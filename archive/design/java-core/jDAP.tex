
% This file contains the design for the reimplementation of the DODS DAS 
% using Java.
%
% $Id$

\documentclass[12pt]{article}
\usepackage{html,psfig}

\psfigurepath{figs}

\input{../../../boiler/html-refs}

\begin{document}

\title{Design of a Java API for DODS}
\author{James Gallagher}
\date{\today}

\maketitle

\begin{abstract}
  
  This document contains the design of a Java API for DODS.  The Java API for
  DODS is implemented by the package {\em EDU.uri.dods}. The API consists of
  the classes {\em DODSException}, {\em DAS}, {\em DDS}, {\em BaseType} as
  well as classes for client support and server support. For information on
  these classes (except for {\em DODSException}) see the DODS User's guide
  and DODS Programmer's guide. The DODSException classes are used to report
  errors using the Java runtime exception mechanism. The Java API is similar
  to the \Cpp\ API (See the DODS Programmer's Guide). However, some of the
  fine points of organization have been changed because more is known about
  how the objects are used and/or because the changes make for smoother use
  by Java programs.

\end{abstract}

\input{../../../boiler/warning}
\input{../../../boiler/developers}
\begin{htmlonly}
\pslink{file://dods.gso.uri.edu/pub/DODS/JDAS.ps}
\end{htmlonly}

\clearpage

\tableofcontents

\clearpage

\section{Introduction}
\label{introduction}

This describes the Java API for DODS. The Java API will do the same basic
things as the \Cpp\ API\@. In some places the Java API may differ from the
\Cpp\ API because either we have learned that the \Cpp\ API could/should be
improved or because changes will make the API easier to use with Java.

The Java API {\em must} be able to interoperate with the \Cpp\ API\@.

All of the classes in this API are members of the package {\em EDU.uri.dods}.

\section{General Requirements}

The Java API {\em must} be able to interoperate with the \Cpp\ API\@.

\section{DODSException}

Empty

\section{DAS}

The DAS class is used to hold attribute information for datasets. Each data
set has one externally visible attribute object. There may be several sources
of information that are combined by the DODS server to product that
attribute object. For example, a particular HDF dataset's DAS object might be
derived from a cached DAS object whose contents in turn might have been
derived from the HDF data file's attribute information along with some
supplemental attribute information stored in a text file. 

The requirements of the Java API for the DAS object are fairly simple:
Implement an interface for DAS objects that is similar to the \Cpp\  class's
API and be able to intern and generate persistent forms of DAS that are
completely compatible with those interned and generated by the \Cpp\  class.

\subsection{Object Hierarchy}
\label{das:object-hierarchy}

The object hierarchy of the proposed Java DAS class is shown in
Figure~\ref{fig:das:hier}. For information on reading Booch diagrams, see
\cite{booch:oo-analysis}. I have tried to keep these diagrams simple and in
the process I have omitted some of the details that Booch uses. In the figure
the dashed blobs are classes, solid lines indicate `has-a' and the number or
letter next to a dark circle indicates how many instances are contained. For
example, in the figure the class DAS contains $N$ instances of Attribute.

There are two classes in this implementation of DAS. The DAS class and the
Attribute class. The Attribute class contains objects for the name (String)
and a vector of values (Vector). Also stored in the Attribute class is type
information which describes the type of information held in the Vector
{\em values}. 

A general feature of the the DAS object is that attributes may be either
scalar or vector. For example, an attribute {\tt units} would probably be a
scalar string while an attribute such as {\tt investigators} would probably
be a vector of strings. In this design both scalar and vector values are
stored in a Java Vector object. For a scalar attribute this Vector has only
one element.

Note that users of the DAS and Attribute classes never access the {\tt values}
or {\tt name} fields.

Another general feature of DAS is that an attribute value may be another
collection of attributes. In the \Cpp\ software this grew out of usage and
the implementation is fairly involved (considering the simplicity of the
concept). In this version of DAS the {\tt values} object holds instances of
Attribute. This works because Vector is a container of generic Objects. See
Figure~\ref{fig:das:instance}.

\begin{figure}
\centerline{\psfig{figure=jDAS-hier.ps}}
\caption{The hierarchy of the Java DAS classes. Note that the solid lines
  represent `has-a' relationships and that none of the classes in this
  diagram inherit from any object other than Java's Object class.}
\label{fig:das:hier}
\end{figure}

\begin{figure}
\centerline{\psfig{figure=Attribute-classes.ps}}
\caption{Example instances of the Java DAS class hierarchy.}
\label{fig:das:instance}
\end{figure}

The Java API for DAS stores and returns actual Byte, ..., objects
rather than the string representations for those objects as is the case with
the \Cpp\ software. This should simplify use for Java client software.

\subsection{DAS API}
\label{DAS-API}

\begin{itemize}

\item See EDU.uri.dods.DAS.ps for \htmladdnormallink{DAS documentation}
  {http://dcz.cvo.oneworld.com/Java-API/EDU.uri.dods.DAS.html}.

\item See EDU.uri.dods.Attribute.ps for \htmladdnormallink{Attribute
    documentation}
  {http://dcz.cvo.oneworld.com/Java-API/EDU.uri.dods.Attribute.html}. 

\end{itemize}

\section{DDS}

There are three important objects that comprise the server-side of DODS in
addition to the data type objects. These are the DDS, constraint and
DODSFilter objects. 

The DODSFilter object is used to unify different implementations of the three
filter programs and increase the change that filter programs/servers built by
other groups will conform to the `standards' set by the servers we provide.

The constraint object is not implemented as a separate object in the \Cpp\
software but it is a discrete entity. It contains the parse tree of the
constraint expression associated with the current data access operation
(which the data filter is `answering').

The DDS object is a container for the data type objects which contain
information about, and the data of, various parts of the dataset. In the
context of the data filter program, the DDS object may be thought of as the
environment in which the constraint is evaluated. Thus a sensible way to
reorganize the DODSFilter,constraint and DDS objects is to formalize that
relationship. DODSFilter becomes the evaluator for the CE and contains both
the CE and DDS object. The DDS object becomes simpler and no longer the the
CE and the CE becomes a full-fledged object.

\section{Data Types}

To expedite CE evaluation and the design of the CE functions, I have added a
Boolean data-type to DODS.

\section{Client-Side Support}

Empty

\section{Server-Side Support}

Empty

\clearpage

\addcontentsline{toc}{section}{Bibliography}
\bibliographystyle{plain}
\bibliography{../../../boiler/dods}

\end{document}

