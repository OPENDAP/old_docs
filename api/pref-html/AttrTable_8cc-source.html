<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libdap++: AttrTable.cc Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>AttrTable.cc</h1><a href="AttrTable_8cc.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00002 <span class="comment">// -*- mode: c++; c-basic-offset:4 -*-</span>
00003 
00004 <span class="comment">// This file is part of libdap, A C++ implementation of the OPeNDAP Data</span>
00005 <span class="comment">// Access Protocol.</span>
00006 
00007 <span class="comment">// Copyright (c) 2002,2003 OPeNDAP, Inc.</span>
00008 <span class="comment">// Author: James Gallagher &lt;jgallagher@opendap.org&gt;</span>
00009 <span class="comment">//</span>
00010 <span class="comment">// This library is free software; you can redistribute it and/or</span>
00011 <span class="comment">// modify it under the terms of the GNU Lesser General Public</span>
00012 <span class="comment">// License as published by the Free Software Foundation; either</span>
00013 <span class="comment">// version 2.1 of the License, or (at your option) any later version.</span>
00014 <span class="comment">// </span>
00015 <span class="comment">// This library is distributed in the hope that it will be useful,</span>
00016 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00017 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00018 <span class="comment">// Lesser General Public License for more details.</span>
00019 <span class="comment">// </span>
00020 <span class="comment">// You should have received a copy of the GNU Lesser General Public</span>
00021 <span class="comment">// License along with this library; if not, write to the Free Software</span>
00022 <span class="comment">// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00023 <span class="comment">//</span>
00024 <span class="comment">// You can contact OPeNDAP, Inc. at PO Box 112, Saunderstown, RI. 02874-0112.</span>
00025  
00026 <span class="comment">// (c) COPYRIGHT URI/MIT 1994-1999</span>
00027 <span class="comment">// Please read the full copyright statement in the file COPYRIGHT_URI.</span>
00028 <span class="comment">//</span>
00029 <span class="comment">// Authors:</span>
00030 <span class="comment">//      jhrg,jimg       James Gallagher &lt;jgallagher@gso.uri.edu&gt;</span>
00031 
00032 <span class="comment">// jhrg 7/29/94</span>
00033 
00034 <span class="preprocessor">#include "<a class="code" href="config__dap_8h.html">config_dap.h</a>"</span>
00035 
00036 <span class="keyword">static</span> <span class="keywordtype">char</span> rcsid[] <a class="code" href="config__dap_8h.html#a49">not_used</a> =<span class="stringliteral">"$Id$"</span>;
00037 
00038 <span class="preprocessor">#ifdef __GNUG__</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#pragma implementation</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00041 <span class="preprocessor"></span>
00042 <span class="preprocessor">#include &lt;assert.h&gt;</span>
00043 
00044 <span class="preprocessor">#include &lt;iostream&gt;</span>
00045 
00046 <span class="preprocessor">#include "<a class="code" href="Error_8h.html">Error.h</a>"</span>
00047 <span class="preprocessor">#include "<a class="code" href="debug_8h.html">debug.h</a>"</span>
00048 <span class="preprocessor">#include "<a class="code" href="util_8h.html">util.h</a>"</span>
00049 <span class="preprocessor">#include "<a class="code" href="AttrTable_8h.html">AttrTable.h</a>"</span>
00050 <span class="preprocessor">#include "<a class="code" href="escaping_8h.html">escaping.h</a>"</span>
00051 <span class="preprocessor">#include "<a class="code" href="AttrIterAdapter_8h.html">AttrIterAdapter.h</a>"</span>
00052 
00053 <span class="keyword">using</span> std::cerr;
00054 <span class="keyword">using</span> std::string;
00055 <span class="keyword">using</span> std::endl;
00056 
00057 <span class="preprocessor">#if defined(_MSC_VER) &amp;&amp; (_MSC_VER == 1200)  //  VC++ 6.0 only</span>
00058 <span class="preprocessor"></span><span class="keyword">using</span> std::vector&lt;string&gt;;
00059 <span class="preprocessor">#else</span>
00060 <span class="preprocessor"></span><span class="keyword">using</span> std::vector;
00061 <span class="preprocessor">#endif</span>
00062 <span class="preprocessor"></span>
00063 string 
00064 AttrTable::AttrType_to_String(<span class="keyword">const</span> AttrType at)
00065 {
00066     <span class="keywordflow">switch</span> (at) {
00067       <span class="keywordflow">case</span> <a class="code" href="AttrTable_8h.html#a12a2">Attr_container</a>: <span class="keywordflow">return</span> <span class="stringliteral">"Container"</span>;
00068       <span class="keywordflow">case</span> <a class="code" href="AttrTable_8h.html#a12a3">Attr_byte</a>: <span class="keywordflow">return</span> <span class="stringliteral">"Byte"</span>;
00069       <span class="keywordflow">case</span> <a class="code" href="AttrTable_8h.html#a12a4">Attr_int16</a>: <span class="keywordflow">return</span> <span class="stringliteral">"Int16"</span>;
00070       <span class="keywordflow">case</span> <a class="code" href="AttrTable_8h.html#a12a5">Attr_uint16</a>: <span class="keywordflow">return</span> <span class="stringliteral">"Uint16"</span>;
00071       <span class="keywordflow">case</span> <a class="code" href="AttrTable_8h.html#a12a6">Attr_int32</a>: <span class="keywordflow">return</span> <span class="stringliteral">"Int32"</span>;
00072       <span class="keywordflow">case</span> <a class="code" href="AttrTable_8h.html#a12a7">Attr_uint32</a>: <span class="keywordflow">return</span> <span class="stringliteral">"Uint32"</span>;
00073       <span class="keywordflow">case</span> <a class="code" href="AttrTable_8h.html#a12a8">Attr_float32</a>: <span class="keywordflow">return</span> <span class="stringliteral">"Float32"</span>;
00074       <span class="keywordflow">case</span> <a class="code" href="AttrTable_8h.html#a12a9">Attr_float64</a>: <span class="keywordflow">return</span> <span class="stringliteral">"Float64"</span>;
00075       <span class="keywordflow">case</span> <a class="code" href="AttrTable_8h.html#a12a10">Attr_string</a>: <span class="keywordflow">return</span> <span class="stringliteral">"String"</span>;
00076       <span class="keywordflow">case</span> <a class="code" href="AttrTable_8h.html#a12a11">Attr_url</a>: <span class="keywordflow">return</span> <span class="stringliteral">"Url"</span>;
00077       <span class="keywordflow">default</span>: <span class="keywordflow">return</span> <span class="stringliteral">""</span>;
00078     }
00079 }
00080 
00081 <a class="code" href="AttrTable_8h.html#a12">AttrType</a>
00082 AttrTable::String_to_AttrType(<span class="keyword">const</span> string &amp;s)
00083 {
00084     string s2 = s;
00085     <a class="code" href="util_8cc.html#a12">downcase</a>(s2);
00086 
00087     <span class="keywordflow">if</span> (s2 == <span class="stringliteral">"container"</span>)
00088     <span class="keywordflow">return</span> <a class="code" href="AttrTable_8h.html#a12a2">Attr_container</a>;
00089     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s2 == <span class="stringliteral">"byte"</span>)
00090     <span class="keywordflow">return</span> <a class="code" href="AttrTable_8h.html#a12a3">Attr_byte</a>;
00091     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s2 == <span class="stringliteral">"int16"</span>)
00092     <span class="keywordflow">return</span> <a class="code" href="AttrTable_8h.html#a12a4">Attr_int16</a>;
00093     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s2 == <span class="stringliteral">"uint16"</span>)
00094     <span class="keywordflow">return</span> <a class="code" href="AttrTable_8h.html#a12a5">Attr_uint16</a>;
00095     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s2 == <span class="stringliteral">"int32"</span>)
00096     <span class="keywordflow">return</span> <a class="code" href="AttrTable_8h.html#a12a6">Attr_int32</a>;
00097     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s2 == <span class="stringliteral">"uint32"</span>)
00098     <span class="keywordflow">return</span> <a class="code" href="AttrTable_8h.html#a12a7">Attr_uint32</a>;
00099     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s2 == <span class="stringliteral">"float32"</span>)
00100     <span class="keywordflow">return</span> <a class="code" href="AttrTable_8h.html#a12a8">Attr_float32</a>;
00101     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s2 == <span class="stringliteral">"float64"</span>)
00102     <span class="keywordflow">return</span> <a class="code" href="AttrTable_8h.html#a12a9">Attr_float64</a>;
00103     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s2 == <span class="stringliteral">"string"</span>)
00104     <span class="keywordflow">return</span> <a class="code" href="AttrTable_8h.html#a12a10">Attr_string</a>;
00105     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s2 == <span class="stringliteral">"url"</span>)
00106     <span class="keywordflow">return</span> <a class="code" href="AttrTable_8h.html#a12a11">Attr_url</a>;
00107     <span class="keywordflow">else</span> 
00108     <span class="keywordflow">return</span> <a class="code" href="AttrTable_8h.html#a12a1">Attr_unknown</a>;
00109 }
00110 
00113 <span class="keywordtype">void</span>
<a name="l00114"></a><a class="code" href="classAttrTable.html#DASb1">00114</a> <a class="code" href="classAttrTable.html#DASb1">AttrTable::clone</a>(<span class="keyword">const</span> <a class="code" href="classAttrTable.html">AttrTable</a> &amp;at)
00115 {
00116     <a class="code" href="classAttrTable.html#DASw0">Attr_citer</a> i = at.<a class="code" href="classAttrTable.html#AttrTabler1">attr_map</a>.begin() ;
00117     <a class="code" href="classAttrTable.html#DASw0">Attr_citer</a> ie = at.<a class="code" href="classAttrTable.html#AttrTabler1">attr_map</a>.end() ;
00118     <span class="keywordflow">for</span>( ; i != ie; i++ )
00119     {
00120     <a class="code" href="structAttrTable_1_1entry.html">entry</a> *e = <span class="keyword">new</span> <a class="code" href="structAttrTable_1_1entry.html">entry</a>( *(*i) ) ;
00121     attr_map.push_back( e ) ;
00122     }
00123 }
00124 
<a name="l00128"></a><a class="code" href="classAttrTable.html#AttrTablez3_0">00128</a> <a class="code" href="classAttrTable.html#AttrTablez3_0">AttrTable::AttrTable</a>()
00129 {
00130 }
00131 
<a name="l00132"></a><a class="code" href="classAttrTable.html#AttrTablez3_1">00132</a> <a class="code" href="classAttrTable.html#AttrTablez3_0">AttrTable::AttrTable</a>(<span class="keyword">const</span> <a class="code" href="classAttrTable.html">AttrTable</a> &amp;rhs)
00133 {
00134     <a class="code" href="classAttrTable.html#DASb1">clone</a>(rhs);
00135 }
00136 
00137 <span class="comment">// Private</span>
00138 <span class="keywordtype">void</span>
00139 AttrTable::delete_attr_table() 
00140 {
00141     <span class="keywordflow">for</span> (<a class="code" href="classAttrTable.html#DASw1">Attr_iter</a> i = attr_map.begin(); i != attr_map.end(); i++)
00142     {
00143     entry *e = *i ;     <span class="comment">// Why not 'delete *i;'? 02/25/03 jhrg</span>
00144     <span class="keyword">delete</span> e ;
00145     }
00146 }
00147 
<a name="l00148"></a><a class="code" href="classAttrTable.html#AttrTablez3_2">00148</a> <a class="code" href="classAttrTable.html#AttrTablez3_2">AttrTable::~AttrTable</a>()
00149 {
00150     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Entering ~AttrTable ("</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="stringliteral">")"</span> &lt;&lt; endl);
00151     delete_attr_table();
00152     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Exiting ~AttrTable"</span> &lt;&lt; endl);
00153 }
00154 
00155 <a class="code" href="classAttrTable.html">AttrTable</a> &amp;
<a name="l00156"></a><a class="code" href="classAttrTable.html#AttrTablez3_3">00156</a> <a class="code" href="classAttrTable.html#AttrTablez3_3">AttrTable::operator=</a>(<span class="keyword">const</span> <a class="code" href="classAttrTable.html">AttrTable</a> &amp;rhs)
00157 {
00158     <span class="keywordflow">if</span> (<span class="keyword">this</span> != &amp;rhs) {
00159     delete_attr_table();
00160     <a class="code" href="classAttrTable.html#DASb1">clone</a>(rhs);
00161     }
00162 
00163     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00164 }       
00166 
00172 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00173"></a><a class="code" href="classAttrTable.html#DASa12">00173</a> <a class="code" href="classAttrTable.html#DASa12">AttrTable::get_size</a>()<span class="keyword"> const</span>
00174 <span class="keyword"></span>{
00175     <span class="keywordflow">return</span> attr_map.size();
00176 }
00177 
00180 string
<a name="l00181"></a><a class="code" href="classAttrTable.html#DASa13">00181</a> <a class="code" href="classAttrTable.html#DASa13">AttrTable::get_name</a>()
00182 {
00183     <span class="keywordflow">return</span> d_name;
00184 }
00185 
00188 <span class="keywordtype">void</span>
<a name="l00189"></a><a class="code" href="classAttrTable.html#DASa14">00189</a> <a class="code" href="classAttrTable.html#DASa14">AttrTable::set_name</a>(<span class="keyword">const</span> string &amp;n)
00190 {
00191     d_name = <a class="code" href="escaping_8cc.html#a7">www2id</a>(n);
00192 }
00193 
00211 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00212"></a><a class="code" href="classAttrTable.html#DASa15">00212</a> <a class="code" href="classAttrTable.html#DASa15">AttrTable::append_attr</a>(<span class="keyword">const</span> string &amp;name, <span class="keyword">const</span> string &amp;type, 
00213                <span class="keyword">const</span> string &amp;attribute) <span class="keywordflow">throw</span> (<a class="code" href="classError.html">Error</a>)
00214 {
00215     string lname = <a class="code" href="escaping_8cc.html#a7">www2id</a>(name);
00216 
00217     <a class="code" href="classAttrTable.html#DASw1">Attr_iter</a> iter = simple_find( lname, <span class="keyword">true</span> ) ;
00218 
00219     <span class="comment">// If the types don't match OR this attribute is a container, calling</span>
00220     <span class="comment">// this mfunc is an error!</span>
00221     <span class="keywordflow">if</span> (iter != attr_map.end() &amp;&amp; ((*iter)-&gt;type != String_to_AttrType(type)))
00222     <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(string(<span class="stringliteral">"An attribute called `"</span>) + name 
00223             + string(<span class="stringliteral">"' already exists but is of a different type"</span>));
00224     <span class="keywordflow">if</span> (iter != attr_map.end() &amp;&amp; (<a class="code" href="HTTPConnect_8h.html#a0">get_type</a>(iter) == <span class="stringliteral">"Container"</span>))
00225     <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(string(<span class="stringliteral">"An attribute called `"</span>) + name 
00226             + string(<span class="stringliteral">"' already exists but is a container."</span>));
00227 
00228     <span class="keywordflow">if</span> (iter != attr_map.end()) {    <span class="comment">// Must be a new attribute value; add it.</span>
00229         (*iter)-&gt;attr-&gt;push_back(attribute);
00230     <span class="keywordflow">return</span> (*iter)-&gt;attr-&gt;size();
00231     } <span class="keywordflow">else</span> {            <span class="comment">// Must be a completely new attribute; add it</span>
00232     <a class="code" href="structAttrTable_1_1entry.html">entry</a> *e = <span class="keyword">new</span> <a class="code" href="structAttrTable_1_1entry.html">entry</a>;
00233 
00234     e-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo0">name</a> = lname;
00235     e-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo2">is_alias</a> = <span class="keyword">false</span>;
00236     e-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo1">type</a> = String_to_AttrType(type); <span class="comment">// Record type using standard names.</span>
00237     e-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo5">attr</a> = <span class="keyword">new</span> vector&lt;string&gt;;
00238     e-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo5">attr</a>-&gt;push_back(attribute);
00239 
00240     attr_map.push_back(e);
00241     
00242     <span class="keywordflow">return</span> e-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo5">attr</a>-&gt;size(); <span class="comment">// return the length of the attr vector</span>
00243     }
00244 }
00245 
00246 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00247"></a><a class="code" href="classAttrTable.html#DASa16">00247</a> <a class="code" href="classAttrTable.html#DASa15">AttrTable::append_attr</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">const</span> <span class="keywordtype">char</span> *type, <span class="keyword">const</span> <span class="keywordtype">char</span> *attr)
00248     <span class="keywordflow">throw</span> (<a class="code" href="classError.html">Error</a>)
00249 {
00250     <span class="keywordflow">return</span> append_attr((string)name, (string)type, (string)attr);
00251 }
00252 
00261 <a class="code" href="classAttrTable.html">AttrTable</a> *
<a name="l00262"></a><a class="code" href="classAttrTable.html#DASa17">00262</a> <a class="code" href="classAttrTable.html#DASa17">AttrTable::append_container</a>(<span class="keyword">const</span> string &amp;name) <span class="keywordflow">throw</span> (<a class="code" href="classError.html">Error</a>)
00263 {
00264     <a class="code" href="classAttrTable.html">AttrTable</a> *new_at = <span class="keyword">new</span> <a class="code" href="classAttrTable.html">AttrTable</a> ;
00265     AttrTable *ret = NULL ;
00266     <span class="keywordflow">try</span>
00267     {
00268     ret = append_container( new_at, name ) ;
00269     }
00270     <span class="keywordflow">catch</span>( <a class="code" href="classError.html">Error</a> &amp;e )
00271     {
00272     <span class="comment">// an error occurred, attribute with that name already exists</span>
00273     <span class="keyword">delete</span> new_at ;
00274     <span class="keywordflow">throw</span> e ;
00275     }
00276     <span class="keywordflow">return</span> ret ;
00277 }
00278 
00288 <a class="code" href="classAttrTable.html">AttrTable</a> *
<a name="l00289"></a><a class="code" href="classAttrTable.html#DASa18">00289</a> <a class="code" href="classAttrTable.html#DASa17">AttrTable::append_container</a>(<a class="code" href="classAttrTable.html">AttrTable</a> *at, <span class="keyword">const</span> string &amp;name) <span class="keywordflow">throw</span> (<a class="code" href="classError.html">Error</a>)
00290 {
00291     string lname = <a class="code" href="escaping_8cc.html#a7">www2id</a>(name);
00292 
00293     <span class="keywordflow">if</span> (simple_find(name))
00294     <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(string(<span class="stringliteral">"There already exists a container called `"</span>)
00295             + name + string(<span class="stringliteral">"in this attribute table."</span>));
00296 
00297     at-&gt;set_name(lname);
00298 
00299     <a class="code" href="structAttrTable_1_1entry.html">entry</a> *e = <span class="keyword">new</span> <a class="code" href="structAttrTable_1_1entry.html">entry</a>;
00300     e-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo0">name</a> = lname;
00301     e-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo2">is_alias</a> = <span class="keyword">false</span>;
00302     e-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo1">type</a> = <a class="code" href="AttrTable_8h.html#a12a2">Attr_container</a>;
00303     e-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo4">attributes</a> = at;
00304 
00305     attr_map.push_back(e);
00306 
00307     <span class="keywordflow">return</span> e-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo4">attributes</a>;
00308 }
00309 
00324 <span class="keywordtype">void</span>
<a name="l00325"></a><a class="code" href="classAttrTable.html#DASa19">00325</a> <a class="code" href="classAttrTable.html#DASa19">AttrTable::find</a>( <span class="keyword">const</span> string &amp;target, <a class="code" href="classAttrTable.html">AttrTable</a> **at, <a class="code" href="classAttrTable.html#DASw1">Attr_iter</a> &amp;iter )
00326 {
00327     string::size_type dotpos = target.rfind(<span class="charliteral">'.'</span>);
00328     <span class="keywordflow">if</span> (dotpos != string::npos)
00329     {
00330     string container = target.substr(0, dotpos);
00331     string field = target.substr(dotpos+1);
00332 
00333     *at = <a class="code" href="classAttrTable.html#DASa20">find_container</a>( container ) ;
00334     <span class="keywordflow">if</span>(*at)
00335     {
00336         iter = (*at)-&gt;simple_find(field, <span class="keyword">true</span>) ;
00337     } <span class="keywordflow">else</span> {
00338         iter = attr_map.end() ;
00339     }
00340     }
00341     <span class="keywordflow">else</span> {
00342     *at = <span class="keyword">this</span>;
00343     iter = simple_find(target, <span class="keyword">true</span>);
00344     }
00345 }
00346 
00347 <span class="comment">// Private</span>
00354 <span class="comment"></span><a class="code" href="classAttrTable.html#DASw1">AttrTable::Attr_iter</a>
00355 AttrTable::simple_find( <span class="keyword">const</span> string &amp;target, <span class="keywordtype">bool</span> )
00356 {
00357     <a class="code" href="classAttrTable.html#DASw1">Attr_iter</a> i ;
00358     <span class="keywordflow">for</span>( i = attr_map.begin(); i != attr_map.end(); i++ )
00359     {
00360     <span class="keywordflow">if</span>( target == (*i)-&gt;name )
00361     {
00362         <span class="keywordflow">break</span> ;
00363     }
00364     }
00365     <span class="keywordflow">return</span> i ;
00366 }
00367 
00381 <a class="code" href="classAttrTable.html">AttrTable</a> *
<a name="l00382"></a><a class="code" href="classAttrTable.html#DASa20">00382</a> <a class="code" href="classAttrTable.html#DASa20">AttrTable::find_container</a>(<span class="keyword">const</span> string &amp;target)
00383 {
00384     string::size_type dotpos = target.<a class="code" href="classAttrTable.html#DASa19">find</a>(<span class="charliteral">'.'</span>);
00385     <span class="keywordflow">if</span> (dotpos != string::npos) {
00386     string container = target.substr(0, dotpos);
00387     string field = target.substr(dotpos+1);
00388     
00389     <a class="code" href="classAttrTable.html">AttrTable</a> *at= simple_find_container(container);
00390     <span class="keywordflow">return</span> (at) ? at-&gt;<a class="code" href="classAttrTable.html#DASa20">find_container</a>(field) : 0;
00391     }
00392     <span class="keywordflow">else</span> {
00393     <span class="keywordflow">return</span> simple_find_container(target);
00394     }
00395 }
00396 
00397 <span class="comment">// Private</span>
00398 <a class="code" href="classAttrTable.html">AttrTable</a> *
00399 AttrTable::simple_find_container(<span class="keyword">const</span> string &amp;target)
00400 {
00401     <span class="keywordflow">if</span> (<a class="code" href="classAttrTable.html#DASa13">get_name</a>() == target)
00402     <span class="keywordflow">return</span> <span class="keyword">this</span>;
00403 
00404     <span class="keywordflow">for</span> (<a class="code" href="classAttrTable.html#DASw1">Attr_iter</a> i = attr_map.begin(); i != attr_map.end(); i++)
00405     {
00406     <span class="keywordflow">if</span> (<a class="code" href="classAttrTable.html#DASz7_11">is_container</a>(i) &amp;&amp; target == (*i)-&gt;name)
00407     {
00408         <span class="keywordflow">return</span> (*i)-&gt;attributes;
00409     }
00410     }
00411 
00412     <span class="keywordflow">return</span> 0;
00413 }
00414 
00422 
00424 <a class="code" href="classAttrTable.html">AttrTable</a> *
<a name="l00425"></a><a class="code" href="classAttrTable.html#DASz5_0">00425</a> <a class="code" href="classAttrTable.html#DASz5_0">AttrTable::get_attr_table</a>(<span class="keyword">const</span> string &amp;name)
00426 {
00427     <span class="keywordflow">return</span> <a class="code" href="classAttrTable.html#DASa20">find_container</a>(name);
00428 }
00429 
00430 <a class="code" href="classAttrTable.html">AttrTable</a> *
<a name="l00431"></a><a class="code" href="classAttrTable.html#DASz5_1">00431</a> <a class="code" href="classAttrTable.html#DASz5_0">AttrTable::get_attr_table</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00432 {
00433     <span class="keywordflow">return</span> <a class="code" href="classAttrTable.html#DASz5_0">get_attr_table</a>((string)name);
00434 }
00435 
00437 string
<a name="l00438"></a><a class="code" href="classAttrTable.html#DASz5_2">00438</a> <a class="code" href="classAttrTable.html#DASz5_2">AttrTable::get_type</a>(<span class="keyword">const</span> string &amp;name)
00439 {
00440     Pix p = simple_find(name);
00441     <span class="keywordflow">return</span> (p) ?  <a class="code" href="classAttrTable.html#DASz5_2">get_type</a>(p) : (string)<span class="stringliteral">""</span>;
00442 }
00443 
00444 string
<a name="l00445"></a><a class="code" href="classAttrTable.html#DASz5_3">00445</a> <a class="code" href="classAttrTable.html#DASz5_2">AttrTable::get_type</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00446 {
00447     <span class="keywordflow">return</span> <a class="code" href="classAttrTable.html#DASz5_2">get_type</a>((string)name);
00448 }
00449 
00452 <a class="code" href="AttrTable_8h.html#a12">AttrType</a>
<a name="l00453"></a><a class="code" href="classAttrTable.html#DASz5_4">00453</a> <a class="code" href="classAttrTable.html#DASz5_4">AttrTable::get_attr_type</a>(<span class="keyword">const</span> string &amp;name)
00454 {
00455     Pix p = simple_find(name);
00456     <span class="keywordflow">return</span> (p) ?  <a class="code" href="classAttrTable.html#DASz5_4">get_attr_type</a>(p) : <a class="code" href="AttrTable_8h.html#a12a1">Attr_unknown</a>;
00457 }
00458 
00459 <a class="code" href="AttrTable_8h.html#a12">AttrType</a>
<a name="l00460"></a><a class="code" href="classAttrTable.html#DASz5_5">00460</a> <a class="code" href="classAttrTable.html#DASz5_4">AttrTable::get_attr_type</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00461 {
00462     <span class="keywordflow">return</span> <a class="code" href="classAttrTable.html#DASz5_4">get_attr_type</a>((string)name);
00463 }
00464 
00472 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> 
<a name="l00473"></a><a class="code" href="classAttrTable.html#DASz5_6">00473</a> <a class="code" href="classAttrTable.html#DASz5_6">AttrTable::get_attr_num</a>(<span class="keyword">const</span> string &amp;name)
00474 {
00475     <a class="code" href="classAttrTable.html#DASw1">Attr_iter</a> iter = simple_find(name, <span class="keyword">true</span>);
00476     <span class="keywordflow">return</span> (iter != attr_map.end()) ?  <a class="code" href="classAttrTable.html#DASz5_6">get_attr_num</a>(iter) : 0;
00477 }
00478 
00479 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> 
<a name="l00480"></a><a class="code" href="classAttrTable.html#DASz5_7">00480</a> <a class="code" href="classAttrTable.html#DASz5_6">AttrTable::get_attr_num</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00481 {
00482     <span class="keywordflow">return</span> <a class="code" href="classAttrTable.html#DASz5_6">get_attr_num</a>((string)name);
00483 }
00484 
00497 vector&lt;string&gt; *
<a name="l00498"></a><a class="code" href="classAttrTable.html#DASz5_8">00498</a> <a class="code" href="classAttrTable.html#DASz5_8">AttrTable::get_attr_vector</a>(<span class="keyword">const</span> string &amp;name)
00499 {
00500     Pix p = simple_find(name);
00501     <span class="keywordflow">return</span> (p) ?  <a class="code" href="classAttrTable.html#DASz5_8">get_attr_vector</a>(p) : 0;
00502 }
00503 
00504 vector&lt;string&gt; *
<a name="l00505"></a><a class="code" href="classAttrTable.html#DASz5_9">00505</a> <a class="code" href="classAttrTable.html#DASz5_8">AttrTable::get_attr_vector</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00506 {
00507     <span class="keywordflow">return</span> <a class="code" href="classAttrTable.html#DASz5_8">get_attr_vector</a>((string)name);
00508 }
00509 
00526 <span class="keywordtype">void</span>
<a name="l00527"></a><a class="code" href="classAttrTable.html#DASz5_10">00527</a> <a class="code" href="classAttrTable.html#DASz5_10">AttrTable::del_attr</a>(<span class="keyword">const</span> string &amp;name, <span class="keywordtype">int</span> i)
00528 {
00529     string lname = <a class="code" href="escaping_8cc.html#a7">www2id</a>(name);
00530 
00531     <a class="code" href="classAttrTable.html#DASw1">Attr_iter</a> iter = simple_find( lname, <span class="keyword">true</span> ) ;
00532     <span class="keywordflow">if</span> ( iter != attr_map.end() ) {
00533     <span class="keywordflow">if</span> (i == -1) {      <span class="comment">// Delete the whole attribute</span>
00534         <a class="code" href="structAttrTable_1_1entry.html">entry</a> *e = *iter ;
00535         attr_map.erase( iter ) ;
00536         <span class="keyword">delete</span> e ;
00537     }
00538     <span class="keywordflow">else</span> {          <span class="comment">// Delete one element from attribute array</span>
00539         <span class="comment">// Don't try to delete elements from the vector of values if the</span>
00540         <span class="comment">// map is a container!</span>
00541         <span class="keywordflow">if</span> ((*iter)-&gt;type == <a class="code" href="AttrTable_8h.html#a12a2">Attr_container</a>) 
00542         <span class="keywordflow">return</span>;
00543 
00544         vector&lt;string&gt; *sxp = (*iter)-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo5">attr</a>;
00545         
00546         assert(i &gt;= 0 &amp;&amp; i &lt; (int)sxp-&gt;size());
00547         sxp-&gt;erase(sxp-&gt;begin() + i); <span class="comment">// rm the element</span>
00548     }
00549     }
00550 }
00551 
00553 
00556 
00557 <span class="comment">// Private, deprecated</span>
00558 Pix
00559 AttrTable::simple_find(<span class="keyword">const</span> string &amp;target)
00560 {
00561     <span class="keywordflow">for</span> (Pix p = <a class="code" href="classAttrTable.html#DASz7_8">first_attr</a>(); p; <a class="code" href="classAttrTable.html#DASz7_9">next_attr</a>(p))
00562     {
00563     <span class="keywordflow">if</span> (target == <a class="code" href="classAttrTable.html#DASz7_10">attr</a>(p)-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo0">name</a>)
00564     {
00565         <span class="keywordflow">return</span> p ;
00566     }
00567     }
00568     <span class="keywordflow">return</span> (<a class="code" href="classIteratorAdapter.html">IteratorAdapter</a> *)0;
00569 }
00570 
00574 Pix 
<a name="l00575"></a><a class="code" href="classAttrTable.html#DASz7_8">00575</a> <a class="code" href="classAttrTable.html#DASz7_8">AttrTable::first_attr</a>()
00576 {
00577     <a class="code" href="classAttrIterAdapter.html">AttrIterAdapter</a> *i = <span class="keyword">new</span> <a class="code" href="classAttrIterAdapter.html">AttrIterAdapter</a>( attr_map ) ;
00578     i-&gt;<a class="code" href="classAttrIterAdapter.html#AttrIterAdapterz54_0">first</a>() ;
00579     <span class="keywordflow">return</span> i ;
00580 }
00581 
00587 <span class="keywordtype">void</span>
<a name="l00588"></a><a class="code" href="classAttrTable.html#DASz7_9">00588</a> <a class="code" href="classAttrTable.html#DASz7_9">AttrTable::next_attr</a>(Pix p)
00589 {
00590     p.next() ;
00591 }
00592 
00593 <a class="code" href="structAttrTable_1_1entry.html">AttrTable::entry</a> *
<a name="l00594"></a><a class="code" href="classAttrTable.html#DASz7_10">00594</a> <a class="code" href="classAttrTable.html#DASz7_10">AttrTable::attr</a>(Pix p)
00595 {
00596     <a class="code" href="classAttrIterAdapter.html">AttrIterAdapter</a> *i = (<a class="code" href="classAttrIterAdapter.html">AttrIterAdapter</a> *)p.getIterator() ;
00597 
00598     <span class="keywordflow">if</span>( i ) {
00599     <span class="keywordflow">return</span> i-&gt;<a class="code" href="classAttrIterAdapter.html#AttrIterAdapterz56_0">entry</a>() ;
00600     }
00601     <span class="keywordflow">return</span> 0 ;
00602 }
00603 
00606 string
<a name="l00607"></a><a class="code" href="classAttrTable.html#AttrTablez7_4">00607</a> <a class="code" href="classAttrTable.html#DASa13">AttrTable::get_name</a>(Pix p)
00608 {
00609     <a class="code" href="classAttrIterAdapter.html">AttrIterAdapter</a> *i = (<a class="code" href="classAttrIterAdapter.html">AttrIterAdapter</a> *)p.getIterator() ;
00610     assert(i);
00611     <span class="keywordflow">return</span> i-&gt;<a class="code" href="classAttrIterAdapter.html#AttrIterAdapterz56_0">entry</a>()-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo0">name</a> ;
00612 }
00613 
00616 <span class="keywordtype">bool</span>
<a name="l00617"></a><a class="code" href="classAttrTable.html#DASz7_11">00617</a> <a class="code" href="classAttrTable.html#DASz7_11">AttrTable::is_container</a>(Pix p)
00618 {
00619     <a class="code" href="classAttrIterAdapter.html">AttrIterAdapter</a> *i = (<a class="code" href="classAttrIterAdapter.html">AttrIterAdapter</a> *)p.getIterator() ;
00620     assert(i);
00621     <span class="keywordflow">return</span> i-&gt;<a class="code" href="classAttrIterAdapter.html#AttrIterAdapterz56_0">entry</a>()-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo1">type</a> == <a class="code" href="AttrTable_8h.html#a12a2">Attr_container</a>;
00622 }
00623 
00630 <a class="code" href="classAttrTable.html">AttrTable</a> *
<a name="l00631"></a><a class="code" href="classAttrTable.html#DASz7_1">00631</a> <a class="code" href="classAttrTable.html#DASz5_0">AttrTable::get_attr_table</a>(Pix p)
00632 {
00633     <a class="code" href="classAttrIterAdapter.html">AttrIterAdapter</a> *i = (<a class="code" href="classAttrIterAdapter.html">AttrIterAdapter</a> *)p.getIterator() ;
00634     assert(i);
00635     <span class="keywordflow">return</span> i-&gt;<a class="code" href="classAttrIterAdapter.html#AttrIterAdapterz56_0">entry</a>()-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo1">type</a> == <a class="code" href="AttrTable_8h.html#a12a2">Attr_container</a> ? i-&gt;<a class="code" href="classAttrIterAdapter.html#AttrIterAdapterz56_0">entry</a>()-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo4">attributes</a> : 0;
00636 }
00637 
00642 string
<a name="l00643"></a><a class="code" href="classAttrTable.html#DASz7_2">00643</a> <a class="code" href="classAttrTable.html#DASz5_2">AttrTable::get_type</a>(Pix p)
00644 {
00645     <a class="code" href="classAttrIterAdapter.html">AttrIterAdapter</a> *i = (<a class="code" href="classAttrIterAdapter.html">AttrIterAdapter</a> *)p.getIterator() ;
00646     assert(i);
00647     <span class="keywordflow">return</span> AttrType_to_String(i-&gt;<a class="code" href="classAttrIterAdapter.html#AttrIterAdapterz56_0">entry</a>()-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo1">type</a>);
00648 }
00649 
00654 <a class="code" href="AttrTable_8h.html#a12">AttrType</a>
<a name="l00655"></a><a class="code" href="classAttrTable.html#DASz7_3">00655</a> <a class="code" href="classAttrTable.html#DASz5_4">AttrTable::get_attr_type</a>(Pix p)
00656 {
00657     <span class="keywordflow">return</span> <a class="code" href="classAttrTable.html#DASz7_10">attr</a>(p)-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo1">type</a>;
00658 }
00659 
00670 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> 
<a name="l00671"></a><a class="code" href="classAttrTable.html#DASz7_4">00671</a> <a class="code" href="classAttrTable.html#DASz5_6">AttrTable::get_attr_num</a>(Pix p)
00672 {
00673     assert(p);
00674     <span class="keywordflow">return</span> (<a class="code" href="classAttrTable.html#DASz7_10">attr</a>(p)-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo1">type</a> == <a class="code" href="AttrTable_8h.html#a12a2">Attr_container</a>)
00675     ? <a class="code" href="classAttrTable.html#DASz7_10">attr</a>(p)-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo4">attributes</a>-&gt;<a class="code" href="classAttrTable.html#DASa12">get_size</a>() 
00676     : <a class="code" href="classAttrTable.html#DASz7_10">attr</a>(p)-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo5">attr</a>-&gt;size();
00677 }
00678 
00697 string
<a name="l00698"></a><a class="code" href="classAttrTable.html#DASz7_6">00698</a> <a class="code" href="classAttrTable.html#DASz7_5">AttrTable::get_attr</a>(Pix p, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i)
00699 {
00700     assert(p);
00701     <span class="keywordflow">return</span> <a class="code" href="classAttrTable.html#DASz7_10">attr</a>(p)-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo1">type</a> == <a class="code" href="AttrTable_8h.html#a12a2">Attr_container</a> ? (string)<span class="stringliteral">"None"</span> : (*<a class="code" href="classAttrTable.html#DASz7_10">attr</a>(p)-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo5">attr</a>)[i];
00702 }
00703 
00719 string
<a name="l00720"></a><a class="code" href="classAttrTable.html#DASz7_5">00720</a> <a class="code" href="classAttrTable.html#DASz7_5">AttrTable::get_attr</a>(<span class="keyword">const</span> string &amp;name, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i)
00721 {
00722     Pix p = simple_find(name);
00723     <span class="keywordflow">return</span> (p) ? <a class="code" href="classAttrTable.html#DASz7_5">get_attr</a>(p, i) : (string)<span class="stringliteral">""</span>;
00724 }
00725 
00739 vector&lt;string&gt; *
<a name="l00740"></a><a class="code" href="classAttrTable.html#DASz7_7">00740</a> <a class="code" href="classAttrTable.html#DASz5_8">AttrTable::get_attr_vector</a>(Pix p)
00741 {
00742     assert(p);
00743     <span class="keywordflow">return</span> <a class="code" href="classAttrTable.html#DASz7_10">attr</a>(p)-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo1">type</a> != <a class="code" href="AttrTable_8h.html#a12a2">Attr_container</a> ? <a class="code" href="classAttrTable.html#DASz7_10">attr</a>(p)-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo5">attr</a> : 0;
00744 }
00745 
00762 Pix 
<a name="l00763"></a><a class="code" href="classAttrTable.html#DASz7_0">00763</a> <a class="code" href="classAttrTable.html#DASa19">AttrTable::find</a>(<span class="keyword">const</span> string &amp;target, <a class="code" href="classAttrTable.html">AttrTable</a> **at)
00764 {
00765     string::size_type dotpos = target.rfind(<span class="charliteral">'.'</span>);
00766     <span class="keywordflow">if</span> (dotpos != string::npos) {
00767     string container = target.substr(0, dotpos);
00768     string field = target.substr(dotpos+1);
00769     
00770     *at = <a class="code" href="classAttrTable.html#DASa20">find_container</a>(container);
00771     <span class="keywordflow">return</span> (*at) ? (*at)-&gt;simple_find(field) : (<a class="code" href="classIteratorAdapter.html">IteratorAdapter</a> *)0;
00772     }
00773     <span class="keywordflow">else</span> {
00774     *at = <span class="keyword">this</span>;
00775     <span class="keywordflow">return</span> simple_find(target);
00776     }
00777 }
00778 
00783 <a class="code" href="classAttrTable.html#DASw1">AttrTable::Attr_iter</a>
<a name="l00784"></a><a class="code" href="classAttrTable.html#DASz9_8">00784</a> <a class="code" href="classAttrTable.html#DASz9_8">AttrTable::attr_begin</a>()
00785 {
00786     <span class="keywordflow">return</span> attr_map.begin() ;
00787 }
00788 
00792 <a class="code" href="classAttrTable.html#DASw1">AttrTable::Attr_iter</a>
<a name="l00793"></a><a class="code" href="classAttrTable.html#DASz9_9">00793</a> <a class="code" href="classAttrTable.html#DASz9_9">AttrTable::attr_end</a>()
00794 {
00795     <span class="keywordflow">return</span> attr_map.end() ;
00796 }
00797 
00806 <a class="code" href="classAttrTable.html#DASw1">AttrTable::Attr_iter</a>
<a name="l00807"></a><a class="code" href="classAttrTable.html#DASz9_10">00807</a> <a class="code" href="classAttrTable.html#DASz9_10">AttrTable::get_attr_iter</a>(<span class="keywordtype">int</span> i)
00808 {
00809     <span class="keywordflow">return</span> attr_map.begin() + i;
00810 }
00811 
00813 string
<a name="l00814"></a><a class="code" href="classAttrTable.html#AttrTablez9_4">00814</a> <a class="code" href="classAttrTable.html#DASa13">AttrTable::get_name</a>( <a class="code" href="classAttrTable.html#DASw1">Attr_iter</a> &amp;iter )
00815 {
00816     assert( iter != attr_map.end() ) ;
00817 
00818     <span class="keywordflow">return</span> (*iter)-&gt;name ;
00819 }
00820 
00822 <span class="keywordtype">bool</span>
<a name="l00823"></a><a class="code" href="classAttrTable.html#DASz9_7">00823</a> <a class="code" href="classAttrTable.html#DASz7_11">AttrTable::is_container</a>( <a class="code" href="classAttrTable.html#DASw1">Attr_iter</a> &amp;i )
00824 {
00825     <span class="keywordflow">return</span> (*i)-&gt;type == <a class="code" href="AttrTable_8h.html#a12a2">Attr_container</a> ;
00826 }
00827 
00833 <a class="code" href="classAttrTable.html">AttrTable</a> *
<a name="l00834"></a><a class="code" href="classAttrTable.html#DASz9_0">00834</a> <a class="code" href="classAttrTable.html#DASz5_0">AttrTable::get_attr_table</a>( <a class="code" href="classAttrTable.html#DASw1">Attr_iter</a> &amp;iter )
00835 {
00836     assert( iter != attr_map.end() ) ;
00837     <span class="keywordflow">return</span> (*iter)-&gt;type == <a class="code" href="AttrTable_8h.html#a12a2">Attr_container</a> ? (*iter)-&gt;attributes : 0 ;
00838 }
00839 
00843 string
<a name="l00844"></a><a class="code" href="classAttrTable.html#DASz9_1">00844</a> <a class="code" href="classAttrTable.html#DASz5_2">AttrTable::get_type</a>( <a class="code" href="classAttrTable.html#DASw1">Attr_iter</a> &amp;iter )
00845 {
00846     assert( iter != attr_map.end() ) ;
00847     <span class="keywordflow">return</span> AttrType_to_String( (*iter)-&gt;type ) ;
00848 }
00849 
00853 <a class="code" href="AttrTable_8h.html#a12">AttrType</a>
<a name="l00854"></a><a class="code" href="classAttrTable.html#DASz9_2">00854</a> <a class="code" href="classAttrTable.html#DASz5_4">AttrTable::get_attr_type</a>( <a class="code" href="classAttrTable.html#DASw1">Attr_iter</a> &amp;iter )
00855 {
00856     <span class="keywordflow">return</span> (*iter)-&gt;type ;
00857 }
00858 
00866 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00867"></a><a class="code" href="classAttrTable.html#DASz9_3">00867</a> <a class="code" href="classAttrTable.html#DASz5_6">AttrTable::get_attr_num</a>( <a class="code" href="classAttrTable.html#DASw1">Attr_iter</a> &amp;iter )
00868 {
00869     assert( iter != attr_map.end() ) ;
00870     <span class="keywordflow">return</span> ( (*iter)-&gt;type == <a class="code" href="AttrTable_8h.html#a12a2">Attr_container</a> )
00871     ? (*iter)-&gt;attributes-&gt;get_size()
00872     : (*iter)-&gt;attr-&gt;size() ;
00873 }
00874 
00891 string
<a name="l00892"></a><a class="code" href="classAttrTable.html#DASz9_5">00892</a> <a class="code" href="classAttrTable.html#DASz7_5">AttrTable::get_attr</a>(<a class="code" href="classAttrTable.html#DASw1">Attr_iter</a> &amp;iter, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i)
00893 {
00894     assert(iter != attr_map.end());
00895     <span class="keywordflow">return</span> (*iter)-&gt;type == <a class="code" href="AttrTable_8h.html#a12a2">Attr_container</a> ? (string)<span class="stringliteral">"None"</span> : (*(*iter)-&gt;attr)[i];
00896 }
00897 
00898 string
<a name="l00899"></a><a class="code" href="classAttrTable.html#DASz9_4">00899</a> <a class="code" href="classAttrTable.html#DASz7_5">AttrTable::get_attr</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i)
00900 {
00901     <span class="keywordflow">return</span> <a class="code" href="classAttrTable.html#DASz7_5">get_attr</a>((string)name, i);
00902 }
00903 
00915 vector&lt;string&gt; *
<a name="l00916"></a><a class="code" href="classAttrTable.html#DASz9_6">00916</a> <a class="code" href="classAttrTable.html#DASz5_8">AttrTable::get_attr_vector</a>(<a class="code" href="classAttrTable.html#DASw1">Attr_iter</a> &amp;iter)
00917 {
00918     assert(iter != attr_map.end());
00919     <span class="keywordflow">return</span> (*iter)-&gt;type != <a class="code" href="AttrTable_8h.html#a12a2">Attr_container</a> ? (*iter)-&gt;attr : 0;
00920 }
00921 
00923 
00924 <span class="comment">// Alias an attribute table. The alias should be added to this object.</span>
00930 <span class="comment"></span><span class="keywordtype">void</span>
<a name="l00931"></a><a class="code" href="classAttrTable.html#DASa21">00931</a> <a class="code" href="classAttrTable.html#DASa21">AttrTable::add_container_alias</a>(<span class="keyword">const</span> string &amp;name, <a class="code" href="classAttrTable.html">AttrTable</a> *src) 
00932     <span class="keywordflow">throw</span> (<a class="code" href="classError.html">Error</a>)
00933 {
00934     string lname = <a class="code" href="escaping_8cc.html#a7">www2id</a>(name);
00935 
00936     <span class="keywordflow">if</span> (simple_find(lname))
00937     <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(string(<span class="stringliteral">"There already exists a container called `"</span>)
00938             + name + string(<span class="stringliteral">"in this attribute table."</span>));
00939 
00940     <a class="code" href="structAttrTable_1_1entry.html">entry</a> *e = <span class="keyword">new</span> <a class="code" href="structAttrTable_1_1entry.html">entry</a>;
00941     e-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo0">name</a> = lname;
00942     e-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo2">is_alias</a> = <span class="keyword">true</span>;
00943     e-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo3">aliased_to</a> = src-&gt;get_name();
00944     e-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo1">type</a> = <a class="code" href="AttrTable_8h.html#a12a2">Attr_container</a>;
00945 
00946     e-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo4">attributes</a> = src;
00947 
00948     attr_map.push_back(e);
00949 }
00950 
00963 <span class="keywordtype">void</span>
<a name="l00964"></a><a class="code" href="classAttrTable.html#DASa22">00964</a> <a class="code" href="classAttrTable.html#DASa22">AttrTable::add_value_alias</a>(<a class="code" href="classAttrTable.html">AttrTable</a> *das, <span class="keyword">const</span> string &amp;name, 
00965                <span class="keyword">const</span> string &amp;source) <span class="keywordflow">throw</span> (<a class="code" href="classError.html">Error</a>)
00966 {
00967     string lname = <a class="code" href="escaping_8cc.html#a7">www2id</a>(name);
00968     string lsource = <a class="code" href="escaping_8cc.html#a7">www2id</a>(source);
00969 
00970     <span class="comment">// find the container that holds #source# and then find #source#'s Pix</span>
00971     <span class="comment">// within that container. Search at the uppermost level of the attribtue</span>
00972     <span class="comment">// object to find values defined `above' the current container.</span>
00973     <a class="code" href="classAttrTable.html">AttrTable</a> *at;
00974     Pix p = das-&gt;find(lsource, &amp;at);
00975 
00976     <span class="comment">// If #source# is not found by looking at the topmost level, look in the</span>
00977     <span class="comment">// current table (i.e., alias z x where x is in the current container</span>
00978     <span class="comment">// won't be found by looking for `x' at the top level). See test case 26</span>
00979     <span class="comment">// in das-testsuite.</span>
00980     <span class="keywordflow">if</span> (!(at &amp;&amp; p)) {
00981     p = find(lsource, &amp;at);
00982     <span class="keywordflow">if</span> (!(at &amp;&amp; p))
00983         <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(string(<span class="stringliteral">"Could not find the attribute `"</span>)
00984             + source + string(<span class="stringliteral">"' in the attribute object."</span>));
00985     }
00986 
00987     <span class="comment">// If we've got a value to alias and it's being added at the top level of</span>
00988     <span class="comment">// the DAS, that's an error.</span>
00989     <span class="keywordflow">if</span> (!at-&gt;<a class="code" href="classAttrTable.html#DASz7_11">is_container</a>(p) &amp;&amp; <span class="keyword">this</span> == das)
00990     <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(string(<span class="stringliteral">"A value cannot be aliased to the top level of the\</span>
00991 <span class="stringliteral"> DAS;\nOnly containers may be present at that level of the DAS."</span>));
00992 
00993     <span class="keywordflow">if</span> (simple_find(lname))
00994     <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(string(<span class="stringliteral">"There already exists a container called `"</span>)
00995             + name + string(<span class="stringliteral">"in this attribute table."</span>));
00996 
00997     <a class="code" href="structAttrTable_1_1entry.html">entry</a> *e = <span class="keyword">new</span> <a class="code" href="structAttrTable_1_1entry.html">entry</a>;
00998     e-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo0">name</a> = lname;
00999     e-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo2">is_alias</a> = <span class="keyword">true</span>;
01000     e-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo3">aliased_to</a> = lsource;
01001     e-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo1">type</a> = at-&gt;<a class="code" href="classAttrTable.html#DASz7_10">attr</a>(p)-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo1">type</a>;
01002     <span class="keywordflow">if</span> (e-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo1">type</a> == <a class="code" href="AttrTable_8h.html#a12a2">Attr_container</a>)
01003     e-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo4">attributes</a> = at-&gt;<a class="code" href="classAttrTable.html#DASz5_0">get_attr_table</a>(p);
01004     <span class="keywordflow">else</span>
01005     e-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo5">attr</a> = at-&gt;<a class="code" href="classAttrTable.html#DASz7_10">attr</a>(p)-&gt;<a class="code" href="structAttrTable_1_1entry.html#AttrTable_1_1entryo5">attr</a>;
01006 
01007     attr_map.push_back(e);
01008 }
01009 
01010 <span class="comment">// Deprecated</span>
01030 <span class="comment"></span><span class="keywordtype">bool</span>
<a name="l01031"></a><a class="code" href="classAttrTable.html#DASa23">01031</a> <a class="code" href="classAttrTable.html#DASa23">AttrTable::attr_alias</a>(<span class="keyword">const</span> string &amp;alias, <a class="code" href="classAttrTable.html">AttrTable</a> *at, <span class="keyword">const</span> string &amp;name)
01032 {
01033     <a class="code" href="classAttrTable.html#DASa22">add_value_alias</a>(at, alias, name);
01034     <span class="keywordflow">return</span> <span class="keyword">true</span>;
01035 }
01036 
01044 <span class="keywordtype">bool</span>
<a name="l01045"></a><a class="code" href="classAttrTable.html#DASa24">01045</a> <a class="code" href="classAttrTable.html#DASa23">AttrTable::attr_alias</a>(<span class="keyword">const</span> string &amp;alias, <span class="keyword">const</span> string &amp;name)
01046 {
01047     <span class="keywordflow">return</span> <a class="code" href="classAttrTable.html#DASa23">attr_alias</a>(alias, <span class="keyword">this</span>, name);
01048 }
01049 
01053 <span class="keywordtype">void</span>
<a name="l01054"></a><a class="code" href="classAttrTable.html#DASa11">01054</a> <a class="code" href="classAttrTable.html#DASa11">AttrTable::erase</a>()
01055 {
01056     <span class="keywordflow">for</span> (<a class="code" href="classAttrTable.html#DASw1">Attr_iter</a> i = attr_map.begin(); i != attr_map.end(); i++) {
01057     <span class="keyword">delete</span> *i;
01058     *i = 0;
01059     }
01060 
01061     attr_map.erase(attr_map.begin(), attr_map.end());
01062 
01063     d_name = <span class="stringliteral">""</span>;
01064 }
01065 
01079 <span class="keywordtype">void</span>
<a name="l01080"></a><a class="code" href="classAttrTable.html#DASb2">01080</a> <a class="code" href="classAttrTable.html#DASb2">AttrTable::simple_print</a>(ostream &amp;os, string pad, <a class="code" href="classAttrTable.html#DASw1">Attr_iter</a> &amp;i,
01081             <span class="keywordtype">bool</span> dereference)
01082 {
01083     <span class="keywordflow">switch</span> ((*i)-&gt;type) {
01084       <span class="keywordflow">case</span> <a class="code" href="AttrTable_8h.html#a12a2">Attr_container</a>:
01085     os &lt;&lt; pad &lt;&lt; <a class="code" href="escaping_8cc.html#a5">id2www</a>(<a class="code" href="classAttrTable.html#DASa13">get_name</a>(i)) &lt;&lt; <span class="stringliteral">" {"</span> &lt;&lt; endl;
01086 
01087     (*i)-&gt;attributes-&gt;print(os, pad + <span class="stringliteral">"    "</span>, dereference);
01088 
01089     os &lt;&lt; pad &lt;&lt; <span class="stringliteral">"}"</span> &lt;&lt; endl;
01090     <span class="keywordflow">break</span>;
01091 
01092       <span class="keywordflow">default</span>: {
01093         os &lt;&lt; pad &lt;&lt; <a class="code" href="classAttrTable.html#DASz5_2">get_type</a>(i) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; <a class="code" href="escaping_8cc.html#a5">id2www</a>(<a class="code" href="classAttrTable.html#DASa13">get_name</a>(i)) &lt;&lt; <span class="stringliteral">" "</span> ;
01094 
01095         vector&lt;string&gt; *sxp = (*i)-&gt;attr;
01096         
01097         vector&lt;string&gt;::iterator last = sxp-&gt;end()-1;
01098         <span class="keywordflow">for</span> (vector&lt;string&gt;::iterator i = sxp-&gt;begin(); i != last; ++i)
01099         os &lt;&lt; *i &lt;&lt; <span class="stringliteral">", "</span>;
01100   
01101         os &lt;&lt; *(sxp-&gt;end()-1) &lt;&lt; <span class="stringliteral">";"</span> &lt;&lt; endl;
01102     }
01103     <span class="keywordflow">break</span>;
01104     }
01105 }
01106 
01109 <span class="keywordtype">void</span>
<a name="l01110"></a><a class="code" href="classAttrTable.html#DASb3">01110</a> <a class="code" href="classAttrTable.html#DASb2">AttrTable::simple_print</a>(FILE *out, string pad, <a class="code" href="classAttrTable.html#DASw1">Attr_iter</a> &amp;i,
01111             <span class="keywordtype">bool</span> dereference)
01112 {
01113     <span class="keywordflow">switch</span> ((*i)-&gt;type) {
01114       <span class="keywordflow">case</span> <a class="code" href="AttrTable_8h.html#a12a2">Attr_container</a>:
01115     fprintf( out, <span class="stringliteral">"%s%s {\n"</span>, pad.c_str(), <a class="code" href="escaping_8cc.html#a5">id2www</a>( <a class="code" href="classAttrTable.html#DASa13">get_name</a>(i) ).c_str()) ;
01116 
01117     (*i)-&gt;attributes-&gt;print(out, pad + <span class="stringliteral">"    "</span>, dereference);
01118 
01119     fprintf( out, <span class="stringliteral">"%s}\n"</span>, pad.c_str() ) ;
01120     <span class="keywordflow">break</span>;
01121 
01122       <span class="keywordflow">default</span>: {
01123         fprintf( out, <span class="stringliteral">"%s%s %s "</span>, pad.c_str(), <a class="code" href="classAttrTable.html#DASz5_2">get_type</a>(i).c_str(),
01124                       <a class="code" href="escaping_8cc.html#a5">id2www</a>(<a class="code" href="classAttrTable.html#DASa13">get_name</a>(i)).c_str() ) ;
01125 
01126         vector&lt;string&gt; *sxp = (*i)-&gt;attr;
01127         
01128         vector&lt;string&gt;::iterator last = sxp-&gt;end()-1;
01129         <span class="keywordflow">for</span> (vector&lt;string&gt;::iterator i = sxp-&gt;begin(); i != last; ++i)
01130         fprintf( out, <span class="stringliteral">"%s, "</span>, (*i).c_str() ) ;
01131   
01132         fprintf( out, <span class="stringliteral">"%s;\n"</span>, (*(sxp-&gt;end()-1)).c_str() ) ;
01133     }
01134     <span class="keywordflow">break</span>;
01135     }
01136 }
01137 
01149 <span class="keywordtype">void</span>
<a name="l01150"></a><a class="code" href="classAttrTable.html#DASa25">01150</a> <a class="code" href="classAttrTable.html#DASa25">AttrTable::print</a>(ostream &amp;os, string pad, <span class="keywordtype">bool</span> dereference)
01151 {
01152     <span class="keywordflow">for</span>(<a class="code" href="classAttrTable.html#DASw1">Attr_iter</a> i = attr_map.begin(); i != attr_map.end(); i++)
01153     {
01154     <span class="keywordflow">if</span> ((*i)-&gt;is_alias) {
01155         <span class="keywordflow">if</span> (dereference) {
01156         <a class="code" href="classAttrTable.html#DASb2">simple_print</a>(os, pad, i, dereference);
01157         }
01158         <span class="keywordflow">else</span> {
01159         os &lt;&lt; pad &lt;&lt; <span class="stringliteral">"Alias "</span> &lt;&lt; <a class="code" href="escaping_8cc.html#a5">id2www</a>(<a class="code" href="classAttrTable.html#DASa13">get_name</a>(i)) &lt;&lt; <span class="stringliteral">" "</span> 
01160            &lt;&lt; <a class="code" href="escaping_8cc.html#a5">id2www</a>((*i)-&gt;aliased_to) &lt;&lt; <span class="stringliteral">";"</span> &lt;&lt; endl;
01161         }
01162     } 
01163     <span class="keywordflow">else</span> {
01164         <a class="code" href="classAttrTable.html#DASb2">simple_print</a>(os, pad, i, dereference);
01165     }
01166     }
01167 }
01168 
01179 <span class="keywordtype">void</span>
<a name="l01180"></a><a class="code" href="classAttrTable.html#DASa26">01180</a> <a class="code" href="classAttrTable.html#DASa25">AttrTable::print</a>(FILE *out, string pad, <span class="keywordtype">bool</span> dereference)
01181 {
01182     <span class="keywordflow">for</span>(<a class="code" href="classAttrTable.html#DASw1">Attr_iter</a> i = attr_map.begin(); i != attr_map.end(); i++)
01183     {
01184     <span class="keywordflow">if</span> ((*i)-&gt;is_alias) {
01185         <span class="keywordflow">if</span> (dereference) {
01186         <a class="code" href="classAttrTable.html#DASb2">simple_print</a>(out, pad, i, dereference);
01187         }
01188         <span class="keywordflow">else</span> {
01189         fprintf( out, <span class="stringliteral">"%sAlias %s %s;\n"</span>,
01190                   pad.c_str(),
01191                   <a class="code" href="escaping_8cc.html#a5">id2www</a>(<a class="code" href="classAttrTable.html#DASa13">get_name</a>(i)).c_str(),
01192                   <a class="code" href="escaping_8cc.html#a5">id2www</a>((*i)-&gt;aliased_to).c_str() ) ;
01193         }
01194     } 
01195     <span class="keywordflow">else</span> {
01196         <a class="code" href="classAttrTable.html#DASb2">simple_print</a>(out, pad, i, dereference);
01197     }
01198     }
01199 }
01200 
01201 <span class="comment">// $Log: AttrTable_8cc-source.html,v $
01201 <span class="comment">// Revision 1.4  2004/02/05 06:51:15  jimg
01201 <span class="comment">// Added/update.
01201 <span class="comment">//</span>
01202 <span class="comment">// Revision 1.38.2.2  2004/01/17 13:37:50  rmorris</span>
01203 <span class="comment">// Mod's to account for differences in usage statements containing template</span>
01204 <span class="comment">// reference between MS VC++ 6.0 and MS VC++ 7.0.</span>
01205 <span class="comment">//</span>
01206 <span class="comment">// Revision 1.38.2.1  2003/09/06 22:37:50  jimg</span>
01207 <span class="comment">// Updated the documentation.</span>
01208 <span class="comment">//</span>
01209 <span class="comment">// Revision 1.38  2003/04/22 19:40:27  jimg</span>
01210 <span class="comment">// Merged with 3.3.1.</span>
01211 <span class="comment">//</span>
01212 <span class="comment">// Revision 1.35.2.2  2003/04/15 00:47:43  jimg</span>
01213 <span class="comment">// Added get_attr_iter method.</span>
01214 <span class="comment">// Added documentation from the header.</span>
01215 <span class="comment">//</span>
01216 <span class="comment">// Revision 1.37  2003/02/25 23:27:27  jimg</span>
01217 <span class="comment">// Added erase() method.</span>
01218 <span class="comment">//</span>
01219 <span class="comment">// Revision 1.36  2003/02/21 00:14:24  jimg</span>
01220 <span class="comment">// Repaired copyright.</span>
01221 <span class="comment">//</span>
01222 <span class="comment">// Revision 1.35.2.1  2003/02/21 00:10:06  jimg</span>
01223 <span class="comment">// Repaired copyright.</span>
01224 <span class="comment">//</span>
01225 <span class="comment">// Revision 1.35  2003/01/23 00:22:23  jimg</span>
01226 <span class="comment">// Updated the copyright notice; this implementation of the DAP is</span>
01227 <span class="comment">// copyrighted by OPeNDAP, Inc.</span>
01228 <span class="comment">//</span>
01229 <span class="comment">// Revision 1.34  2003/01/15 19:24:39  pwest</span>
01230 <span class="comment">// Removing IteratorAdapterT and replacing with non-templated versions.</span>
01231 <span class="comment">//</span>
01232 <span class="comment">// Revision 1.33  2003/01/10 19:46:39  jimg</span>
01233 <span class="comment">// Merged with code tagged release-3-2-10 on the release-3-2 branch. In many</span>
01234 <span class="comment">// cases files were added on that branch (so they appear on the trunk for</span>
01235 <span class="comment">// the first time).</span>
01236 <span class="comment">//</span>
01237 <span class="comment">// Revision 1.28.4.13  2002/12/31 16:43:20  rmorris</span>
01238 <span class="comment">// Patches to handle some of the fancier template code under VC++ 6.0.</span>
01239 <span class="comment">//</span>
01240 <span class="comment">// Revision 1.28.4.12  2002/12/17 22:35:02  pwest</span>
01241 <span class="comment">// Added and updated methods using stdio. Deprecated methods using iostream.</span>
01242 <span class="comment">//</span>
01243 <span class="comment">// Revision 1.28.4.11  2002/12/01 14:37:52  rmorris</span>
01244 <span class="comment">// Smalling changes for the win32 porting and maintenance work.</span>
01245 <span class="comment">//</span>
01246 <span class="comment">// Revision 1.28.4.10  2002/11/06 22:56:52  pwest</span>
01247 <span class="comment">// Memory delete errors and uninitialized memory read errors corrected</span>
01248 <span class="comment">//</span>
01249 <span class="comment">// Revision 1.28.4.9  2002/10/28 21:17:43  pwest</span>
01250 <span class="comment">// Converted all return values and method parameters to use non-const iterator.</span>
01251 <span class="comment">// Added operator== and operator!= methods to IteratorAdapter to handle Pix</span>
01252 <span class="comment">// problems.</span>
01253 <span class="comment">//</span>
01254 <span class="comment">// Revision 1.28.4.8  2002/09/12 22:49:57  pwest</span>
01255 <span class="comment">// Corrected signature changes made with Pix to IteratorAdapter changes. Rather</span>
01256 <span class="comment">// than taking a reference to a Pix, taking a Pix value.</span>
01257 <span class="comment">//</span>
01258 <span class="comment">// Revision 1.28.4.7  2002/09/05 22:52:54  pwest</span>
01259 <span class="comment">// Replaced the GNU data structures SLList and DLList with the STL container</span>
01260 <span class="comment">// class vector&lt;&gt;. To maintain use of Pix, changed the Pix.h header file to</span>
01261 <span class="comment">// redefine Pix to be an IteratorAdapter. Usage remains the same and all code</span>
01262 <span class="comment">// outside of the DAP should compile and link with no problems. Added methods</span>
01263 <span class="comment">// to the different classes where Pix is used to include methods to use STL</span>
01264 <span class="comment">// iterators. Replaced the use of Pix within the DAP to use iterators instead.</span>
01265 <span class="comment">// Updated comments for documentation, updated the test suites, and added some</span>
01266 <span class="comment">// unit tests. Updated the Makefile to remove GNU/SLList and GNU/DLList.</span>
01267 <span class="comment">//</span>
01268 <span class="comment">// Revision 1.28.4.6  2002/08/08 06:54:56  jimg</span>
01269 <span class="comment">// Changes for thread-safety. In many cases I found ugly places at the</span>
01270 <span class="comment">// tops of files while looking for globals, et c., and I fixed them up</span>
01271 <span class="comment">// (hopefully making them easier to read, ...). Only the files RCReader.cc</span>
01272 <span class="comment">// and usage.cc actually use pthreads synchronization functions. In other</span>
01273 <span class="comment">// cases I removed static objects where they were used for supposed</span>
01274 <span class="comment">// improvements in efficiency which had never actually been verifiied (and</span>
01275 <span class="comment">// which looked dubious).</span>
01276 <span class="comment">//</span>
01277 <span class="comment">// Revision 1.32  2002/06/18 15:36:24  tom</span>
01278 <span class="comment">// Moved comments and edited to accommodate doxygen documentation-generator.</span>
01279 <span class="comment">//</span>
01280 <span class="comment">// Revision 1.31  2002/06/03 22:21:15  jimg</span>
01281 <span class="comment">// Merged with release-3-2-9</span>
01282 <span class="comment">//</span>
01283 <span class="comment">// Revision 1.28.4.5  2001/10/30 06:55:45  rmorris</span>
01284 <span class="comment">// Win32 porting changes.  Brings core win32 port up-to-date.</span>
01285 <span class="comment">//</span>
01286 <span class="comment">// Revision 1.30  2001/08/24 17:46:22  jimg</span>
01287 <span class="comment">// Resolved conflicts from the merge of release 3.2.6</span>
01288 <span class="comment">//</span>
01289 <span class="comment">// Revision 1.28.4.4  2001/08/18 01:48:53  jimg</span>
01290 <span class="comment">// Removed WIN32 compile guards from using statements.</span>
01291 <span class="comment">//</span>
01292 <span class="comment">// Revision 1.28.4.3  2001/07/28 01:10:41  jimg</span>
01293 <span class="comment">// Some of the numeric type classes did not have copy ctors or operator=.</span>
01294 <span class="comment">// I added those where they were needed.</span>
01295 <span class="comment">// In every place where delete (or delete []) was called, I set the pointer</span>
01296 <span class="comment">// just deleted to zero. Thus if for some reason delete is called again</span>
01297 <span class="comment">// before new memory is allocated there won't be a mysterious crash. This is</span>
01298 <span class="comment">// just good form when using delete.</span>
01299 <span class="comment">// I added calls to www2id and id2www where appropriate. The DAP now handles</span>
01300 <span class="comment">// making sure that names are escaped and unescaped as needed. Connect is</span>
01301 <span class="comment">// set to handle CEs that contain names as they are in the dataset (see the</span>
01302 <span class="comment">// comments/Log there). Servers should not handle escaping or unescaping</span>
01303 <span class="comment">// characters on their own.</span>
01304 <span class="comment">//</span>
01305 <span class="comment">// Revision 1.29  2001/01/26 19:48:09  jimg</span>
01306 <span class="comment">// Merged with release-3-2-3.</span>
01307 <span class="comment">//</span>
01308 <span class="comment">// Revision 1.28.4.2  2000/11/30 05:24:46  jimg</span>
01309 <span class="comment">// Significant changes and improvements to the AttrTable and DAS classes. DAS</span>
01310 <span class="comment">// now is a child of AttrTable, which makes attributes behave uniformly at</span>
01311 <span class="comment">// all levels of the DAS object. Alias now work. I've added unit tests for</span>
01312 <span class="comment">// several methods in AttrTable and some of the functions in parser-util.cc.</span>
01313 <span class="comment">// In addition, all of the DAS tests now work.</span>
01314 <span class="comment">//</span>
01315 <span class="comment">// Revision 1.28.4.1  2000/11/22 21:47:42  jimg</span>
01316 <span class="comment">// Changed the implementation of DAS; it now inherits from AttrTable</span>
01317 <span class="comment">//</span>
01318 <span class="comment">// Revision 1.28  2000/07/09 22:05:35  rmorris</span>
01319 <span class="comment">// Changes to increase portability, minimize ifdef's for win32 and account</span>
01320 <span class="comment">// for differences in the iostreams implementations.</span>
01321 <span class="comment">//</span>
01322 <span class="comment">// Revision 1.27  2000/06/16 18:14:59  jimg</span>
01323 <span class="comment">// Merged with 3.1.7</span>
01324 <span class="comment">//</span>
01325 <span class="comment">// Revision 1.23.6.4  2000/06/14 16:59:00  jimg</span>
01326 <span class="comment">// Added instrumentation for the dtor.</span>
01327 <span class="comment">//</span>
01328 <span class="comment">// Revision 1.26  2000/06/07 19:33:21  jimg</span>
01329 <span class="comment">// Merged with verson 3.1.6</span>
01330 <span class="comment">//</span>
01331 <span class="comment">// Revision 1.23.6.3  2000/05/18 17:47:21  jimg</span>
01332 <span class="comment">// Fixed a bug in the AttrTable. Container attributes below the top level were</span>
01333 <span class="comment">// broken in the latest changes to the DAS code.</span>
01334 <span class="comment">//</span>
01335 <span class="comment">// Revision 1.23.6.2  2000/05/12 18:55:54  jimg</span>
01336 <span class="comment">// See comments in AttrTable.h.</span>
01337 <span class="comment">//</span>
01338 <span class="comment">// Revision 1.23.6.1  2000/01/26 23:55:02  jimg</span>
01339 <span class="comment">// Fixed the return type of string::find.</span>
01340 <span class="comment">//</span>
01341 <span class="comment">// Revision 1.23  1999/04/29 02:29:26  jimg</span>
01342 <span class="comment">// Merge of no-gnu branch</span>
01343 <span class="comment">//</span>
01344 <span class="comment">// Revision 1.22  1999/03/24 23:37:13  jimg</span>
01345 <span class="comment">// Added support for the Int16, UInt16 and Float32 types</span>
01346 <span class="comment">//</span>
01347 <span class="comment">// Revision 1.21  1998/11/24 06:50:07  jimg</span>
01348 <span class="comment">// Added instrumentation. Used while I was removing DASVHMap.</span>
01349 <span class="comment">//</span>
01350 <span class="comment">// Revision 1.20.2.2  1999/02/05 09:32:10  jimg</span>
01351 <span class="comment">// Fixed __unused__ so that it not longer clashes with Red Hat 5.2 inlined</span>
01352 <span class="comment">// math code. </span>
01353 <span class="comment">//</span>
01354 <span class="comment">// Revision 1.20.2.1  1999/02/02 19:43:13  jimg</span>
01355 <span class="comment">// StringSPlex Removed</span>
01356 <span class="comment">//</span>
01357 <span class="comment">// Revision 1.20  1998/08/06 16:06:42  jimg</span>
01358 <span class="comment">// Now prints aliases as such rather than replicating the aliased entry.</span>
01359 <span class="comment">//</span>
01360 <span class="comment">// Revision 1.19  1997/08/09 21:18:41  jimg</span>
01361 <span class="comment">// Changed/fixed the type comparison in attr_append so that code which calls</span>
01362 <span class="comment">// unsigned int `UInt32' won't break (the type is called Uint32, but the das</span>
01363 <span class="comment">// parser and scanner accept UInt32 as well).</span>
01364 <span class="comment">//</span>
01365 <span class="comment">// Revision 1.18  1997/07/15 21:58:04  jimg</span>
01366 <span class="comment">// Formatting.</span>
01367 <span class="comment">//</span>
01368 <span class="comment">// Revision 1.17  1997/06/06 03:12:44  jimg</span>
01369 <span class="comment">// Added mfuncs with char * parameters for some of the calls. See AttrTable.h</span>
01370 <span class="comment">//</span>
01371 <span class="comment">// Revision 1.16  1997/05/13 23:32:11  jimg</span>
01372 <span class="comment">// Added changes to handle the new Alias and lexical scoping rules.</span>
01373 <span class="comment">//</span>
01374 <span class="comment">// Revision 1.15  1997/01/13 16:56:03  jimg</span>
01375 <span class="comment">// Changed the name of the private member `map' to `attr_map' to avoid a name</span>
01376 <span class="comment">// collision with the STL'd map class.</span>
01377 <span class="comment">//</span>
01378 <span class="comment">// Revision 1.14  1996/08/13 20:49:30  jimg</span>
01379 <span class="comment">// Added not_used to definition of char rcsid[].</span>
01380 <span class="comment">//</span>
01381 <span class="comment">// Revision 1.13  1996/05/31 23:29:21  jimg</span>
01382 <span class="comment">// Updated copyright notice.</span>
01383 <span class="comment">//</span>
01384 <span class="comment">// Revision 1.12  1996/04/05 00:21:18  jimg</span>
01385 <span class="comment">// Compiled with g++ -Wall and fixed various warnings.</span>
01386 <span class="comment">//</span>
01387 <span class="comment">// Revision 1.11  1995/07/09  21:28:50  jimg</span>
01388 <span class="comment">// Added copyright notice.</span>
01389 <span class="comment">//</span>
01390 <span class="comment">// Revision 1.10  1995/02/10  02:27:53  jimg</span>
01391 <span class="comment">// Fixed an error where two attributes could be declared with the same name</span>
01392 <span class="comment">// (for the same variable) if they hade different types.</span>
01393 <span class="comment">//</span>
01394 <span class="comment">// Revision 1.9  1994/12/21  03:03:37  reza</span>
01395 <span class="comment">// Added overloading functions for get_attr_num().</span>
01396 <span class="comment">//</span>
01397 <span class="comment">// Revision 1.8  1994/12/07  21:09:24  jimg</span>
01398 <span class="comment">// Added support for vectors of attributes (using XPlex from libg++).</span>
01399 <span class="comment">//</span>
01400 <span class="comment">// Revision 1.7  1994/10/13  15:43:29  jimg</span>
01401 <span class="comment">// Added a new version of append_attr that takes (const char *)s and modified</span>
01402 <span class="comment">// the version that takes strings to take (const String &amp;).</span>
01403 <span class="comment">//</span>
01404 <span class="comment">// Revision 1.6  1994/10/05  16:38:17  jimg</span>
01405 <span class="comment">// Changed internal representation of the attribute table from a Map</span>
01406 <span class="comment">// to a DLList&lt;&gt;.</span>
01407 <span class="comment">//</span>
01408 <span class="comment">// Revision 1.5  1994/09/27  22:42:44  jimg</span>
01409 <span class="comment">// Changed definition of the class AttrTable; it no longer inherits from</span>
01410 <span class="comment">// AttrVHMap, instead it uses that class (contains a member that is an instance</span>
01411 <span class="comment">// of AttrVHMap).</span>
01412 <span class="comment">// Added mfuncs to AttrTable so that the new member could be set/accessed.</span>
01413 <span class="comment">//</span>
01414 <span class="comment">// Revision 1.4  1994/09/09  15:26:39  jimg</span>
01415 <span class="comment">// Removed operator&lt;&lt; and added print() since I have no good way to define</span>
01416 <span class="comment">// operator&gt;&gt;. It seems best to define all operators from a set (like &lt;&lt;, &gt;&gt;)</span>
01417 <span class="comment">// or none at all. Since parse() is the input mfunc, it seems that output</span>
01418 <span class="comment">// should be a mfunc too.</span>
01419 <span class="comment">//</span>
01420 <span class="comment">// Revision 1.3  1994/08/02  20:11:27  jimg</span>
01421 <span class="comment">// Changes operator&lt;&lt; so that it writes a parsable version of the</span>
01422 <span class="comment">// attribute table.</span>
01423 <span class="comment">//' comments and rcsid[] variables (syntax errors due to //</span>
01424 <span class="comment">// comments caused compilation failures.</span>
01425 <span class="comment">// das.tab.c and .h are commited now as well.</span>
01426 <span class="comment">//</span>
01427 <span class="comment">// Revision 1.1  1994/08/02  18:32:04  jimg</span>
01428 <span class="comment">// The implementation of AttrTable. This file defined ostream &amp;operator&lt;&lt; and</span>
01429 <span class="comment">// a static class variable String empty (it is initialized to "").</span>
01430 
01431 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Feb 4 23:42:55 2004 for libdap++ by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
