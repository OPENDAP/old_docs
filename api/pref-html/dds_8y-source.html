<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>dds.y Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>dds.y</h1><a href="dds_8y.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00002 <span class="comment">// -*- mode: c++; c-basic-offset:4 -*-</span>
00003 
00004 <span class="comment">// This file is part of libdap, A C++ implementation of the OPeNDAP Data</span>
00005 <span class="comment">// Access Protocol.</span>
00006 
00007 <span class="comment">// Copyright (c) 2002,2003 OPeNDAP, Inc.</span>
00008 <span class="comment">// Author: James Gallagher &lt;jgallagher@opendap.org&gt;</span>
00009 <span class="comment">//</span>
00010 <span class="comment">// This library is free software; you can redistribute it and/or</span>
00011 <span class="comment">// modify it under the terms of the GNU Lesser General Public</span>
00012 <span class="comment">// License as published by the Free Software Foundation; either</span>
00013 <span class="comment">// version 2.1 of the License, or (at your option) any later version.</span>
00014 <span class="comment">// </span>
00015 <span class="comment">// This library is distributed in the hope that it will be useful,</span>
00016 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00017 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00018 <span class="comment">// Lesser General Public License for more details.</span>
00019 <span class="comment">// </span>
00020 <span class="comment">// You should have received a copy of the GNU Lesser General Public</span>
00021 <span class="comment">// License along with this library; if not, write to the Free Software</span>
00022 <span class="comment">// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00023 <span class="comment">//</span>
00024 <span class="comment">// You can contact OPeNDAP, Inc. at PO Box 112, Saunderstown, RI. 02874-0112.</span>
00025  
00026 <span class="comment">// (c) COPYRIGHT URI/MIT 1994-1999</span>
00027 <span class="comment">// Please read the full copyright statement in the file COPYRIGHT_URI.</span>
00028 <span class="comment">//</span>
00029 <span class="comment">// Authors:</span>
00030 <span class="comment">//      jhrg,jimg       James Gallagher &lt;jgallagher@gso.uri.edu&gt;</span>
00031 
00032 <span class="comment">/*</span>
00033 <span class="comment">   Grammar for the DDS. This grammar can be used with the bison parser</span>
00034 <span class="comment">   generator to build a parser for the DDS. It assumes that a scanner called</span>
00035 <span class="comment">   `ddslex()' exists and returns several token types (see das.tab.h)</span>
00036 <span class="comment">   in addition to several single character token types. The matched lexeme</span>
00037 <span class="comment">   for an ID is stored by the scanner in a global char * `ddslval'.</span>
00038 <span class="comment">   Because the scanner returns a value via this global and because the parser</span>
00039 <span class="comment">   stores ddslval (not the information pointed to), the values of rule</span>
00040 <span class="comment">   components must be stored as they are parsed and used once accumulated at</span>
00041 <span class="comment">   or near the end of a rule. If ddslval returned a value (instead of a</span>
00042 <span class="comment">   pointer to a value) this would not be necessary.</span>
00043 <span class="comment"></span>
00044 <span class="comment">   jhrg 8/29/94 </span>
00045 <span class="comment">*/</span>
00046 
00047 %{
00048 
00049 <span class="preprocessor">#include "<a class="code" href="config__dap_8h.html">config_dap.h</a>"</span>
00050 
00051 <span class="keyword">static</span> <span class="keywordtype">char</span> rcsid[] not_used = {<span class="stringliteral">"$Id$"</span>};
00052 
00053 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00054 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00055 <span class="preprocessor">#include &lt;assert.h&gt;</span>
00056 
00057 <span class="preprocessor">#include &lt;iostream&gt;</span>
00058 <span class="preprocessor">#include &lt;stack&gt;</span>
00059 
00060 <span class="preprocessor">#if defined(__GNUG__) || defined(WIN32)</span>
00061 <span class="preprocessor"></span><span class="preprocessor">#include &lt;strstream&gt;</span>
00062 <span class="preprocessor">#else</span>
00063 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sstream&gt;</span>
00064 <span class="preprocessor">#endif</span>
00065 <span class="preprocessor"></span>
00066 <span class="preprocessor">#include "<a class="code" href="DDS_8h.html">DDS.h</a>"</span>
00067 <span class="preprocessor">#include "<a class="code" href="Array_8h.html">Array.h</a>"</span>
00068 <span class="preprocessor">#include "<a class="code" href="Error_8h.html">Error.h</a>"</span>
00069 <span class="preprocessor">#include "<a class="code" href="parser_8h.html">parser.h</a>"</span>
00070 <span class="preprocessor">#include "<a class="code" href="util_8h.html">util.h</a>"</span>
00071 
00072 <span class="keyword">using</span> std::endl;
00073 <span class="keyword">using</span> std::ends;
00074 <span class="keyword">using</span> std::ostrstream;
00075 
00076 <span class="comment">// These macros are used to access the `arguments' passed to the parser. A</span>
00077 <span class="comment">// pointer to an error object and a pointer to an integer status variable are</span>
00078 <span class="comment">// passed in to the parser within a structure (which itself is passed as a</span>
00079 <span class="comment">// pointer). Note that the ERROR macro explicitly casts OBJ to an ERROR *. </span>
00080 <span class="comment">// ERROR is no longer used. These parsers now signal problems by throwing</span>
00081 <span class="comment">// exceptions. 5/22/2002 jhrg</span>
00082 <span class="preprocessor">#define DDS_OBJ(arg) ((DDS *)((parser_arg *)(arg))-&gt;_object)</span>
00083 <span class="preprocessor"></span>
00084 <span class="preprocessor">#define YYPARSE_PARAM arg</span>
00085 <span class="preprocessor"></span>
00086 <span class="keyword">extern</span> <span class="keywordtype">int</span> dds_line_num;    <span class="comment">/* defined in dds.lex */</span>
00087 
00088 <span class="comment">// No global static objects in the dap library! 1/24/2000 jhrg</span>
00089 <span class="keyword">static</span> stack&lt;BaseType *&gt; *<a class="code" href="dds_8y.html#a7">ctor</a>;
00090 <span class="keyword">static</span> <a class="code" href="classBaseType.html">BaseType</a> *<a class="code" href="dds_8y.html#a8">current</a>;
00091 <span class="keyword">static</span> string *id;
00092 <span class="keyword">static</span> <a class="code" href="BaseType_8h.html#a28">Part</a> <a class="code" href="dds_8y.html#a9">part</a> = <a class="code" href="BaseType_8h.html#a28a10">nil</a>;     <span class="comment">/* Part is defined in BaseType */</span>
00093 
00094 <span class="keyword">static</span> <span class="keywordtype">char</span> *NO_DDS_MSG =
00095 <span class="stringliteral">"The descriptor object returned from the dataset was null.\n\</span>
00096 <span class="stringliteral">Check that the URL is correct."</span>;
00097 
00098 <span class="keyword">static</span> <span class="keywordtype">char</span> *BAD_DECLARATION =
00099 <span class="stringliteral">"In the dataset descriptor object: Expected a variable declaration\n\</span>
00100 <span class="stringliteral">(e.g., Int32 i;). Make sure that the variable name is not the name\n\</span>
00101 <span class="stringliteral">of a datatype and that the Array: and Maps: sections of a Grid are\n\</span>
00102 <span class="stringliteral">labeled properly."</span>;
00103  
00104 <span class="keywordtype">int</span> <a class="code" href="dds-test_8cc.html#a7">ddslex</a>();
00105 <span class="keywordtype">void</span> <a class="code" href="dds_8y.html#a25">ddserror</a>(<span class="keywordtype">char</span> *s);
00106 
00107 <span class="keywordtype">void</span> <a class="code" href="dds_8y.html#a27">add_entry</a>(<a class="code" href="classDDS.html">DDS</a> &amp;table, stack&lt;BaseType *&gt; **<a class="code" href="dds_8y.html#a7">ctor</a>, <a class="code" href="classBaseType.html">BaseType</a> **current, 
00108            <a class="code" href="BaseType_8h.html#a28">Part</a> <a class="code" href="AttrTable_8cc.html#a1">p</a>);
00109 <span class="keywordtype">void</span> <a class="code" href="dds_8y.html#a26">invalid_declaration</a>(<a class="code" href="structparser__arg.html">parser_arg</a> *arg, string semantic_err_msg, 
00110              <span class="keywordtype">char</span> *type, <span class="keywordtype">char</span> *<a class="code" href="das_8y.html#a18">name</a>);
00111 
00112 %}
00113 
00114 %expect 56
00115 
00116 %<span class="keyword">union </span>{
00117     <span class="keywordtype">bool</span> <span class="keywordtype">boolean</span>;
00118     <span class="keywordtype">char</span> word[ID_MAX];
00119 }
00120 
00121 %token &lt;word&gt; SCAN_WORD
00122 %token &lt;word&gt; SCAN_DATASET
00123 %token &lt;word&gt; SCAN_LIST
00124 %token &lt;word&gt; SCAN_SEQUENCE
00125 %token &lt;word&gt; SCAN_STRUCTURE
00126 %token &lt;word&gt; SCAN_FUNCTION
00127 %token &lt;word&gt; SCAN_GRID
00128 %token &lt;word&gt; SCAN_BYTE
00129 %token &lt;word&gt; SCAN_INT16
00130 %token &lt;word&gt; SCAN_UINT16
00131 %token &lt;word&gt; SCAN_INT32
00132 %token &lt;word&gt; SCAN_UINT32
00133 %token &lt;word&gt; SCAN_FLOAT32
00134 %token &lt;word&gt; SCAN_FLOAT64
00135 %token &lt;word&gt; SCAN_STRING
00136 %token &lt;word&gt; SCAN_URL 
00137 
00138 %type &lt;boolean&gt; datasets dataset declarations <a class="code" href="dds_8y.html#a5">declaration</a> <a class="code" href="dds_8y.html#a17">array_decl</a>
00139 
00140 %type &lt;word&gt; non_list_decl
00141 %type &lt;word&gt; base_type list structure sequence grid var var_name <a class="code" href="das_8y.html#a18">name</a>
00142 
00143 %%
00144 
00145 start:
00146                 {
00147             <span class="comment">/* On entry to the parser, make the BaseType stack. */</span>
00148             <a class="code" href="dds_8y.html#a7">ctor</a> = <span class="keyword">new</span> stack&lt;BaseType *&gt;;
00149                 }
00150                 datasets
00151                 {
00152             <span class="keyword">delete</span> <a class="code" href="dds_8y.html#a7">ctor</a>;
00153         }
00154 ;
00155 
00156 datasets:   dataset
00157         | datasets dataset
00158 ;
00159 
00160 dataset:    SCAN_DATASET <span class="charliteral">'{'</span> declarations <span class="charliteral">'}'</span> <a class="code" href="das_8y.html#a18">name</a> <span class="charliteral">';'</span>
00161                 {
00162             $$ = $3 &amp;&amp; $5;
00163         }
00164                 | error
00165                 {
00166             <a class="code" href="parser-util_8cc.html#a3">parse_error</a>((<a class="code" href="structparser__arg.html">parser_arg</a> *)arg, NO_DDS_MSG,
00167                 dds_line_num, $&lt;word&gt;1);
00168             YYABORT;
00169         }
00170 ;
00171 
00172 declarations:   <span class="comment">/* empty */</span>
00173                 {
00174             $$ = <span class="keyword">true</span>;
00175         }
00176         | <a class="code" href="dds_8y.html#a5">declaration</a>
00177         | declarations <a class="code" href="dds_8y.html#a5">declaration</a>
00178 ;
00179 
00180 <a class="code" href="dds_8y.html#a5">declaration</a>:    list non_list_decl
00181                 { 
00182             string smsg;
00183             <span class="keywordflow">if</span> (<a class="code" href="dds_8y.html#a8">current</a>-&gt;check_semantics(smsg))
00184             <a class="code" href="dds_8y.html#a27">add_entry</a>(*DDS_OBJ(arg), &amp;<a class="code" href="dds_8y.html#a7">ctor</a>, &amp;<a class="code" href="dds_8y.html#a8">current</a>, <a class="code" href="dds_8y.html#a9">part</a>); 
00185             <span class="keywordflow">else</span> {
00186             <a class="code" href="dds_8y.html#a26">invalid_declaration</a>((<a class="code" href="structparser__arg.html">parser_arg</a> *)arg, smsg, $1, $2);
00187             YYABORT;
00188             }
00189         }
00190                 | non_list_decl
00191                 {
00192             $$ = <span class="keyword">true</span>;
00193         }
00194 ;
00195 
00196 <span class="comment">/* This non-terminal is here only to keep types like `List List Int32' from</span>
00197 <span class="comment">   parsing. DODS does not allow Lists of Lists. Those types make translation</span>
00198 <span class="comment">   to/from arrays too hard. */</span>
00199 
00200 non_list_decl:  base_type var <span class="charliteral">';'</span> 
00201                 { 
00202             string smsg;
00203             <span class="keywordflow">if</span> (<a class="code" href="dds_8y.html#a8">current</a>-&gt;check_semantics(smsg)) {
00204             <span class="comment">/* BaseType *current_save = current ; */</span>
00205             <a class="code" href="dds_8y.html#a27">add_entry</a>(*DDS_OBJ(arg), &amp;<a class="code" href="dds_8y.html#a7">ctor</a>, &amp;<a class="code" href="dds_8y.html#a8">current</a>, <a class="code" href="dds_8y.html#a9">part</a>); 
00206             <span class="comment">/* FIX</span>
00207 <span class="comment">            if( current_save == current )</span>
00208 <span class="comment">            {</span>
00209 <span class="comment">                delete current ;</span>
00210 <span class="comment">                current = 0 ;</span>
00211 <span class="comment">            }</span>
00212 <span class="comment">            */</span>
00213             } <span class="keywordflow">else</span> {
00214               <a class="code" href="dds_8y.html#a26">invalid_declaration</a>((<a class="code" href="structparser__arg.html">parser_arg</a> *)arg, smsg, $1, $2);
00215               YYABORT;
00216             }
00217                     strcpy($$,$2);
00218         }
00219 
00220         | structure  <span class="charliteral">'{'</span> declarations <span class="charliteral">'}'</span> 
00221         { 
00222             <span class="keywordflow">if</span>( current ) <span class="keyword">delete</span> <a class="code" href="dds_8y.html#a8">current</a> ;
00223             <a class="code" href="dds_8y.html#a8">current</a> = <a class="code" href="dds_8y.html#a7">ctor</a>-&gt;top(); 
00224             <a class="code" href="dds_8y.html#a7">ctor</a>-&gt;pop();
00225         } 
00226                 var <span class="charliteral">';'</span> 
00227                 { 
00228             string smsg;
00229             <span class="keywordflow">if</span> (<a class="code" href="dds_8y.html#a8">current</a>-&gt;check_semantics(smsg))
00230             <a class="code" href="dds_8y.html#a27">add_entry</a>(*DDS_OBJ(arg), &amp;<a class="code" href="dds_8y.html#a7">ctor</a>, &amp;<a class="code" href="dds_8y.html#a8">current</a>, <a class="code" href="dds_8y.html#a9">part</a>); 
00231             <span class="keywordflow">else</span> {
00232               <a class="code" href="dds_8y.html#a26">invalid_declaration</a>((<a class="code" href="structparser__arg.html">parser_arg</a> *)arg, smsg, $1, $6);
00233               YYABORT;
00234             }
00235                     strcpy($$,$6);
00236         }
00237 
00238         | sequence <span class="charliteral">'{'</span> declarations <span class="charliteral">'}'</span> 
00239                 { 
00240             <span class="keywordflow">if</span>( current ) <span class="keyword">delete</span> <a class="code" href="dds_8y.html#a8">current</a> ;
00241             <a class="code" href="dds_8y.html#a8">current</a> = <a class="code" href="dds_8y.html#a7">ctor</a>-&gt;top(); 
00242             <a class="code" href="dds_8y.html#a7">ctor</a>-&gt;pop();
00243         } 
00244                 var <span class="charliteral">';'</span> 
00245                 { 
00246             string smsg;
00247             <span class="keywordflow">if</span> (<a class="code" href="dds_8y.html#a8">current</a>-&gt;check_semantics(smsg))
00248             <a class="code" href="dds_8y.html#a27">add_entry</a>(*DDS_OBJ(arg), &amp;<a class="code" href="dds_8y.html#a7">ctor</a>, &amp;<a class="code" href="dds_8y.html#a8">current</a>, <a class="code" href="dds_8y.html#a9">part</a>); 
00249             <span class="keywordflow">else</span> {
00250               <a class="code" href="dds_8y.html#a26">invalid_declaration</a>((<a class="code" href="structparser__arg.html">parser_arg</a> *)arg, smsg, $1, $6);
00251               YYABORT;
00252             }
00253                     strcpy($$,$6);
00254         }
00255 
00256         | grid <span class="charliteral">'{'</span> SCAN_WORD <span class="charliteral">':'</span>
00257         { 
00258             <span class="keywordflow">if</span> (<a class="code" href="parser-util_8cc.html#a6">is_keyword</a>(string($3), <span class="stringliteral">"array"</span>))
00259             <a class="code" href="dds_8y.html#a9">part</a> = <a class="code" href="BaseType_8h.html#a28a11">array</a>; 
00260             <span class="keywordflow">else</span> {
00261             ostrstream <a class="code" href="dds_8y.html#a20">msg</a>;
00262             <a class="code" href="dds_8y.html#a20">msg</a> &lt;&lt; BAD_DECLARATION &lt;&lt; ends;
00263             <a class="code" href="parser-util_8cc.html#a3">parse_error</a>((<a class="code" href="structparser__arg.html">parser_arg</a> *)arg, <a class="code" href="dds_8y.html#a20">msg</a>.str(),
00264                     dds_line_num, $3);
00265             <a class="code" href="dds_8y.html#a20">msg</a>.freeze(0);
00266             YYABORT;
00267             }
00268                 }
00269                 <a class="code" href="dds_8y.html#a5">declaration</a> SCAN_WORD <span class="charliteral">':'</span>
00270         { 
00271             <span class="keywordflow">if</span> (<a class="code" href="parser-util_8cc.html#a6">is_keyword</a>(string($7), <span class="stringliteral">"maps"</span>))
00272             <a class="code" href="dds_8y.html#a9">part</a> = <a class="code" href="BaseType_8h.html#a28a12">maps</a>; 
00273             <span class="keywordflow">else</span> {
00274             ostrstream <a class="code" href="dds_8y.html#a20">msg</a>;
00275             <a class="code" href="dds_8y.html#a20">msg</a> &lt;&lt; BAD_DECLARATION &lt;&lt; ends;
00276             <a class="code" href="parser-util_8cc.html#a3">parse_error</a>((<a class="code" href="structparser__arg.html">parser_arg</a> *)arg, <a class="code" href="dds_8y.html#a20">msg</a>.str(),
00277                     dds_line_num, $7);
00278             <a class="code" href="dds_8y.html#a20">msg</a>.freeze(0);
00279             YYABORT;
00280             }
00281                 }
00282                 declarations <span class="charliteral">'}'</span> 
00283         {
00284             <span class="keywordflow">if</span>( current ) <span class="keyword">delete</span> <a class="code" href="dds_8y.html#a8">current</a> ;
00285             <a class="code" href="dds_8y.html#a8">current</a> = <a class="code" href="dds_8y.html#a7">ctor</a>-&gt;top(); 
00286             <a class="code" href="dds_8y.html#a7">ctor</a>-&gt;pop();
00287         }
00288                 var <span class="charliteral">';'</span> 
00289                 {
00290             string smsg;
00291             <span class="keywordflow">if</span> (<a class="code" href="dds_8y.html#a8">current</a>-&gt;check_semantics(smsg)) {
00292             <a class="code" href="dds_8y.html#a9">part</a> = <a class="code" href="BaseType_8h.html#a28a10">nil</a>; 
00293             <a class="code" href="dds_8y.html#a27">add_entry</a>(*DDS_OBJ(arg), &amp;<a class="code" href="dds_8y.html#a7">ctor</a>, &amp;<a class="code" href="dds_8y.html#a8">current</a>, <a class="code" href="dds_8y.html#a9">part</a>); 
00294             }
00295             <span class="keywordflow">else</span> {
00296               <a class="code" href="dds_8y.html#a26">invalid_declaration</a>((<a class="code" href="structparser__arg.html">parser_arg</a> *)arg, smsg, $1, $13);
00297               YYABORT;
00298             }
00299                     strcpy($$,$13);
00300         }
00301 
00302                 | error 
00303                 {
00304             ostrstream <a class="code" href="dds_8y.html#a20">msg</a>;
00305             <a class="code" href="dds_8y.html#a20">msg</a> &lt;&lt; BAD_DECLARATION &lt;&lt; ends;
00306             <a class="code" href="parser-util_8cc.html#a3">parse_error</a>((<a class="code" href="structparser__arg.html">parser_arg</a> *)arg, <a class="code" href="dds_8y.html#a20">msg</a>.str(),
00307                 dds_line_num, $&lt;word&gt;1);
00308             <a class="code" href="dds_8y.html#a20">msg</a>.freeze(0);
00309             YYABORT;
00310         }
00311 ;
00312  
00313 
00314 list:       SCAN_LIST 
00315         { 
00316             <a class="code" href="dds_8y.html#a7">ctor</a>-&gt;push(<a class="code" href="VirtualCtorList_8cc.html#a1">NewList</a>()); 
00317         }
00318 ;
00319 
00320 structure:  SCAN_STRUCTURE
00321         { 
00322             <a class="code" href="dds_8y.html#a7">ctor</a>-&gt;push(<a class="code" href="VirtualCtorStructure_8cc.html#a1">NewStructure</a>()); 
00323         }
00324 ;
00325 
00326 sequence:   SCAN_SEQUENCE 
00327         { 
00328             <a class="code" href="dds_8y.html#a7">ctor</a>-&gt;push(<a class="code" href="VirtualCtorSequence_8cc.html#a1">NewSequence</a>()); 
00329         }
00330 ;
00331 
00332 grid:       SCAN_GRID 
00333         { 
00334             <a class="code" href="dds_8y.html#a7">ctor</a>-&gt;push(<a class="code" href="VirtualCtorGrid_8cc.html#a1">NewGrid</a>()); 
00335         }
00336 ;
00337 
00338 base_type:  SCAN_BYTE { <span class="keywordflow">if</span>( current ) <span class="keyword">delete</span> <a class="code" href="dds_8y.html#a8">current</a> ;<a class="code" href="dds_8y.html#a8">current</a> = <a class="code" href="VirtualCtorByte_8cc.html#a1">NewByte</a>(); }
00339         | SCAN_INT16 { <span class="keywordflow">if</span>( current ) <span class="keyword">delete</span> <a class="code" href="dds_8y.html#a8">current</a> ;<a class="code" href="dds_8y.html#a8">current</a> = <a class="code" href="VirtualCtorInt16_8cc.html#a1">NewInt16</a>(); }
00340         | SCAN_UINT16 { <span class="keywordflow">if</span>( current ) <span class="keyword">delete</span> <a class="code" href="dds_8y.html#a8">current</a> ;<a class="code" href="dds_8y.html#a8">current</a> = <a class="code" href="VirtualCtorUInt16_8cc.html#a1">NewUInt16</a>(); }
00341         | SCAN_INT32 { <span class="keywordflow">if</span>( current ) <span class="keyword">delete</span> <a class="code" href="dds_8y.html#a8">current</a> ;<a class="code" href="dds_8y.html#a8">current</a> = <a class="code" href="VirtualCtorInt32_8cc.html#a1">NewInt32</a>(); }
00342         | SCAN_UINT32 { <span class="keywordflow">if</span>( current ) <span class="keyword">delete</span> <a class="code" href="dds_8y.html#a8">current</a> ;<a class="code" href="dds_8y.html#a8">current</a> = <a class="code" href="VirtualCtorUInt32_8cc.html#a1">NewUInt32</a>(); }
00343         | SCAN_FLOAT32 { <span class="keywordflow">if</span>( current ) <span class="keyword">delete</span> <a class="code" href="dds_8y.html#a8">current</a> ;<a class="code" href="dds_8y.html#a8">current</a> = <a class="code" href="VirtualCtorFloat32_8cc.html#a1">NewFloat32</a>(); }
00344         | SCAN_FLOAT64 { <span class="keywordflow">if</span>( current ) <span class="keyword">delete</span> <a class="code" href="dds_8y.html#a8">current</a> ;<a class="code" href="dds_8y.html#a8">current</a> = <a class="code" href="VirtualCtorFloat64_8cc.html#a1">NewFloat64</a>(); }
00345         | SCAN_STRING { <span class="keywordflow">if</span>( current ) <span class="keyword">delete</span> <a class="code" href="dds_8y.html#a8">current</a> ;<a class="code" href="dds_8y.html#a8">current</a> = <a class="code" href="VirtualCtorStr_8cc.html#a1">NewStr</a>(); }
00346         | SCAN_URL { <span class="keywordflow">if</span>( current ) <span class="keyword">delete</span> <a class="code" href="dds_8y.html#a8">current</a> ;<a class="code" href="dds_8y.html#a8">current</a> = <a class="code" href="VirtualCtorUrl_8cc.html#a1">NewUrl</a>(); }
00347 ;
00348 
00349 var:        var_name { <a class="code" href="dds_8y.html#a8">current</a>-&gt;set_name($1); }
00350         | var <a class="code" href="dds_8y.html#a17">array_decl</a>
00351 ;
00352 
00353 var_name:       SCAN_WORD | SCAN_BYTE | SCAN_INT16 | SCAN_INT32 | SCAN_UINT16
00354                 | SCAN_UINT32 | SCAN_FLOAT32 | SCAN_FLOAT64 | SCAN_STRING
00355                 | SCAN_URL | SCAN_STRUCTURE | SCAN_SEQUENCE | SCAN_GRID
00356                 | SCAN_LIST
00357 ;
00358 
00359 <a class="code" href="dds_8y.html#a17">array_decl</a>: <span class="charliteral">'['</span> SCAN_WORD <span class="charliteral">']'</span>
00360                  { 
00361              <span class="keywordflow">if</span> (!<a class="code" href="parser-util_8cc.html#a10">check_int32</a>($2)) {
00362              string <a class="code" href="dds_8y.html#a20">msg</a> = <span class="stringliteral">"In the dataset descriptor object:\n"</span>;
00363              <a class="code" href="dds_8y.html#a20">msg</a> += <span class="stringliteral">"Expected an array subscript.\n"</span>;
00364              <a class="code" href="parser-util_8cc.html#a3">parse_error</a>((<a class="code" href="structparser__arg.html">parser_arg</a> *)arg, <a class="code" href="dds_8y.html#a20">msg</a>.c_str(), 
00365                  dds_line_num, $2);
00366              }
00367              <span class="keywordflow">if</span> (<a class="code" href="dds_8y.html#a8">current</a>-&gt;type() == <a class="code" href="BaseType_8h.html#a29a23">dods_array_c</a>
00368              &amp;&amp; <a class="code" href="parser-util_8cc.html#a10">check_int32</a>($2)) {
00369              ((<a class="code" href="classArray.html">Array</a> *)<a class="code" href="dds_8y.html#a8">current</a>)-&gt;append_dim(atoi($2));
00370              }
00371              <span class="keywordflow">else</span> {
00372              <a class="code" href="classArray.html">Array</a> *a = <a class="code" href="VirtualCtorArray_8cc.html#a1">NewArray</a>(); 
00373              a-&gt;<a class="code" href="classVector.html#Vectora20">add_var</a>(<a class="code" href="dds_8y.html#a8">current</a>); 
00374              a-&gt;<a class="code" href="classArray.html#Arraya6">append_dim</a>(atoi($2));
00375              <span class="keywordflow">if</span>( current ) <span class="keyword">delete</span> <a class="code" href="dds_8y.html#a8">current</a> ;
00376              <a class="code" href="dds_8y.html#a8">current</a> = a;
00377              }
00378          }
00379 
00380          | <span class="charliteral">'['</span> SCAN_WORD 
00381          {
00382              id = <span class="keyword">new</span> string($2);
00383          } 
00384                  <span class="charliteral">'='</span> SCAN_WORD 
00385                  { 
00386              <span class="keywordflow">if</span> (!<a class="code" href="parser-util_8cc.html#a10">check_int32</a>($5)) {
00387              string <a class="code" href="dds_8y.html#a20">msg</a> = <span class="stringliteral">"In the dataset descriptor object:\n"</span>;
00388              <a class="code" href="dds_8y.html#a20">msg</a> += <span class="stringliteral">"Expected an array subscript.\n"</span>;
00389              <a class="code" href="parser-util_8cc.html#a3">parse_error</a>((<a class="code" href="structparser__arg.html">parser_arg</a> *)arg, <a class="code" href="dds_8y.html#a20">msg</a>.c_str(), 
00390                  dds_line_num, $5);
00391              }
00392              <span class="keywordflow">if</span> (<a class="code" href="dds_8y.html#a8">current</a>-&gt;type() == <a class="code" href="BaseType_8h.html#a29a23">dods_array_c</a>) {
00393              ((<a class="code" href="classArray.html">Array</a> *)<a class="code" href="dds_8y.html#a8">current</a>)-&gt;append_dim(atoi($5), *id);
00394              }
00395              <span class="keywordflow">else</span> {
00396              <a class="code" href="classArray.html">Array</a> *a = <a class="code" href="VirtualCtorArray_8cc.html#a1">NewArray</a>(); 
00397              a-&gt;<a class="code" href="classVector.html#Vectora20">add_var</a>(<a class="code" href="dds_8y.html#a8">current</a>); 
00398              a-&gt;<a class="code" href="classArray.html#Arraya6">append_dim</a>(atoi($5), *id);
00399              <span class="keywordflow">if</span>( current ) <span class="keyword">delete</span> <a class="code" href="dds_8y.html#a8">current</a> ;
00400              <a class="code" href="dds_8y.html#a8">current</a> = a;
00401              }
00402 
00403              <span class="keyword">delete</span> id;
00404          }
00405          <span class="charliteral">']'</span>
00406 
00407          | error
00408                  {
00409              ostrstream <a class="code" href="dds_8y.html#a20">msg</a>;
00410              <a class="code" href="dds_8y.html#a20">msg</a> &lt;&lt; <span class="stringliteral">"In the dataset descriptor object:"</span> &lt;&lt; endl
00411              &lt;&lt; <span class="stringliteral">"Expected an array subscript."</span> &lt;&lt; endl &lt;&lt; ends;
00412              <a class="code" href="parser-util_8cc.html#a3">parse_error</a>((<a class="code" href="structparser__arg.html">parser_arg</a> *)arg, <a class="code" href="dds_8y.html#a20">msg</a>.str(), 
00413                  dds_line_num, $&lt;word&gt;1);
00414              <a class="code" href="dds_8y.html#a20">msg</a>.rdbuf()-&gt;freeze(0);
00415              YYABORT;
00416          }
00417 ;
00418 
00419 <a class="code" href="das_8y.html#a18">name</a>:       var_name { (*DDS_OBJ(arg)).set_dataset_name($1); }
00420         | SCAN_DATASET { (*DDS_OBJ(arg)).set_dataset_name($1); }
00421                 | error 
00422                 {
00423           ostrstream <a class="code" href="dds_8y.html#a20">msg</a>;
00424           <a class="code" href="dds_8y.html#a20">msg</a> &lt;&lt; <span class="stringliteral">"Error parsing the dataset name."</span> &lt;&lt; endl
00425               &lt;&lt; <span class="stringliteral">"The name may be missing or may contain an illegal character."</span> &lt;&lt; endl &lt;&lt; ends;
00426              <a class="code" href="parser-util_8cc.html#a3">parse_error</a>((<a class="code" href="structparser__arg.html">parser_arg</a> *)arg, <a class="code" href="dds_8y.html#a20">msg</a>.str(),
00427                  dds_line_num, $&lt;word&gt;1);
00428              <a class="code" href="dds_8y.html#a20">msg</a>.rdbuf()-&gt;freeze(0);
00429              YYABORT;
00430         }
00431 ;
00432 
00433 %%
00434 
00435 <span class="comment">/* </span>
00436 <span class="comment">   This function must be defined. However, use the error reporting code in</span>
00437 <span class="comment">   parser-utils.cc.</span>
00438 <span class="comment">*/</span>
00439 
00440 <span class="keywordtype">void</span> 
00441 <a class="code" href="dds_8y.html#a25">ddserror</a>(<span class="keywordtype">char</span> *)
00442 {
00443 }
00444 
00445 <span class="comment">/*</span>
00446 <span class="comment">  Invalid declaration message.</span>
00447 <span class="comment">*/</span>
00448 
00449 <span class="keywordtype">void</span>
00450 <a class="code" href="dds_8y.html#a26">invalid_declaration</a>(<a class="code" href="structparser__arg.html">parser_arg</a> *arg, string semantic_err_msg, <span class="keywordtype">char</span> *type, 
00451             <span class="keywordtype">char</span> *<a class="code" href="das_8y.html#a18">name</a>)
00452 {
00453   ostrstream <a class="code" href="dds_8y.html#a20">msg</a>;
00454   <a class="code" href="dds_8y.html#a20">msg</a> &lt;&lt; <span class="stringliteral">"In the dataset descriptor object: `"</span> &lt;&lt; type &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; <a class="code" href="das_8y.html#a18">name</a> 
00455       &lt;&lt; <span class="stringliteral">"'"</span> &lt;&lt; endl &lt;&lt; <span class="stringliteral">"is not a valid declaration."</span> &lt;&lt; endl 
00456       &lt;&lt; semantic_err_msg &lt;&lt; ends;
00457   <a class="code" href="parser-util_8cc.html#a3">parse_error</a>((<a class="code" href="structparser__arg.html">parser_arg</a> *)arg, <a class="code" href="dds_8y.html#a20">msg</a>.str(), dds_line_num);
00458   <a class="code" href="dds_8y.html#a20">msg</a>.rdbuf()-&gt;freeze(0);
00459 }
00460 
00461 <span class="comment">/*</span>
00462 <span class="comment">  Add the variable pointed to by CURRENT to either the topmost ctor object on</span>
00463 <span class="comment">  the stack CTOR or to the dataset variable table TABLE if CTOR is empty.  If</span>
00464 <span class="comment">  it exists, the current ctor object is popped off the stack and assigned to</span>
00465 <span class="comment">  CURRENT.</span>
00466 <span class="comment"></span>
00467 <span class="comment">  NB: the ctor stack is popped for lists and arrays because they are ctors</span>
00468 <span class="comment">  which contain only a single variable. For other ctor types, several</span>
00469 <span class="comment">  variables may be members and the parse rule (see `declaration' above)</span>
00470 <span class="comment">  determines when to pop the stack. </span>
00471 <span class="comment"></span>
00472 <span class="comment">  Returns: void </span>
00473 <span class="comment">*/</span>
00474 
00475 <span class="keywordtype">void</span>    
00476 <a class="code" href="dds_8y.html#a27">add_entry</a>(<a class="code" href="classDDS.html">DDS</a> &amp;table, stack&lt;BaseType *&gt; **<a class="code" href="dds_8y.html#a7">ctor</a>, <a class="code" href="classBaseType.html">BaseType</a> **<a class="code" href="dds_8y.html#a8">current</a>, <a class="code" href="BaseType_8h.html#a28">Part</a> <a class="code" href="dds_8y.html#a9">part</a>)
00477 { 
00478     <span class="keywordflow">if</span> (!*<a class="code" href="dds_8y.html#a7">ctor</a>)
00479     *<a class="code" href="dds_8y.html#a7">ctor</a> = <span class="keyword">new</span> stack&lt;BaseType *&gt;;
00480 
00481     <span class="keywordflow">if</span> (!(*ctor)-&gt;empty()) { <span class="comment">/* must be parsing a ctor type */</span>
00482     (*ctor)-&gt;top()-&gt;add_var(*current, <a class="code" href="dds_8y.html#a9">part</a>);
00483 
00484     <span class="keyword">const</span> <a class="code" href="BaseType_8h.html#a29">Type</a> &amp;ctor_type = (*ctor)-&gt;top()-&gt;type();
00485 
00486     <span class="keywordflow">if</span> (ctor_type == <a class="code" href="BaseType_8h.html#a29a24">dods_list_c</a> || ctor_type == <a class="code" href="BaseType_8h.html#a29a23">dods_array_c</a>) {
00487         <span class="keywordflow">if</span>( *current ) <span class="keyword">delete</span> *current ;
00488         *current = (*ctor)-&gt;top();
00489         (*ctor)-&gt;pop();
00490     }
00491     <span class="keywordflow">else</span>
00492         <span class="keywordflow">return</span>;
00493     }
00494     <span class="keywordflow">else</span>
00495     table.<a class="code" href="classDDS.html#DDSa4">add_var</a>(*current);
00496 }
00497 
00498 <span class="comment">/* </span>
00499 <span class="comment"> * $Log: dds_8y-source.html,v $
00499 <span class="comment"> * Revision 1.2  2004/01/30 22:51:15  jimg
00499 <span class="comment"> * Updated 2004/01/30.
00499 <span class="comment"> *</span>
00500 <span class="comment"> * Revision 1.42  2003/04/22 19:40:28  jimg</span>
00501 <span class="comment"> * Merged with 3.3.1.</span>
00502 <span class="comment"> *</span>
00503 <span class="comment"> * Revision 1.41  2003/02/21 00:14:25  jimg</span>
00504 <span class="comment"> * Repaired copyright.</span>
00505 <span class="comment"> *</span>
00506 <span class="comment"> * Revision 1.40.2.1  2003/02/21 00:10:08  jimg</span>
00507 <span class="comment"> * Repaired copyright.</span>
00508 <span class="comment"> *</span>
00509 <span class="comment"> * Revision 1.40  2003/01/23 00:22:24  jimg</span>
00510 <span class="comment"> * Updated the copyright notice; this implementation of the DAP is</span>
00511 <span class="comment"> * copyrighted by OPeNDAP, Inc.</span>
00512 <span class="comment"> *</span>
00513 <span class="comment"> * Revision 1.39  2003/01/10 19:46:41  jimg</span>
00514 <span class="comment"> * Merged with code tagged release-3-2-10 on the release-3-2 branch. In many</span>
00515 <span class="comment"> * cases files were added on that branch (so they appear on the trunk for</span>
00516 <span class="comment"> * the first time).</span>
00517 <span class="comment"> *</span>
00518 <span class="comment"> * Revision 1.33.4.7  2002/12/24 00:24:44  jimg</span>
00519 <span class="comment"> * I removed a variable, current_save, that was unused after Patrick fixed a bug.</span>
00520 <span class="comment"> *</span>
00521 <span class="comment"> * Revision 1.33.4.6  2002/11/21 21:24:17  pwest</span>
00522 <span class="comment"> * memory leak cleanup and file descriptor cleanup</span>
00523 <span class="comment"> *</span>
00524 <span class="comment"> * Revision 1.38  2002/06/03 22:21:16  jimg</span>
00525 <span class="comment"> * Merged with release-3-2-9</span>
00526 <span class="comment"> *</span>
00527 <span class="comment"> * Revision 1.37  2002/05/22 21:52:31  jimg</span>
00528 <span class="comment"> * I added a new rule called start. This rule is used to initialize objects used</span>
00529 <span class="comment"> * by the parser (like the stack of ctors). The logic of the parser have not</span>
00530 <span class="comment"> * been changed. This just localizes the code to init this object.</span>
00531 <span class="comment"> *</span>
00532 <span class="comment"> * Revision 1.33.4.5  2001/11/03 10:08:07  rmorris</span>
00533 <span class="comment"> * Fixed four lines that were using assignment "=" on addresses of strings.</span>
00534 <span class="comment"> * Assumed a string copy was what was meant.  "$$ = $2" to "strcpy($$,$2)"</span>
00535 <span class="comment"> * where the $$ and $2 generate vars that are string addresses.  Left note</span>
00536 <span class="comment"> * to James to make sure what I assumed he meant was what he actually meant.</span>
00537 <span class="comment"> *</span>
00538 <span class="comment"> * Revision 1.33.4.4  2001/11/01 00:43:51  jimg</span>
00539 <span class="comment"> * Fixes to the scanners and parsers so that dataset variable names may</span>
00540 <span class="comment"> * start with digits. I've expanded the set of characters that may appear</span>
00541 <span class="comment"> * in a variable name and made it so that all except `#' may appear at</span>
00542 <span class="comment"> * the start. Some characters are not allowed in variables that appear in</span>
00543 <span class="comment"> * a DDS or CE while they are allowed in the DAS. This makes it possible</span>
00544 <span class="comment"> * to define containers with names like `COARDS:long_name.' Putting a colon</span>
00545 <span class="comment"> * in a variable name makes the CE parser much more complex. Since the set</span>
00546 <span class="comment"> * of characters that people want seems pretty limited (compared to the</span>
00547 <span class="comment"> * complete ASCII set) I think this is an OK approach. If we have to open</span>
00548 <span class="comment"> * up the expr.lex scanner completely, then we can but not without adding</span>
00549 <span class="comment"> * lots of action clauses to teh parser. Note that colon is just an example,</span>
00550 <span class="comment"> * there's a host of characters that are used in CEs that are not allowed</span>
00551 <span class="comment"> * in IDs.</span>
00552 <span class="comment"> *</span>
00553 <span class="comment"> * Revision 1.36  2001/08/24 17:46:22  jimg</span>
00554 <span class="comment"> * Resolved conflicts from the merge of release 3.2.6</span>
00555 <span class="comment"> *</span>
00556 <span class="comment"> * Revision 1.33.4.3  2001/06/23 00:52:08  jimg</span>
00557 <span class="comment"> * Normalized the definitions of ID (SCAN_ID), INT, FLOAT and NEVER so</span>
00558 <span class="comment"> * that they are (more or less) the same in all the scanners. There are</span>
00559 <span class="comment"> * one or two characters that differ (for example das.lex allows ( and )</span>
00560 <span class="comment"> * in an ID while dds.lex, expr.lex and gse.lex don't) but the definitions</span>
00561 <span class="comment"> * are essentially the same across the board.</span>
00562 <span class="comment"> * Added `#' to the set of characeters allowed in an ID (bug 179).</span>
00563 <span class="comment"> *</span>
00564 <span class="comment"> * Revision 1.35  2001/06/15 23:49:03  jimg</span>
00565 <span class="comment"> * Merged with release-3-2-4.</span>
00566 <span class="comment"> *</span>
00567 <span class="comment"> * Revision 1.33.4.2  2001/05/08 19:10:47  jimg</span>
00568 <span class="comment"> * Expanded the set of names that the dds.y parser will recognize to</span>
00569 <span class="comment"> * include integers (for files named like 990412.nc). Also removed the</span>
00570 <span class="comment"> * unused keywords Dependent and Independent from both the DDS scanner</span>
00571 <span class="comment"> * and parser.</span>
00572 <span class="comment"> * Added other reserved words to the set of possible Dataset names.</span>
00573 <span class="comment"> *</span>
00574 <span class="comment"> * Revision 1.33.4.1  2001/05/04 00:12:10  jimg</span>
00575 <span class="comment"> * Added a rule that allows variable names to be the names of datatypes.</span>
00576 <span class="comment"> *</span>
00577 <span class="comment"> * Revision 1.33  2000/09/22 02:17:22  jimg</span>
00578 <span class="comment"> * Rearranged source files so that the CVS logs appear at the end rather than</span>
00579 <span class="comment"> * the start. Also made the ifdef guard symbols use the same naming scheme and</span>
00580 <span class="comment"> * wrapped headers included in other headers in those guard symbols (to cut</span>
00581 <span class="comment"> * down on extraneous file processing - See Lakos).</span>
00582 <span class="comment"> *</span>
00583 <span class="comment"> * Revision 1.32  2000/09/21 16:22:10  jimg</span>
00584 <span class="comment"> * Merged changes from Jose Garcia that add exceptions to the software.</span>
00585 <span class="comment"> * Many methods that returned error codes now throw exectptions. There are</span>
00586 <span class="comment"> * two classes which are thrown by the software, Error and InternalErr.</span>
00587 <span class="comment"> * InternalErr is used to report errors within the library or errors using</span>
00588 <span class="comment"> * the library. Error is used to reprot all other errors. Since InternalErr</span>
00589 <span class="comment"> * is a subclass of Error, programs need only to catch Error.</span>
00590 <span class="comment"> *</span>
00591 <span class="comment"> * Revision 1.31  2000/08/16 18:29:02  jimg</span>
00592 <span class="comment"> * Added dot (.) to the set of characters allowed in a variable name</span>
00593 <span class="comment"> *</span>
00594 <span class="comment"> * Revision 1.30  2000/07/09 21:43:29  rmorris</span>
00595 <span class="comment"> * Mods to increase portability, minimize ifdef's for win32</span>
00596 <span class="comment"> *</span>
00597 <span class="comment"> * Revision 1.29  2000/06/07 18:07:00  jimg</span>
00598 <span class="comment"> * Merged the pc port branch</span>
00599 <span class="comment"> *</span>
00600 <span class="comment"> * Revision 1.28.6.1  2000/06/02 18:36:38  rmorris</span>
00601 <span class="comment"> * Mod's for port to Win32.</span>
00602 <span class="comment"> *</span>
00603 <span class="comment"> * Revision 1.27.8.1  2000/02/17 05:03:17  jimg</span>
00604 <span class="comment"> * Added file and line number information to calls to InternalErr.</span>
00605 <span class="comment"> * Resolved compile-time problems with read due to a change in its</span>
00606 <span class="comment"> * parameter list given that errors are now reported using exceptions.</span>
00607 <span class="comment"> *</span>
00608 <span class="comment"> * Revision 1.28  2000/01/27 06:30:00  jimg</span>
00609 <span class="comment"> * Resolved conflicts from merge with release-3-1-4</span>
00610 <span class="comment"> *</span>
00611 <span class="comment"> * Revision 1.27.2.1  2000/01/24 22:25:10  jimg</span>
00612 <span class="comment"> * Removed static global objects</span>
00613 <span class="comment"> *</span>
00614 <span class="comment"> * Revision 1.27  1999/07/22 17:07:47  jimg</span>
00615 <span class="comment"> * Fixed a bug found by Peter Fox. Array index names were not handled properly</span>
00616 <span class="comment"> * after the String to string conversion.</span>
00617 <span class="comment"> *</span>
00618 <span class="comment"> * Revision 1.26  1999/05/04 19:47:23  jimg</span>
00619 <span class="comment"> * Fixed copyright statements. Removed more of the GNU classes.</span>
00620 <span class="comment"> *</span>
00621 <span class="comment"> * Revision 1.25  1999/04/29 02:29:36  jimg</span>
00622 <span class="comment"> * Merge of no-gnu branch</span>
00623 <span class="comment"> *</span>
00624 <span class="comment"> * Revision 1.24  1999/03/24 23:32:33  jimg</span>
00625 <span class="comment"> * Added support for the new Int16, UInt16 and Float32 types.</span>
00626 <span class="comment"> *</span>
00627 <span class="comment"> * Revision 1.23  1998/08/13 22:12:44  jimg</span>
00628 <span class="comment"> * Fixed error messages.</span>
00629 <span class="comment"> *</span>
00630 <span class="comment"> * Revision 1.22.6.2  1999/02/05 09:32:36  jimg</span>
00631 <span class="comment"> * Fixed __unused__ so that it not longer clashes with Red Hat 5.2 inlined</span>
00632 <span class="comment"> * math code. </span>
00633 <span class="comment"> *</span>
00634 <span class="comment"> * Revision 1.22.6.1  1999/02/02 21:57:06  jimg</span>
00635 <span class="comment"> * String to string version</span>
00636 <span class="comment"> *</span>
00637 <span class="comment"> * Revision 1.22  1997/11/20 20:14:10  jimg</span>
00638 <span class="comment"> * Added to the name rule so that it recognizes both the ID and NAME lexeme</span>
00639 <span class="comment"> * as valid when parsing the dataset name. NAME (see dds.lex) is just like ID</span>
00640 <span class="comment"> * except that it includes `.'. Thus datasets with names like sst.reynolds.nc</span>
00641 <span class="comment"> * now parse correctly.</span>
00642 <span class="comment"> *</span>
00643 <span class="comment"> * Revision 1.21  1997/02/28 01:31:22  jimg</span>
00644 <span class="comment"> * Added error messages.</span>
00645 <span class="comment"> *</span>
00646 <span class="comment"> * Revision 1.20  1996/10/28 23:44:16  jimg</span>
00647 <span class="comment"> * Added unsigned int to set of possible datatypes.</span>
00648 <span class="comment"> *</span>
00649 <span class="comment"> * Revision 1.19  1996/10/16 22:35:31  jimg</span>
00650 <span class="comment"> * Fixed bad operator in DODS_BISON_VER preprocessor statement.</span>
00651 <span class="comment"> *</span>
00652 <span class="comment"> * Revision 1.18  1996/10/08 17:04:42  jimg</span>
00653 <span class="comment"> * Added a fix for Bison 1.25 so that PARSE_PARAM will still work</span>
00654 <span class="comment"> *</span>
00655 <span class="comment"> * Revision 1.17  1996/08/13 20:54:45  jimg</span>
00656 <span class="comment"> * Generated files.</span>
00657 <span class="comment"> *</span>
00658 <span class="comment"> * Revision 1.16  1996/05/31 23:27:17  jimg</span>
00659 <span class="comment"> * Removed {YYACCEPT;} from rule 2 (dataset: DATASET ...).</span>
00660 <span class="comment"> *</span>
00661 <span class="comment"> * Revision 1.15  1996/05/29 21:59:51  jimg</span>
00662 <span class="comment"> * *** empty log message ***</span>
00663 <span class="comment"> *</span>
00664 <span class="comment"> * Revision 1.14  1996/05/14 15:38:54  jimg</span>
00665 <span class="comment"> * These changes have already been checked in once before. However, I</span>
00666 <span class="comment"> * corrupted the source repository and restored it from a 5/9/96 backup</span>
00667 <span class="comment"> * tape. The previous version's log entry should cover the changes.</span>
00668 <span class="comment"> *</span>
00669 <span class="comment"> * Revision 1.13  1996/04/05 21:59:38  jimg</span>
00670 <span class="comment"> * Misc Changes for release 2.0.1 of the core software - for developers.</span>
00671 <span class="comment"> *</span>
00672 <span class="comment"> * Revision 1.12  1996/04/05 00:06:45  jimg</span>
00673 <span class="comment"> * Merged changes from version 1.1.1.</span>
00674 <span class="comment"> * Eliminated the static global CTOR.</span>
00675 <span class="comment"> *</span>
00676 <span class="comment"> * Revision 1.11  1995/12/06 19:45:08  jimg</span>
00677 <span class="comment"> * Changed grammar so that List List ... &lt;type&gt; is no longer possible. This</span>
00678 <span class="comment"> * fixed some hard problems in the serailize/deserailize mfuncs.</span>
00679 <span class="comment"> *</span>
00680 <span class="comment"> * Revision 1.10  1995/10/23  22:59:41  jimg</span>
00681 <span class="comment"> * Modified some rules so that they use the functions defined in</span>
00682 <span class="comment"> * parser_util.cc instead of local definitions.</span>
00683 <span class="comment"> *</span>
00684 <span class="comment"> * Revision 1.9  1995/08/23  00:27:47  jimg</span>
00685 <span class="comment"> * Uses new member functions.</span>
00686 <span class="comment"> * Added copyright notice.</span>
00687 <span class="comment"> * Switched from String to enum type representation.</span>
00688 <span class="comment"> *</span>
00689 <span class="comment"> * Revision 1.8.2.1  1996/04/04 23:24:44  jimg</span>
00690 <span class="comment"> * Removed static global CTOR from the dds parser. The stack for constructor</span>
00691 <span class="comment"> * variable is now managed via a pointer. The stack is allocated when first</span>
00692 <span class="comment"> * used by add_entry().</span>
00693 <span class="comment"> *</span>
00694 <span class="comment"> * Revision 1.8  1995/01/19  20:13:04  jimg</span>
00695 <span class="comment"> * The parser now uses the new utility functions to create new instances</span>
00696 <span class="comment"> * of the variable objects (Byte, ..., Grid).</span>
00697 <span class="comment"> * Fixed the number of shift/reduce conflicts expected (now at 60).</span>
00698 <span class="comment"> *</span>
00699 <span class="comment"> * Revision 1.7  1994/12/22  04:30:57  reza</span>
00700 <span class="comment"> * Made save_str static to avoid linking conflict.</span>
00701 <span class="comment"> *</span>
00702 <span class="comment"> * Revision 1.6  1994/12/16  22:24:23  jimg</span>
00703 <span class="comment"> * Switched from a CtorType stack to BaseType stack.</span>
00704 <span class="comment"> * Fixed an error in save_str() (see das.y).</span>
00705 <span class="comment"> * Fixed a bug in the use of append_dim - it was called with $4 when it</span>
00706 <span class="comment"> * should have been called with $5.</span>
00707 <span class="comment"> *</span>
00708 <span class="comment"> * Revision 1.5  1994/12/09  21:42:41  jimg</span>
00709 <span class="comment"> * Added to array: so that an array decl can contain: an int or an id=int.</span>
00710 <span class="comment"> * This is for the named dimensions (see Array.{cc,h}).</span>
00711 <span class="comment"> *</span>
00712 <span class="comment"> * Revision 1.4  1994/11/10  19:50:54  jimg</span>
00713 <span class="comment"> * In the past it was possible to have a null file correctly parse as a</span>
00714 <span class="comment"> * DAS or DDS. However, now that is not possible. It is possible to have</span>
00715 <span class="comment"> * a file that contains no variables parse, but the keyword `Attribute'</span>
00716 <span class="comment"> * or `Dataset' *must* be present. This was changed so that errors from</span>
00717 <span class="comment"> * the CGIs could be detected (since they return nothing in the case of</span>
00718 <span class="comment"> * a error).</span>
00719 <span class="comment"> *</span>
00720 <span class="comment"> * Revision 1.3  1994/09/23  14:56:19  jimg</span>
00721 <span class="comment"> * Added code to build in-memory DDS during parse.</span>
00722 <span class="comment"> *</span>
00723 <span class="comment"> * Revision 1.2  1994/09/15  21:11:56  jimg</span>
00724 <span class="comment"> * Modified dds.y so that it can parse all the DDS types.</span>
00725 <span class="comment"> * Still no error checking beyond what bison gives you.</span>
00726 <span class="comment"> *</span>
00727 <span class="comment"> * Revision 1.1  1994/09/08  21:10:45  jimg</span>
00728 <span class="comment"> * DDS Class test driver and parser and scanner.</span>
00729 <span class="comment"> */</span>
00730 
</pre></div><hr><address style="align: right;"><small>Generated on Tue Aug 19 12:42:02 2003 for OPeNDAP by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>
