<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libdap++: expr-test.cc Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>expr-test.cc</h1><a href="expr-test_8cc.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00002 <span class="comment">// -*- mode: c++; c-basic-offset:4 -*-</span>
00003 
00004 <span class="comment">// This file is part of libdap, A C++ implementation of the OPeNDAP Data</span>
00005 <span class="comment">// Access Protocol.</span>
00006 
00007 <span class="comment">// Copyright (c) 2002,2003 OPeNDAP, Inc.</span>
00008 <span class="comment">// Author: James Gallagher &lt;jgallagher@opendap.org&gt;</span>
00009 <span class="comment">//</span>
00010 <span class="comment">// This library is free software; you can redistribute it and/or</span>
00011 <span class="comment">// modify it under the terms of the GNU Lesser General Public</span>
00012 <span class="comment">// License as published by the Free Software Foundation; either</span>
00013 <span class="comment">// version 2.1 of the License, or (at your option) any later version.</span>
00014 <span class="comment">// </span>
00015 <span class="comment">// This library is distributed in the hope that it will be useful,</span>
00016 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00017 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00018 <span class="comment">// Lesser General Public License for more details.</span>
00019 <span class="comment">// </span>
00020 <span class="comment">// You should have received a copy of the GNU Lesser General Public</span>
00021 <span class="comment">// License along with this library; if not, write to the Free Software</span>
00022 <span class="comment">// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00023 <span class="comment">//</span>
00024 <span class="comment">// You can contact OPeNDAP, Inc. at PO Box 112, Saunderstown, RI. 02874-0112.</span>
00025  
00026 <span class="comment">// (c) COPYRIGHT URI/MIT 1995-1999</span>
00027 <span class="comment">// Please read the full copyright statement in the file COPYRIGHT_URI.</span>
00028 <span class="comment">//</span>
00029 <span class="comment">// Authors:</span>
00030 <span class="comment">//      jhrg,jimg       James Gallagher &lt;jgallagher@gso.uri.edu&gt;</span>
00031 
00032 <span class="comment">// Test the CE scanner and parser.</span>
00033 <span class="comment">//</span>
00034 <span class="comment">// jhrg 9/12/95</span>
00035 
00036 <span class="preprocessor">#include "<a class="code" href="config__dap_8h.html">config_dap.h</a>"</span>
00037 
00038 <span class="keyword">static</span> <span class="keywordtype">char</span> rcsid[] <a class="code" href="config__dap_8h.html#a49">not_used</a> = {<span class="stringliteral">"$Id$"</span>};
00039 
00040 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00041 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00042 <span class="preprocessor">#ifndef WIN32</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#include &lt;unistd.h&gt;</span>
00044 <span class="preprocessor">#endif</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#include &lt;string.h&gt;</span>
00046 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00047 
00048 <span class="preprocessor">#ifdef WIN32</span>
00049 <span class="preprocessor"></span><span class="preprocessor">#include &lt;rpc.h&gt;</span>
00050 <span class="preprocessor">#include &lt;winsock.h&gt;</span>
00051 <span class="preprocessor">#include &lt;xdr.h&gt;</span>
00052 <span class="preprocessor">#include &lt;io.h&gt;</span>
00053 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
00054 <span class="preprocessor">#else</span>
00055 <span class="preprocessor"></span><span class="preprocessor">#include &lt;rpc/types.h&gt;</span>
00056 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00057 <span class="preprocessor">#include &lt;rpc/xdr.h&gt;</span>
00058 <span class="preprocessor">#endif</span>
00059 <span class="preprocessor"></span>
00060 <span class="preprocessor">#include &lt;GetOpt.h&gt;</span>
00061 
00062 <span class="preprocessor">#include &lt;string&gt;</span>
00063 
00064 <span class="preprocessor">#include "<a class="code" href="DDS_8h.html">DDS.h</a>"</span>
00065 <span class="preprocessor">#include "<a class="code" href="DataDDS_8h.html">DataDDS.h</a>"</span>
00066 <span class="preprocessor">#include "<a class="code" href="BaseType_8h.html">BaseType.h</a>"</span>
00067 
00068 <span class="preprocessor">#include "<a class="code" href="parser_8h.html">parser.h</a>"</span>
00069 <span class="preprocessor">#include "expr.h"</span>
00070 <span class="preprocessor">#include "expr.tab.h"</span>
00071 <span class="preprocessor">#include "<a class="code" href="util_8h.html">util.h</a>"</span>
00072 <span class="preprocessor">#include "<a class="code" href="debug_8h.html">debug.h</a>"</span>
00073 
00074 <span class="keyword">using</span> std::cin;
00075 
<a name="l00076"></a><a class="code" href="expr-test_8cc.html#a3">00076</a> <span class="keywordtype">int</span> <a class="code" href="expr-test_8cc.html#a3">test_variable_sleep_interval</a> = 0; <span class="comment">// Used in Test* classes for testing</span>
00077                       <span class="comment">// timeouts. </span>
00078 
<a name="l00079"></a><a class="code" href="expr-test_8cc.html#a0">00079</a> <span class="preprocessor">#define DODS_DDS_PRX "dods_dds"</span>
<a name="l00080"></a><a class="code" href="expr-test_8cc.html#a1">00080</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_BUFFER_STATE (void *)</span>
00081 <span class="preprocessor"></span>
00082 <span class="keywordtype">void</span> <a class="code" href="das-test_8cc.html#a9">test_scanner</a>(<span class="keyword">const</span> string &amp;str);
00083 <span class="keywordtype">void</span> <a class="code" href="das-test_8cc.html#a9">test_scanner</a>(<span class="keywordtype">bool</span> show_prompt);
00084 <span class="keywordtype">void</span> <a class="code" href="dds-test_8cc.html#a5">test_parser</a>(<a class="code" href="classDDS.html">DDS</a> &amp;table, <span class="keyword">const</span> string &amp;dds_name, <span class="keyword">const</span> string &amp;constraint);
00085 <span class="keywordtype">bool</span> <a class="code" href="expr-test_8cc.html#a13">read_table</a>(<a class="code" href="classDDS.html">DDS</a> &amp;table, <span class="keyword">const</span> string &amp;name, <span class="keywordtype">bool</span> print);
00086 <span class="keywordtype">void</span> <a class="code" href="expr-test_8cc.html#a14">evaluate_dds</a>(<a class="code" href="classDDS.html">DDS</a> &amp;table, <span class="keywordtype">bool</span> print_constrained);
00087 <span class="keywordtype">bool</span> <a class="code" href="expr-test_8cc.html#a15">loopback_pipe</a>(FILE **pout, FILE **pin);
00088 <span class="keywordtype">bool</span> <a class="code" href="expr-test_8cc.html#a16">constrained_trans</a>(<span class="keyword">const</span> string &amp;dds_name, string dataset,
00089                <span class="keyword">const</span> string &amp;ce);
00090 
00091 <span class="keywordtype">int</span> <a class="code" href="expr-test_8cc.html#a17">exprlex</a>();          <span class="comment">// exprlex() uses the global exprlval</span>
00092 <span class="keywordtype">int</span> <a class="code" href="expr-test_8cc.html#a18">exprparse</a>(<span class="keywordtype">void</span> *arg);
00093 <span class="keywordtype">void</span> <a class="code" href="expr-test_8cc.html#a19">exprrestart</a>(FILE *in);
00094 
00095 <span class="comment">// Glue routines declared in expr.lex</span>
00096 <span class="keywordtype">void</span> <a class="code" href="expr-test_8cc.html#a20">expr_switch_to_buffer</a>(<span class="keywordtype">void</span> *new_buffer);
00097 <span class="keywordtype">void</span> <a class="code" href="expr-test_8cc.html#a21">expr_delete_buffer</a>(<span class="keywordtype">void</span> * buffer);
00098 <span class="keywordtype">void</span> *<a class="code" href="expr-test_8cc.html#a22">expr_string</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *yy_str);
00099 
<a name="l00100"></a><a class="code" href="expr-test_8cc.html#a4">00100</a> <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="expr-test_8cc.html#a4">exprdebug</a>;
00101 
00102 <span class="keyword">static</span> <span class="keywordtype">int</span> keep_temps = 0;  <span class="comment">// MT-safe; test code.</span>
00103 
<a name="l00104"></a><a class="code" href="expr-test_8cc.html#a6">00104</a> <span class="keyword">const</span> string <a class="code" href="das-test_8cc.html#a4">version</a> = <span class="stringliteral">"version 1.12"</span>;
<a name="l00105"></a><a class="code" href="expr-test_8cc.html#a7">00105</a> <span class="keyword">const</span> string <a class="code" href="das-test_8cc.html#a3">prompt</a> = <span class="stringliteral">"expr-test: "</span>;
<a name="l00106"></a><a class="code" href="expr-test_8cc.html#a8">00106</a> <span class="keyword">const</span> string <a class="code" href="expr-test_8cc.html#a8">options</a> = <span class="stringliteral">"sS:decvp:w:f:k:v"</span>;
00107 <span class="keyword">const</span> string <a class="code" href="error-test_8cc.html#a9">usage</a> = <span class="stringliteral">"\</span>
00108 <span class="stringliteral">\nexpr-test [-s [-S string] -d -c -v [-p dds-file]\</span>
00109 <span class="stringliteral">\n[-e expr] [-w dds-file] [-f data-file] [-k expr]]\</span>
00110 <span class="stringliteral">\nTest the expression evaluation software.\</span>
00111 <span class="stringliteral">\nOptions:\</span>
00112 <span class="stringliteral">\n  -s: Feed the input stream directly into the expression scanner, does\</span>
00113 <span class="stringliteral">\n      not parse.\</span>
00114 <span class="stringliteral">\n        -S: &lt;string&gt; Scan the string as if it was standard input.\</span>
00115 <span class="stringliteral">\n  -d: Turn on expression parser debugging.\</span>
00116 <span class="stringliteral">\n  -c: Print the constrained DDS (the one that will be returned\</span>
00117 <span class="stringliteral">\n      prepended to a data transmission. Must also supply -p and -e \</span>
00118 <span class="stringliteral">\n  -t: Test transmission of data. This uses the Test*classes.\</span>
00119 <span class="stringliteral">\n      Transmission is done using a single process that writes and then\</span>
00120 <span class="stringliteral">\n      reads from a pipe. Must also suppply -p.\</span>
00121 <span class="stringliteral">\n      -v: Verbose output\</span>
00122 <span class="stringliteral">\n      -V: Print the version of expr-test\</span>
00123 <span class="stringliteral">\n      -p: DDS-file: Read the DDS from DDS-file and create a DDS object,\</span>
00124 <span class="stringliteral">\n      then prompt for an expression and parse that expression, given\</span>
00125 <span class="stringliteral">\n      the DDS object.\</span>
00126 <span class="stringliteral">\n  -e: Evaluate the constraint expression. Must be used with -p.\</span>
00127 <span class="stringliteral">\n  -w: Do the whole enchilada. You don't need to supply -p, -e, ...\</span>
00128 <span class="stringliteral">\n       This prompts for the constraint expression and the optional\</span>
00129 <span class="stringliteral">\n             data file name. NOTE: The CE parser Error objects do not print\</span>
00130 <span class="stringliteral">\n             with this option.\</span>
00131 <span class="stringliteral">\n  -f: A file to use for data. Currently only used by -w for sequences.\</span>
00132 <span class="stringliteral">\n  -k: A constraint expression to use with the data. Works with -p,\</span>
00133 <span class="stringliteral">\n      -e, -t and -w"</span>;
00134 
00135 <span class="preprocessor">#ifdef WIN32</span>
00136 <span class="preprocessor"></span><span class="keywordtype">void</span>
00137 <span class="preprocessor">#else</span>
00138 <span class="preprocessor"></span><span class="keywordtype">int</span>
00139 <span class="preprocessor">#endif</span>
<a name="l00140"></a><a class="code" href="expr-test_8cc.html#a23">00140</a> <span class="preprocessor"></span><a class="code" href="usage_8cc.html#a17">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
00141 {
00142     GetOpt getopt(argc, argv, <a class="code" href="expr-test_8cc.html#a8">options</a>.c_str());
00143     <span class="keywordtype">int</span> option_char;
00144     <span class="keywordtype">bool</span> scanner_test = <span class="keyword">false</span>, parser_test = <span class="keyword">false</span>, evaluate_test = <span class="keyword">false</span>;
00145     <span class="keywordtype">bool</span> print_constrained = <span class="keyword">false</span>;
00146     <span class="keywordtype">bool</span> whole_enchalada = <span class="keyword">false</span>, constraint_expr = <span class="keyword">false</span>;
00147     <span class="keywordtype">bool</span> scan_string = <span class="keyword">false</span>;
00148     <span class="keywordtype">bool</span> verbose = <span class="keyword">false</span>;
00149     string dds_file_name;
00150     string dataset = <span class="stringliteral">""</span>;
00151     string constraint = <span class="stringliteral">""</span>;
00152     <a class="code" href="classDDS.html">DDS</a> table;
00153 
00154     <span class="comment">// process options</span>
00155 
00156     <span class="keywordflow">while</span> ((option_char = getopt()) != EOF)
00157     <span class="keywordflow">switch</span> (option_char) {
00158       <span class="keywordflow">case</span> <span class="charliteral">'d'</span>: 
00159         <a class="code" href="expr-test_8cc.html#a4">exprdebug</a> = <span class="keyword">true</span>;
00160         <span class="keywordflow">break</span>;
00161       <span class="keywordflow">case</span> <span class="charliteral">'s'</span>:
00162         scanner_test = <span class="keyword">true</span>;
00163         <span class="keywordflow">break</span>;
00164       <span class="keywordflow">case</span> <span class="charliteral">'S'</span>:
00165         scanner_test = <span class="keyword">true</span>;
00166         scan_string = <span class="keyword">true</span>;
00167         constraint = getopt.optarg;
00168         <span class="keywordflow">break</span>;
00169       <span class="keywordflow">case</span> <span class="charliteral">'p'</span>:
00170         parser_test = <span class="keyword">true</span>;
00171         dds_file_name = getopt.optarg;
00172         <span class="keywordflow">break</span>;
00173       <span class="keywordflow">case</span> <span class="charliteral">'e'</span>:
00174         evaluate_test = <span class="keyword">true</span>;
00175         <span class="keywordflow">break</span>;
00176       <span class="keywordflow">case</span> <span class="charliteral">'c'</span>:
00177         print_constrained = <span class="keyword">true</span>;
00178         <span class="keywordflow">break</span>;
00179       <span class="keywordflow">case</span> <span class="charliteral">'w'</span>:
00180         whole_enchalada = <span class="keyword">true</span>;
00181         dds_file_name = getopt.optarg;
00182         <span class="keywordflow">break</span>;
00183       <span class="keywordflow">case</span> <span class="charliteral">'k'</span>:
00184         constraint_expr = <span class="keyword">true</span>;
00185         constraint = getopt.optarg;
00186         <span class="keywordflow">break</span>;
00187       <span class="keywordflow">case</span> <span class="charliteral">'f'</span>:
00188         dataset = getopt.optarg;
00189         <span class="keywordflow">break</span>;
00190       <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
00191         verbose = <span class="keyword">true</span>;
00192         <span class="keywordflow">break</span>;
00193       <span class="keywordflow">case</span> <span class="charliteral">'V'</span>:
00194         fprintf( stderr, <span class="stringliteral">"%s: %s\n"</span>, argv[0], <a class="code" href="das-test_8cc.html#a4">version</a>.c_str() ) ;
00195         exit(0);
00196       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>: 
00197       <span class="keywordflow">default</span>:
00198         fprintf( stderr, <span class="stringliteral">"%s\n"</span>, <a class="code" href="error-test_8cc.html#a9">usage</a>.c_str() ) ;
00199         exit(1);
00200         <span class="keywordflow">break</span>;
00201     }
00202 
00203     <span class="keywordflow">if</span> (!scanner_test &amp;&amp; !parser_test &amp;&amp; !evaluate_test &amp;&amp; !whole_enchalada) {
00204     fprintf( stderr, <span class="stringliteral">"%s\n"</span>, <a class="code" href="error-test_8cc.html#a9">usage</a>.c_str() ) ;
00205     exit(1);
00206     }
00207 
00208     <span class="comment">// run selected tests</span>
00209 
00210     <span class="keywordflow">if</span> (scanner_test) {
00211     <span class="keywordflow">if</span> (scan_string)
00212         <a class="code" href="das-test_8cc.html#a9">test_scanner</a>(constraint);
00213     <span class="keywordflow">else</span>
00214         <a class="code" href="das-test_8cc.html#a9">test_scanner</a>(<span class="keyword">true</span>);
00215     exit(0);
00216     }
00217 
00218     <span class="keywordflow">if</span> (parser_test) {
00219     <a class="code" href="dds-test_8cc.html#a5">test_parser</a>(table, dds_file_name, constraint);
00220     }
00221 
00222     <span class="keywordflow">if</span> (evaluate_test) {
00223     <a class="code" href="expr-test_8cc.html#a14">evaluate_dds</a>(table, print_constrained);
00224     }
00225 
00226     <span class="keywordflow">if</span> (whole_enchalada) {
00227     <a class="code" href="expr-test_8cc.html#a16">constrained_trans</a>(dds_file_name, dataset, constraint);
00228     }
00229 
00230 <span class="preprocessor">#ifdef WIN32</span>
00231 <span class="preprocessor"></span>    exit(0); <span class="comment">//  DejaGnu/Cygwin based test suite requires this.</span>
00232     <span class="keywordflow">return</span>;  <span class="comment">//  Visual C++ requests this.</span>
00233 <span class="preprocessor">#endif</span>
00234 <span class="preprocessor"></span>}
00235 
00236 <span class="comment">// Instead of reading the tokens from stdin, read them from a string.</span>
00237 
00238 
00239 <span class="keywordtype">void</span>
<a name="l00240"></a><a class="code" href="expr-test_8cc.html#a10">00240</a> <a class="code" href="das-test_8cc.html#a9">test_scanner</a>(<span class="keyword">const</span> string &amp;str)
00241 {
00242     <a class="code" href="expr-test_8cc.html#a19">exprrestart</a>(0);
00243     <span class="keywordtype">void</span> *buffer = <a class="code" href="expr-test_8cc.html#a22">expr_string</a>(str.c_str());
00244     <a class="code" href="expr-test_8cc.html#a20">expr_switch_to_buffer</a>(buffer);
00245 
00246     <a class="code" href="das-test_8cc.html#a9">test_scanner</a>(<span class="keyword">false</span>);
00247 
00248     <a class="code" href="expr-test_8cc.html#a21">expr_delete_buffer</a>(buffer);
00249 }
00250 
00251 <span class="keywordtype">void</span>
<a name="l00252"></a><a class="code" href="expr-test_8cc.html#a11">00252</a> <a class="code" href="das-test_8cc.html#a9">test_scanner</a>(<span class="keywordtype">bool</span> show_prompt)
00253 {
00254     <span class="keywordflow">if</span> (show_prompt) 
00255     fprintf( stdout, <span class="stringliteral">"%s"</span>, <a class="code" href="das-test_8cc.html#a3">prompt</a>.c_str() ) ; <span class="comment">// first prompt</span>
00256 
00257     <span class="keywordtype">int</span> tok;
00258     <span class="keywordflow">while</span> ((tok = <a class="code" href="expr-test_8cc.html#a17">exprlex</a>())) {
00259     <span class="keywordflow">switch</span> (tok) {
00260       <span class="keywordflow">case</span> SCAN_WORD:
00261         fprintf( stdout, <span class="stringliteral">"WORD: %s\n"</span>, exprlval.id ) ;
00262         <span class="keywordflow">break</span>;
00263       <span class="keywordflow">case</span> SCAN_STR:
00264         fprintf( stdout, <span class="stringliteral">"STR: %s\n"</span>, exprlval.val.v.s-&gt;c_str() ) ;
00265         <span class="keywordflow">break</span>;
00266 <span class="preprocessor">#if 0</span>
00267 <span class="preprocessor"></span>      <span class="keywordflow">case</span> SCAN_INT:
00268         fprintf( stdout, <span class="stringliteral">"INT: %d\n"</span>, exprlval.val.v.i ) ;
00269         <span class="keywordflow">break</span>;
00270       <span class="keywordflow">case</span> SCAN_FLOAT:
00271         fprintf( stdout, <span class="stringliteral">"FLOAT: %f\n"</span>, exprlval.val.v.f ) ;
00272         <span class="keywordflow">break</span>;
00273 <span class="preprocessor">#endif</span>
00274 <span class="preprocessor"></span>      <span class="keywordflow">case</span> SCAN_EQUAL:
00275         fprintf( stdout, <span class="stringliteral">"EQUAL: %d\n"</span>, exprlval.op ) ;
00276         <span class="keywordflow">break</span>;
00277       <span class="keywordflow">case</span> SCAN_NOT_EQUAL:
00278         fprintf( stdout, <span class="stringliteral">"NOT_EQUAL: %d\n"</span>, exprlval.op ) ;
00279         <span class="keywordflow">break</span>;
00280       <span class="keywordflow">case</span> SCAN_GREATER:
00281         fprintf( stdout, <span class="stringliteral">"GREATER: %d\n"</span>, exprlval.op ) ;
00282         <span class="keywordflow">break</span>;
00283       <span class="keywordflow">case</span> SCAN_GREATER_EQL:
00284         fprintf( stdout, <span class="stringliteral">"GREATER_EQL: %d\n"</span>, exprlval.op ) ;
00285         <span class="keywordflow">break</span>;
00286       <span class="keywordflow">case</span> SCAN_LESS:
00287         fprintf( stdout, <span class="stringliteral">"LESS: %d\n"</span>, exprlval.op ) ;
00288         <span class="keywordflow">break</span>;
00289       <span class="keywordflow">case</span> SCAN_LESS_EQL:
00290         fprintf( stdout, <span class="stringliteral">"LESS_EQL: %d\n"</span>, exprlval.op ) ;
00291         <span class="keywordflow">break</span>;
00292       <span class="keywordflow">case</span> SCAN_REGEXP:
00293         fprintf( stdout, <span class="stringliteral">"REGEXP: %d\n"</span>, exprlval.op ) ;
00294         <span class="keywordflow">break</span>;
00295       <span class="keywordflow">case</span> <span class="charliteral">'*'</span>:
00296         fprintf( stdout, <span class="stringliteral">"Dereference\n"</span> ) ;
00297         <span class="keywordflow">break</span>;
00298       <span class="keywordflow">case</span> <span class="charliteral">'.'</span>:
00299         fprintf( stdout, <span class="stringliteral">"Field Selector\n"</span> ) ;
00300         <span class="keywordflow">break</span>;
00301       <span class="keywordflow">case</span> <span class="charliteral">','</span>:
00302         fprintf( stdout, <span class="stringliteral">"List Element Separator\n"</span> ) ;
00303         <span class="keywordflow">break</span>;
00304       <span class="keywordflow">case</span> <span class="charliteral">'['</span>:
00305         fprintf( stdout, <span class="stringliteral">"Left Bracket\n"</span> ) ;
00306         <span class="keywordflow">break</span>;
00307       <span class="keywordflow">case</span> <span class="charliteral">']'</span>:
00308         fprintf( stdout, <span class="stringliteral">"Right Bracket\n"</span> ) ;
00309         <span class="keywordflow">break</span>;
00310       <span class="keywordflow">case</span> <span class="charliteral">'('</span>:
00311         fprintf( stdout, <span class="stringliteral">"Left Paren\n"</span> ) ;
00312         <span class="keywordflow">break</span>;
00313       <span class="keywordflow">case</span> <span class="charliteral">')'</span>:
00314         fprintf( stdout, <span class="stringliteral">"Right Paren\n"</span> ) ;
00315         <span class="keywordflow">break</span>;
00316       <span class="keywordflow">case</span> <span class="charliteral">'{'</span>:
00317         fprintf( stdout, <span class="stringliteral">"Left Brace\n"</span> ) ;
00318         <span class="keywordflow">break</span>;
00319       <span class="keywordflow">case</span> <span class="charliteral">'}'</span>:
00320         fprintf( stdout, <span class="stringliteral">"Right Brace\n"</span> ) ;
00321         <span class="keywordflow">break</span>;
00322       <span class="keywordflow">case</span> <span class="charliteral">':'</span>:
00323         fprintf( stdout, <span class="stringliteral">"Colon\n"</span> ) ;
00324         <span class="keywordflow">break</span>;
00325       <span class="keywordflow">case</span> <span class="charliteral">'&amp;'</span>:
00326         fprintf( stdout, <span class="stringliteral">"Ampersand\n"</span> ) ;
00327         <span class="keywordflow">break</span>;
00328       <span class="keywordflow">default</span>:
00329         fprintf( stdout, <span class="stringliteral">"Error: Unrecognized input\n"</span> ) ;
00330     }
00331     fprintf( stdout, <span class="stringliteral">"%s"</span>, <a class="code" href="das-test_8cc.html#a3">prompt</a>.c_str() ) ; <span class="comment">// print prompt after output</span>
00332     fflush( stdout ) ;
00333     }
00334 }
00335 
00336 <span class="comment">// NB: The DDS is read in via a file because reading from stdin must be</span>
00337 <span class="comment">// terminated by EOF. However, the EOF used to terminate the DDS also closes</span>
00338 <span class="comment">// stdin and thus the expr scanner exits immediately.</span>
00339 
00340 <span class="keywordtype">void</span>
<a name="l00341"></a><a class="code" href="expr-test_8cc.html#a12">00341</a> <a class="code" href="dds-test_8cc.html#a5">test_parser</a>(<a class="code" href="classDDS.html">DDS</a> &amp;table, <span class="keyword">const</span> string &amp;dds_name, <span class="keyword">const</span> string &amp;constraint)
00342 {
00343     <span class="keywordflow">try</span> {
00344     <a class="code" href="expr-test_8cc.html#a13">read_table</a>(table, dds_name, <span class="keyword">true</span>);
00345 
00346     <span class="keywordflow">if</span> (constraint != <span class="stringliteral">""</span>) {
00347         table.<a class="code" href="classDDS.html#DDSa36">parse_constraint</a>(constraint);
00348     }
00349     <span class="keywordflow">else</span> {
00350         <a class="code" href="expr-test_8cc.html#a19">exprrestart</a>(stdin);
00351         fprintf( stdout, <span class="stringliteral">"%s"</span>, <a class="code" href="das-test_8cc.html#a3">prompt</a>.c_str() ) ;
00352         <a class="code" href="structparser__arg.html">parser_arg</a> arg(&amp;table);
00353         <a class="code" href="expr-test_8cc.html#a18">exprparse</a>((<span class="keywordtype">void</span> *)&amp;arg);
00354     }
00355 
00356     fprintf( stdout, <span class="stringliteral">"Input parsed\n"</span> ) ;   <span class="comment">// Parser throws on failure.</span>
00357     }
00358     <span class="keywordflow">catch</span> (<a class="code" href="classError.html">Error</a> &amp;e) {
00359     e.display_message();
00360     }
00361 }
00362 
00363 <span class="comment">// Read a DDS from stdin and build the cooresponding DDS. IF PRINT is true,</span>
00364 <span class="comment">// print the text reprsentation of that DDS on the stdout. The DDS TABLE is</span>
00365 <span class="comment">// modified as a side effect.</span>
00366 <span class="comment">//</span>
00367 <span class="comment">// Returns: true iff that DDS pasted the semantic_check() mfunc, otherwise</span>
00368 <span class="comment">// false.</span>
00369 
00370 <span class="keywordtype">bool</span>
<a name="l00371"></a><a class="code" href="expr-test_8cc.html#a13">00371</a> <a class="code" href="expr-test_8cc.html#a13">read_table</a>(<a class="code" href="classDDS.html">DDS</a> &amp;table, <span class="keyword">const</span> string &amp;name, <span class="keywordtype">bool</span> print)
00372 {
00373     table.<a class="code" href="classDDS.html#DDSa40">parse</a>(name);
00374     
00375     <span class="keywordflow">if</span> (print)
00376     table.<a class="code" href="classDDS.html#DDSa43">print</a>( stdout );
00377 
00378     <span class="keywordflow">if</span> (table.<a class="code" href="classDDS.html#DDSa50">check_semantics</a>(<span class="keyword">true</span>))
00379     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00380     <span class="keywordflow">else</span> {
00381     fprintf( stdout, <span class="stringliteral">"Input did not pass semantic checks\n"</span> ) ;
00382     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00383     }
00384 }
00385 
00386 <span class="keywordtype">void</span>
<a name="l00387"></a><a class="code" href="expr-test_8cc.html#a14">00387</a> <a class="code" href="expr-test_8cc.html#a14">evaluate_dds</a>(<a class="code" href="classDDS.html">DDS</a> &amp;table, <span class="keywordtype">bool</span> print_constrained)
00388 {
00389     <span class="keywordflow">if</span> (print_constrained)
00390     table.<a class="code" href="classDDS.html#DDSa45">print_constrained</a>( stdout );
00391     <span class="keywordflow">else</span>
00392     <span class="keywordflow">for</span> (<a class="code" href="classDDS.html#DDSw1">DDS::Vars_iter</a> p = table.<a class="code" href="classDDS.html#DDSa13">var_begin</a>(); p != table.<a class="code" href="classDDS.html#DDSa14">var_end</a>(); p++)
00393         (*p)-&gt;print_decl(stdout, <span class="stringliteral">""</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);
00394 }
00395 
00396 <span class="comment">// create a pipe for the caller's process which can be used by the DODS</span>
00397 <span class="comment">// software to write to and read from itself.</span>
00398 
00399 <span class="keywordtype">bool</span>
<a name="l00400"></a><a class="code" href="expr-test_8cc.html#a15">00400</a> <a class="code" href="expr-test_8cc.html#a15">loopback_pipe</a>(FILE **pout, FILE **pin)
00401 {
00402 <span class="preprocessor">#ifdef WIN32</span>
00403 <span class="preprocessor"></span>    <span class="keywordtype">int</span> fd[2];
00404     <span class="keywordflow">if</span> (_pipe(fd, 1024, _O_BINARY) &lt; 0) {
00405     fprintf( stderr, <span class="stringliteral">"Could not open pipe\n"</span> ) ;
00406     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00407     }
00408 
00409     *pout = fdopen(fd[1], <span class="stringliteral">"w+b"</span>);
00410     *pin = fdopen(fd[0], <span class="stringliteral">"r+b"</span>);
00411 <span class="preprocessor">#else</span>
00412 <span class="preprocessor"></span>    <span class="keywordtype">int</span> fd[2];
00413     <span class="keywordflow">if</span> (pipe(fd) &lt; 0) {
00414     fprintf( stderr, <span class="stringliteral">"Could not open pipe\n"</span> ) ;
00415     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00416     }
00417 
00418     *pout = fdopen(fd[1], <span class="stringliteral">"w"</span>);
00419     *pin = fdopen(fd[0], <span class="stringliteral">"r"</span>);
00420 <span class="preprocessor">#endif</span>
00421 <span class="preprocessor"></span>
00422     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00423 }
00424 
00425 
00426 <span class="comment">// Originally in netexec.c (part of the netio library).</span>
00427 <span class="comment">// Read the DDS from the data stream. Leave the binary information behind. The</span>
00428 <span class="comment">// DDS is moved, without parsing it, into a file and a pointer to that FILE is</span>
00429 <span class="comment">// returned. The argument IN (the input FILE stream) is positioned so that the</span>
00430 <span class="comment">// next byte is the binary data.</span>
00431 <span class="comment">//</span>
00432 <span class="comment">// The binary data follows the text `Data:', which itself starts a line.</span>
00433 <span class="comment">//</span>
00434 <span class="comment">// Returns: a FILE * which contains the DDS describing the binary information</span>
00435 <span class="comment">// in IF.</span>
00436 
00437 FILE *
<a name="l00438"></a><a class="code" href="expr-test_8cc.html#a24">00438</a> <a class="code" href="expr-test_8cc.html#a24">move_dds</a>(FILE *in)
00439 {
00440     <span class="keywordtype">char</span> *c = tempnam(NULL, <span class="stringliteral">"dods"</span>);
00441     <span class="keywordflow">if</span> (!c) {
00442     fprintf( stderr, <span class="stringliteral">"Could not create temporary file name %s\n"</span>,
00443              strerror(errno) ) ;
00444     <span class="keywordflow">return</span> NULL;
00445     }
00446 
00447     FILE *fp = fopen(c, <span class="stringliteral">"w+b"</span>);
00448     <span class="keywordflow">if</span> (!keep_temps)
00449     unlink(c);
00450     <span class="keywordflow">if</span> (!fp) {
00451     fprintf( stderr, <span class="stringliteral">"Could not open anonymous temporary file: %s\n"</span>,
00452              strerror(errno) ) ;
00453     <span class="keywordflow">return</span> NULL;
00454     }
00455         
00456     <span class="keywordtype">int</span> data = <a class="code" href="parser_8h.html#a4">FALSE</a>;
00457     <span class="keywordtype">char</span> s[256], *sp;
00458     
00459     sp = &amp;s[0];
00460     <span class="keywordflow">while</span> (!feof(in) &amp;&amp; !data) {
00461     sp = fgets(s, 255, in);
00462     <span class="keywordflow">if</span> (strcmp(s, <span class="stringliteral">"Data:\n"</span>) == 0)
00463         data = <a class="code" href="parser_8h.html#a3">TRUE</a>;
00464     <span class="keywordflow">else</span>
00465         fputs(s, fp);
00466     }
00467 
00468     fflush(fp);
00469     <span class="keywordflow">if</span> (fseek(fp, 0L, 0) &lt; 0) {
00470     fprintf( stderr, <span class="stringliteral">"Could not rewind data DDS stream: %s\n"</span>,
00471          strerror(errno) ) ;
00472     <span class="keywordflow">return</span> NULL;
00473     }
00474     
00475     free(c);            <span class="comment">// tempnam uses malloc</span>
00476     <span class="keywordflow">return</span> fp;
00477 }
00478 
00479 <span class="comment">// Gobble up the mime header. At one time the MIME Headers were output from</span>
00480 <span class="comment">// the server filter programs (not the core software) so we could call</span>
00481 <span class="comment">// DDS::send() from this test code and not have to parse the MIME header. But</span>
00482 <span class="comment">// in order to get errors to work more reliably the header generation was</span>
00483 <span class="comment">// moved `closer to the send'. That is, we put off determining whether to</span>
00484 <span class="comment">// send a DDS or an Error object until later. That trade off is that the</span>
00485 <span class="comment">// header generation is not buried in the core software. This code simply</span>
00486 <span class="comment">// reads until the end of the header is found. 3/25/98 jhrg</span>
00487 
00488 <span class="keywordtype">void</span>
<a name="l00489"></a><a class="code" href="expr-test_8cc.html#a25">00489</a> <a class="code" href="expr-test_8cc.html#a25">parse_mime</a>(FILE *data_source)
00490 {
00491     <span class="keywordtype">char</span> line[256];
00492 
00493     fgets(line, 256, data_source);
00494     
00495     <span class="keywordflow">while</span> (line[0] != <span class="charliteral">'\n'</span>)
00496     fgets(line, 256, data_source);
00497 }
00498 
00499 <span class="comment">// Test the transmission of constrained datasets. Use read_table() to read</span>
00500 <span class="comment">// the DDS from a file. Once done, prompt for the variable name and</span>
00501 <span class="comment">// constraint expression. In a real client-server system the server would</span>
00502 <span class="comment">// read the DDS for the entire dataset and send it to the client. The client</span>
00503 <span class="comment">// would then respond to the server by asking for a variable given a</span>
00504 <span class="comment">// constraint.</span>
00505 <span class="comment">// </span>
00506 <span class="comment">// Once the constraint has been entered, it is evaluated in the context of</span>
00507 <span class="comment">// the DDS using DDS:eval_constraint() (this would happen on the server-side</span>
00508 <span class="comment">// in a real system). Once the evaluation is complete,</span>
00509 <span class="comment">// DDS::print_constrained() is used to create a DDS describing only those</span>
00510 <span class="comment">// parts of the dataset that are to be sent to the client process and written</span>
00511 <span class="comment">// to the output stream. After that, the marker `Data:' is written to the</span>
00512 <span class="comment">// output stream, followed by the binary data.</span>
00513 
00514 <span class="keywordtype">bool</span>
<a name="l00515"></a><a class="code" href="expr-test_8cc.html#a16">00515</a> <a class="code" href="expr-test_8cc.html#a16">constrained_trans</a>(<span class="keyword">const</span> string &amp;dds_name, string dataset, 
00516           <span class="keyword">const</span> string &amp;constraint) 
00517 {
00518     <span class="keywordtype">bool</span> status;
00519     FILE *pin, *pout;
00520     <a class="code" href="classDDS.html">DDS</a> server;         <span class="comment">// could use DataDDS, but no need when</span>
00521                 <span class="comment">// sending. </span>
00522 
00523     fprintf( stdout, <span class="stringliteral">"The complete DDS:\n"</span> ) ;
00524     <a class="code" href="expr-test_8cc.html#a13">read_table</a>(server, dds_name, <span class="keyword">true</span>);
00525 
00526     status = <a class="code" href="expr-test_8cc.html#a15">loopback_pipe</a>(&amp;pout, &amp;pin);
00527     <span class="keywordflow">if</span> (!status) {
00528     fprintf( stderr, <span class="stringliteral">"Could not create the loopback streams\n"</span> ) ;
00529     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00530     }
00531 
00532     <span class="comment">// If the CE was not passed in, read it from the command line.</span>
00533     string ce;
00534     <span class="keywordflow">if</span> (constraint == <span class="stringliteral">""</span>) {
00535     fprintf( stdout, <span class="stringliteral">"Constraint:"</span> ) ;
00536     <span class="keywordtype">char</span> c[256];
00537     cin.getline(c, 256);
00538     <span class="keywordflow">if</span> (!cin) {
00539         fprintf( stderr, <span class="stringliteral">"Could nore read the constraint expression\n"</span> ) ;
00540         exit(1);
00541     }
00542     ce = c;
00543     }
00544     <span class="keywordflow">else</span>
00545     ce = constraint;
00546 
00547     <span class="keywordflow">if</span> (dataset == <span class="stringliteral">""</span>) {
00548     fprintf( stdout, <span class="stringliteral">"Data file:"</span> ) ;
00549     <span class="keywordtype">char</span> c[256];
00550     cin.getline(c, 255);
00551     <span class="keywordflow">if</span> (!cin) {
00552         fprintf( stderr, <span class="stringliteral">"Could nore read the data file name\n"</span> ) ;
00553         exit(1);
00554     }
00555     dataset = c;
00556     }
00557 
00558     <span class="keywordflow">try</span> {
00559     <span class="comment">// send the variable given the constraint; TRUE flushes the I/O</span>
00560     <span class="comment">// channel. Currently only Sequence uses the `dataset' parameter.</span>
00561     <span class="comment">//</span>
00562     <span class="comment">// We're at that awkward stage between two different error processing</span>
00563     <span class="comment">// techniques. 4/6/2000 jhrg</span>
00564     <span class="keywordflow">if</span> (!server.<a class="code" href="classDDS.html#DDSa47">send</a>(dataset, ce, pout, <span class="keyword">false</span>)) {
00565         fprintf( stderr, <span class="stringliteral">"Could not send the DDS\n"</span> ) ;
00566         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00567     }
00568     }
00569     <span class="keywordflow">catch</span>(<a class="code" href="classError.html">Error</a> &amp;e) {
00570     e.display_message();
00571     fclose(pout);
00572     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00573     }
00574 
00575     fclose(pout);       <span class="comment">// close pout to read from pin. Why?</span>
00576     
00577     <span class="comment">// Now do what Connect::request_data() does:</span>
00578 
00579     <span class="comment">// First read the DDS into a new object (using a file to store the DDS</span>
00580     <span class="comment">// temporarily - the parser/scanner won't stop reading until an EOF is</span>
00581     <span class="comment">// found, this fixes that problem).</span>
00582 
00583     <span class="keywordflow">try</span> {
00584     <a class="code" href="classDataDDS.html">DataDDS</a> dds(<span class="stringliteral">"Test_data"</span>, <span class="stringliteral">"DODS/3.2"</span>); <span class="comment">// Must use DataDDS on receving end</span>
00585     FILE *dds_fp = <a class="code" href="expr-test_8cc.html#a24">move_dds</a>(pin);
00586     <a class="code" href="debug_8h.html#a1">DBG</a>( fprintf( stderr, <span class="stringliteral">"Moved the DDS to a temp file\n"</span> ) ) ;
00587     <a class="code" href="expr-test_8cc.html#a25">parse_mime</a>(dds_fp);
00588     dds.<a class="code" href="classDDS.html#DDSa40">parse</a>(dds_fp);
00589     fclose(dds_fp);
00590 
00591     XDR *source = <a class="code" href="util_8cc.html#a4">new_xdrstdio</a>(pin, XDR_DECODE);
00592 
00593     <span class="comment">// Back on the client side; deserialize the data *using the newly</span>
00594     <span class="comment">// generated DDS* (the one sent with the data).</span>
00595 
00596     fprintf( stdout, <span class="stringliteral">"The data:\n"</span> ) ;
00597     <span class="keywordflow">for</span> (<a class="code" href="classDDS.html#DDSw1">DDS::Vars_iter</a> q = dds.<a class="code" href="classDDS.html#DDSa13">var_begin</a>(); q != dds.<a class="code" href="classDDS.html#DDSa14">var_end</a>(); q++)
00598     {
00599         (*q)-&gt;deserialize(source, &amp;dds);
00600         (*q)-&gt;print_val(stdout);
00601     }
00602 
00603     <a class="code" href="util_8cc.html#a6">delete_xdrstdio</a>(source);
00604     }
00605     <span class="keywordflow">catch</span> (<a class="code" href="classError.html">Error</a> &amp;e) {
00606     e.display_message();
00607     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00608     }
00609     
00610     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00611 }
00612 
00613 <span class="comment">// $Log: expr-test_8cc-source.html,v $
00613 <span class="comment">// Revision 1.4  2004/02/05 06:51:20  jimg
00613 <span class="comment">// Added/update.
00613 <span class="comment">//</span>
00614 <span class="comment">// Revision 1.36.2.1  2003/07/24 00:45:06  jimg</span>
00615 <span class="comment">// Added test_variable_sleep_interval. This is used to test timeouts by</span>
00616 <span class="comment">// simulating very long read times.</span>
00617 <span class="comment">//</span>
00618 <span class="comment">// Revision 1.36  2003/04/22 19:40:28  jimg</span>
00619 <span class="comment">// Merged with 3.3.1.</span>
00620 <span class="comment">//</span>
00621 <span class="comment">// Revision 1.35  2003/02/21 00:14:25  jimg</span>
00622 <span class="comment">// Repaired copyright.</span>
00623 <span class="comment">//</span>
00624 <span class="comment">// Revision 1.34.2.1  2003/02/21 00:10:08  jimg</span>
00625 <span class="comment">// Repaired copyright.</span>
00626 <span class="comment">//</span>
00627 <span class="comment">// Revision 1.34  2003/01/23 00:22:24  jimg</span>
00628 <span class="comment">// Updated the copyright notice; this implementation of the DAP is</span>
00629 <span class="comment">// copyrighted by OPeNDAP, Inc.</span>
00630 <span class="comment">//</span>
00631 <span class="comment">// Revision 1.33  2003/01/10 19:46:41  jimg</span>
00632 <span class="comment">// Merged with code tagged release-3-2-10 on the release-3-2 branch. In many</span>
00633 <span class="comment">// cases files were added on that branch (so they appear on the trunk for</span>
00634 <span class="comment">// the first time).</span>
00635 <span class="comment">//</span>
00636 <span class="comment">// Revision 1.29.4.10  2002/12/17 22:35:03  pwest</span>
00637 <span class="comment">// Added and updated methods using stdio. Deprecated methods using iostream.</span>
00638 <span class="comment">//</span>
00639 <span class="comment">// Revision 1.29.4.9  2002/11/06 21:53:06  jimg</span>
00640 <span class="comment">// I changed the includes of Regex.h from &lt;Regex.h&gt; to "Regex.h". This means</span>
00641 <span class="comment">// make depend will include the header in the list of dependencies.</span>
00642 <span class="comment">//</span>
00643 <span class="comment">// Revision 1.29.4.8  2002/10/28 21:17:44  pwest</span>
00644 <span class="comment">// Converted all return values and method parameters to use non-const iterator.</span>
00645 <span class="comment">// Added operator== and operator!= methods to IteratorAdapter to handle Pix</span>
00646 <span class="comment">// problems.</span>
00647 <span class="comment">//</span>
00648 <span class="comment">// Revision 1.29.4.7  2002/09/05 22:52:55  pwest</span>
00649 <span class="comment">// Replaced the GNU data structures SLList and DLList with the STL container</span>
00650 <span class="comment">// class vector&lt;&gt;. To maintain use of Pix, changed the Pix.h header file to</span>
00651 <span class="comment">// redefine Pix to be an IteratorAdapter. Usage remains the same and all code</span>
00652 <span class="comment">// outside of the DAP should compile and link with no problems. Added methods</span>
00653 <span class="comment">// to the different classes where Pix is used to include methods to use STL</span>
00654 <span class="comment">// iterators. Replaced the use of Pix within the DAP to use iterators instead.</span>
00655 <span class="comment">// Updated comments for documentation, updated the test suites, and added some</span>
00656 <span class="comment">// unit tests. Updated the Makefile to remove GNU/SLList and GNU/DLList.</span>
00657 <span class="comment">//</span>
00658 <span class="comment">// Revision 1.29.4.6  2002/08/08 06:54:57  jimg</span>
00659 <span class="comment">// Changes for thread-safety. In many cases I found ugly places at the</span>
00660 <span class="comment">// tops of files while looking for globals, et c., and I fixed them up</span>
00661 <span class="comment">// (hopefully making them easier to read, ...). Only the files RCReader.cc</span>
00662 <span class="comment">// and usage.cc actually use pthreads synchronization functions. In other</span>
00663 <span class="comment">// cases I removed static objects where they were used for supposed</span>
00664 <span class="comment">// improvements in efficiency which had never actually been verifiied (and</span>
00665 <span class="comment">// which looked dubious).</span>
00666 <span class="comment">//</span>
00667 <span class="comment">// Revision 1.32  2002/06/03 22:21:16  jimg</span>
00668 <span class="comment">// Merged with release-3-2-9</span>
00669 <span class="comment">//</span>
00670 <span class="comment">// Revision 1.29.4.5  2002/02/20 19:16:27  jimg</span>
00671 <span class="comment">// Changed the expression parser so that variable names may contain only</span>
00672 <span class="comment">// digits.</span>
00673 <span class="comment">//</span>
00674 <span class="comment">// Revision 1.29.4.4  2001/11/01 00:43:51  jimg</span>
00675 <span class="comment">// Fixes to the scanners and parsers so that dataset variable names may</span>
00676 <span class="comment">// start with digits. I've expanded the set of characters that may appear</span>
00677 <span class="comment">// in a variable name and made it so that all except `#' may appear at</span>
00678 <span class="comment">// the start. Some characters are not allowed in variables that appear in</span>
00679 <span class="comment">// a DDS or CE while they are allowed in the DAS. This makes it possible</span>
00680 <span class="comment">// to define containers with names like `COARDS:long_name.' Putting a colon</span>
00681 <span class="comment">// in a variable name makes the CE parser much more complex. Since the set</span>
00682 <span class="comment">// of characters that people want seems pretty limited (compared to the</span>
00683 <span class="comment">// complete ASCII set) I think this is an OK approach. If we have to open</span>
00684 <span class="comment">// up the expr.lex scanner completely, then we can but not without adding</span>
00685 <span class="comment">// lots of action clauses to teh parser. Note that colon is just an example,</span>
00686 <span class="comment">// there's a host of characters that are used in CEs that are not allowed</span>
00687 <span class="comment">// in IDs.</span>
00688 <span class="comment">//</span>
00689 <span class="comment">// Revision 1.31  2001/09/28 17:50:07  jimg</span>
00690 <span class="comment">// Merged with 3.2.7.</span>
00691 <span class="comment">//</span>
00692 <span class="comment">// Revision 1.29.4.3  2001/09/07 00:38:35  jimg</span>
00693 <span class="comment">// Sequence::deserialize(...) now reads all the sequence values at once.</span>
00694 <span class="comment">// Its call semantics are the same as the other classes' versions. Values</span>
00695 <span class="comment">// are stored in the Sequence object using a vector&lt;BaseType *&gt; for each</span>
00696 <span class="comment">// row (those are themselves held in a vector). Three new accessor methods</span>
00697 <span class="comment">// have been added to Sequence (row_value() and two versions of var_value()).</span>
00698 <span class="comment">// BaseType::deserialize(...) now always returns true. This matches with the</span>
00699 <span class="comment">// expectations of most client code (the seqeunce version returned false</span>
00700 <span class="comment">// when it was done reading, but all the calls for sequences must be changed</span>
00701 <span class="comment">// anyway). If an XDR error is found, deserialize throws InternalErr.</span>
00702 <span class="comment">//</span>
00703 <span class="comment">// Revision 1.30  2001/08/24 17:46:22  jimg</span>
00704 <span class="comment">// Resolved conflicts from the merge of release 3.2.6</span>
00705 <span class="comment">//</span>
00706 <span class="comment">// Revision 1.29.4.2  2001/08/18 00:02:57  jimg</span>
00707 <span class="comment">// Removed WIN32 compile guards from using statements.</span>
00708 <span class="comment">//</span>
00709 <span class="comment">// Revision 1.29.4.1  2001/06/23 00:52:08  jimg</span>
00710 <span class="comment">// Normalized the definitions of ID (SCAN_ID), INT, FLOAT and NEVER so</span>
00711 <span class="comment">// that they are (more or less) the same in all the scanners. There are</span>
00712 <span class="comment">// one or two characters that differ (for example das.lex allows ( and )</span>
00713 <span class="comment">// in an ID while dds.lex, expr.lex and gse.lex don't) but the definitions</span>
00714 <span class="comment">// are essentially the same across the board.</span>
00715 <span class="comment">// Added `#' to the set of characeters allowed in an ID (bug 179).</span>
00716 <span class="comment">//</span>
00717 <span class="comment">// Revision 1.29  2000/09/22 02:17:22  jimg</span>
00718 <span class="comment">// Rearranged source files so that the CVS logs appear at the end rather than</span>
00719 <span class="comment">// the start. Also made the ifdef guard symbols use the same naming scheme and</span>
00720 <span class="comment">// wrapped headers included in other headers in those guard symbols (to cut</span>
00721 <span class="comment">// down on extraneous file processing - See Lakos).</span>
00722 <span class="comment">//</span>
00723 <span class="comment">// Revision 1.28  2000/09/21 16:22:10  jimg</span>
00724 <span class="comment">// Merged changes from Jose Garcia that add exceptions to the software.</span>
00725 <span class="comment">// Many methods that returned error codes now throw exectptions. There are</span>
00726 <span class="comment">// two classes which are thrown by the software, Error and InternalErr.</span>
00727 <span class="comment">// InternalErr is used to report errors within the library or errors using</span>
00728 <span class="comment">// the library. Error is used to reprot all other errors. Since InternalErr</span>
00729 <span class="comment">// is a subclass of Error, programs need only to catch Error.</span>
00730 <span class="comment">//</span>
00731 <span class="comment">// Revision 1.27  2000/07/19 22:51:40  rmorris</span>
00732 <span class="comment">// Call and return from main in a manner Visual C++ likes and</span>
00733 <span class="comment">// exit the program with exit(0) so that DejaGnu/Cygwin based</span>
00734 <span class="comment">// testsuite can succeed for win32.</span>
00735 <span class="comment">//</span>
00736 <span class="comment">// Revision 1.26  2000/07/09 22:05:36  rmorris</span>
00737 <span class="comment">// Changes to increase portability, minimize ifdef's for win32 and account</span>
00738 <span class="comment">// for differences in the iostreams implementations.</span>
00739 <span class="comment">//</span>
00740 <span class="comment">// Revision 1.24  2000/06/07 18:07:00  jimg</span>
00741 <span class="comment">// Merged the pc port branch</span>
00742 <span class="comment">//</span>
00743 <span class="comment">// Revision 1.23.4.1  2000/06/02 18:36:38  rmorris</span>
00744 <span class="comment">// Mod's for port to Win32.</span>
00745 <span class="comment">//</span>
00746 <span class="comment">// Revision 1.23  2000/04/07 00:19:29  jimg</span>
00747 <span class="comment">// Added exception handling</span>
00748 <span class="comment">//</span>
00749 <span class="comment">// Revision 1.22.14.1  2000/02/17 05:03:17  jimg</span>
00750 <span class="comment">// Added file and line number information to calls to InternalErr.</span>
00751 <span class="comment">// Resolved compile-time problems with read due to a change in its</span>
00752 <span class="comment">// parameter list given that errors are now reported using exceptions.</span>
00753 <span class="comment">//</span>
00754 <span class="comment">// Revision 1.22  1999/05/04 19:47:24  jimg</span>
00755 <span class="comment">// Fixed copyright statements. Removed more of the GNU classes.</span>
00756 <span class="comment">//</span>
00757 <span class="comment">// Revision 1.21  1999/04/29 02:29:36  jimg</span>
00758 <span class="comment">// Merge of no-gnu branch</span>
00759 <span class="comment">//</span>
00760 <span class="comment">// Revision 1.20  1999/03/24 23:32:05  jimg</span>
00761 <span class="comment">// Added a verbose mode.</span>
00762 <span class="comment">// Commented out the old transmit(...) function. Use constrained_trans(...)</span>
00763 <span class="comment">// instead.</span>
00764 <span class="comment">//</span>
00765 <span class="comment">// Revision 1.19  1999/01/21 02:50:08  jimg</span>
00766 <span class="comment">// Added code to test the expr scanner using strings and not files.</span>
00767 <span class="comment">//</span>
00768 <span class="comment">// Revision 1.18  1998/11/10 00:49:19  jimg</span>
00769 <span class="comment">// Fixed up the online help.</span>
00770 <span class="comment">//</span>
00771 <span class="comment">// Revision 1.17  1998/09/17 17:00:02  jimg</span>
00772 <span class="comment">// Added include files to get rid of compiler messages about missing</span>
00773 <span class="comment">// prototypes.</span>
00774 <span class="comment">//</span>
00775 <span class="comment">// Revision 1.16.6.2  1999/02/05 09:32:36  jimg</span>
00776 <span class="comment">// Fixed __unused__ so that it not longer clashes with Red Hat 5.2 inlined</span>
00777 <span class="comment">// math code. </span>
00778 <span class="comment">//</span>
00779 <span class="comment">// Revision 1.16.6.1  1999/02/02 21:57:07  jimg</span>
00780 <span class="comment">// String to string version</span>
00781 <span class="comment">//</span>
00782 <span class="comment">// Revision 1.16  1998/03/26 00:15:53  jimg</span>
00783 <span class="comment">// Added keep_temps global for use with debuggers to keep those temp file</span>
00784 <span class="comment">// around.</span>
00785 <span class="comment">// Added parse_mime() to gobble up the mime header generated by DDS::send()</span>
00786 <span class="comment">//</span>
00787 <span class="comment">// Revision 1.15  1998/03/19 23:29:20  jimg</span>
00788 <span class="comment">// Removed old code (that was surrounded by #if 0 ... #endif).</span>
00789 <span class="comment">//</span>
00790 <span class="comment">// Revision 1.14  1997/09/22 22:33:14  jimg</span>
00791 <span class="comment">// Added data file option. Now -f can be used to specify the name of a file</span>
00792 <span class="comment">// from which to read data. This currently only works with Sequences, but</span>
00793 <span class="comment">// in the future all test data could be read from a file.</span>
00794 <span class="comment">// Added use of the DataDDS class (which is required by the new core</span>
00795 <span class="comment">// software).</span>
00796 <span class="comment">//</span>
00797 <span class="comment">// Revision 1.13  1997/06/05 22:51:25  jimg</span>
00798 <span class="comment">// Changed so that compression is not used.</span>
00799 <span class="comment">//</span>
00800 <span class="comment">// Revision 1.12  1996/08/13 18:55:20  jimg</span>
00801 <span class="comment">// Added not_used to definition of char rcsid[].</span>
00802 <span class="comment">// Uses the parser_arg object to communicate with the parser.</span>
00803 <span class="comment">//</span>
00804 <span class="comment">// Revision 1.11  1996/06/11 17:30:36  jimg</span>
00805 <span class="comment">// Fixed -k (constraint expression) option when used with -p (parser) option.</span>
00806 <span class="comment">//</span>
00807 <span class="comment">// Revision 1.10  1996/06/04 21:34:00  jimg</span>
00808 <span class="comment">// Multiple connections are now possible. It is now possible to open several</span>
00809 <span class="comment">// URLs at the same time and read from them in a round-robin fashion. To do</span>
00810 <span class="comment">// this I added data source and sink parameters to the serialize and</span>
00811 <span class="comment">// deserialize mfuncs. Connect was also modified so that it manages the data</span>
00812 <span class="comment">// source `object' (which is just an XDR pointer).</span>
00813 <span class="comment">//</span>
00814 <span class="comment">// Revision 1.9  1996/05/31 23:30:58  jimg</span>
00815 <span class="comment">// Updated copyright notice.</span>
00816 <span class="comment">//</span>
00817 <span class="comment">// Revision 1.8  1996/05/29 22:04:13  jimg</span>
00818 <span class="comment">// Removed old, useless, code.</span>
00819 <span class="comment">//</span>
00820 <span class="comment">// Revision 1.7  1996/05/22 18:05:35  jimg</span>
00821 <span class="comment">// Merged files from the old netio directory into the dap directory.</span>
00822 <span class="comment">// Removed the errmsg library from the software.</span>
00823 <span class="comment">//</span>
00824 <span class="comment">// Revision 1.6  1996/05/14 15:38:57  jimg</span>
00825 <span class="comment">// These changes have already been checked in once before. However, I</span>
00826 <span class="comment">// corrupted the source repository and restored it from a 5/9/96 backup</span>
00827 <span class="comment">// tape. The previous version's log entry should cover the changes.</span>
00828 <span class="comment">//</span>
00829 <span class="comment">// Revision 1.5  1996/03/05 00:57:19  jimg</span>
00830 <span class="comment">// Fixed tests of constrained tranmission so CEs with spaces will be read</span>
00831 <span class="comment">// properly.</span>
00832 <span class="comment">// Added new option so that a CE may be given on the command line.</span>
00833 <span class="comment">//</span>
00834 <span class="comment">// Revision 1.4  1995/12/09  01:07:37  jimg</span>
00835 <span class="comment">// Added changes so that relational operators will work properly for all the</span>
00836 <span class="comment">// datatypes (including Sequences). The relational ops are evaluated in</span>
00837 <span class="comment">// DDS::eval_constraint() after being parsed by DDS::parse_constraint().</span>
00838 <span class="comment">//</span>
00839 <span class="comment">// Revision 1.3  1995/12/06  19:43:09  jimg</span>
00840 <span class="comment">// Added options for testing the constraint evaluator software.</span>
00841 <span class="comment">// Added functions which test the constraint evaluator.</span>
00842 <span class="comment">// Added function that simulates te complete client-server conversation which</span>
00843 <span class="comment">// causes a variable to be sent after the evaluation of a CE. This manages</span>
00844 <span class="comment">// multiple DDSs just as a real client would. This code is different than the</span>
00845 <span class="comment">// simpler code run by evaluate_dds().</span>
00846 <span class="comment">//</span>
00847 <span class="comment">// Revision 1.2  1995/10/23  23:08:17  jimg</span>
00848 <span class="comment">// Fixed scanner display code to match current scanner.</span>
00849 <span class="comment">// Added code to test simple evaluator.</span>
00850 <span class="comment">// Fixed type declarations (YYSTYPE, ...).</span>
00851 <span class="comment">//</span>
00852 <span class="comment">// Revision 1.1  1995/10/13  03:02:26  jimg</span>
00853 <span class="comment">// First version. Runs scanner and parser.</span>
00854 <span class="comment">//</span>
00855 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Feb 4 23:43:00 2004 for libdap++ by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
