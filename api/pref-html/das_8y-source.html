<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>das.y Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>das.y</h1><a href="das_8y.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00002 <span class="comment">// -*- mode: c++; c-basic-offset:4 -*-</span>
00003 
00004 <span class="comment">// This file is part of libdap, A C++ implementation of the OPeNDAP Data</span>
00005 <span class="comment">// Access Protocol.</span>
00006 
00007 <span class="comment">// Copyright (c) 2002,2003 OPeNDAP, Inc.</span>
00008 <span class="comment">// Author: James Gallagher &lt;jgallagher@opendap.org&gt;</span>
00009 <span class="comment">//</span>
00010 <span class="comment">// This library is free software; you can redistribute it and/or</span>
00011 <span class="comment">// modify it under the terms of the GNU Lesser General Public</span>
00012 <span class="comment">// License as published by the Free Software Foundation; either</span>
00013 <span class="comment">// version 2.1 of the License, or (at your option) any later version.</span>
00014 <span class="comment">// </span>
00015 <span class="comment">// This library is distributed in the hope that it will be useful,</span>
00016 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00017 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00018 <span class="comment">// Lesser General Public License for more details.</span>
00019 <span class="comment">// </span>
00020 <span class="comment">// You should have received a copy of the GNU Lesser General Public</span>
00021 <span class="comment">// License along with this library; if not, write to the Free Software</span>
00022 <span class="comment">// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00023 <span class="comment">//</span>
00024 <span class="comment">// You can contact OPeNDAP, Inc. at PO Box 112, Saunderstown, RI. 02874-0112.</span>
00025  
00026 <span class="comment">// (c) COPYRIGHT URI/MIT 1994-1999</span>
00027 <span class="comment">// Please read the full copyright statement in the file COPYRIGHT_URI.</span>
00028 <span class="comment">//</span>
00029 <span class="comment">// Authors:</span>
00030 <span class="comment">//      jhrg,jimg       James Gallagher &lt;jgallagher@gso.uri.edu&gt;</span>
00031 
00032 <span class="comment">/*</span>
00033 <span class="comment">   Grammar for the DAS. This grammar can be used with the bison parser</span>
00034 <span class="comment">   generator to build a parser for the DAS. It assumes that a scanner called</span>
00035 <span class="comment">   `daslex()' exists and that the objects DAS and AttrTable also exist.</span>
00036 <span class="comment"></span>
00037 <span class="comment">   jhrg 7/12/94 </span>
00038 <span class="comment">*/</span>
00039 
00040 %{
00041 
00042 <span class="preprocessor">#define YYSTYPE char *</span>
00043 <span class="preprocessor"></span>
00044 <span class="preprocessor">#include "<a class="code" href="config__dap_8h.html">config_dap.h</a>"</span>
00045 
00046 <span class="keyword">static</span> <span class="keywordtype">char</span> rcsid[] not_used = {<span class="stringliteral">"$Id$"</span>};
00047 
00048 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00049 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00050 <span class="preprocessor">#include &lt;string&gt;</span>
00051 <span class="preprocessor">#include &lt;assert.h&gt;</span>
00052 
00053 <span class="preprocessor">#if defined(__GNUG__) || defined(WIN32)</span>
00054 <span class="preprocessor"></span><span class="preprocessor">#include &lt;strstream&gt;</span>
00055 <span class="preprocessor">#else</span>
00056 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sstream&gt;</span>
00057 <span class="preprocessor">#endif</span>
00058 <span class="preprocessor"></span><span class="preprocessor">#include &lt;vector&gt;</span>
00059 
00060 <span class="preprocessor">#include "<a class="code" href="DAS_8h.html">DAS.h</a>"</span>
00061 <span class="preprocessor">#include "<a class="code" href="Error_8h.html">Error.h</a>"</span>
00062 <span class="preprocessor">#include "<a class="code" href="debug_8h.html">debug.h</a>"</span>
00063 <span class="preprocessor">#include "<a class="code" href="parser_8h.html">parser.h</a>"</span>
00064 <span class="preprocessor">#include "<a class="code" href="das_8tab_8h.html">das.tab.h</a>"</span>
00065 
00066 <span class="preprocessor">#ifdef TRACE_NEW</span>
00067 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="trace__new_8h.html">trace_new.h</a>"</span>
00068 <span class="preprocessor">#endif</span>
00069 <span class="preprocessor"></span>
00070 <span class="preprocessor">#ifdef WIN32</span>
00071 <span class="preprocessor"></span><span class="keyword">using</span> std::ends;
00072 <span class="keyword">using</span> std::ostrstream;
00073 <span class="preprocessor">#endif</span>
00074 <span class="preprocessor"></span>
00075 <span class="comment">// These macros are used to access the `arguments' passed to the parser. A</span>
00076 <span class="comment">// pointer to an error object and a pointer to an integer status variable are</span>
00077 <span class="comment">// passed in to the parser within a strucutre (which itself is passed as a</span>
00078 <span class="comment">// pointer). Note that the ERROR macro explicitly casts OBJ to an ERROR *. </span>
00079 <span class="comment">// The parser now throws an exception when it encounters an error. 5/23/2002</span>
00080 <span class="comment">// jhrg </span>
00081 
00082 <span class="preprocessor">#define DAS_OBJ(arg) ((DAS *)((parser_arg *)(arg))-&gt;_object)</span>
00083 <span class="preprocessor"></span>
00084 <span class="preprocessor">#define YYPARSE_PARAM arg</span>
00085 <span class="preprocessor"></span>
00086 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="das_8y.html#a13">das_line_num</a>;    <span class="comment">/* defined in das.lex */</span>
00087 
00088 <span class="comment">// No global static objects. We go through this every so often, I guess I</span>
00089 <span class="comment">// should learn... 1/24/2000 jhrg</span>
00090 <span class="keyword">static</span> string *<a class="code" href="das_8y.html#a18">name</a>;    <span class="comment">/* holds name in attr_pair rule */</span>
00091 <span class="keyword">static</span> string *type;    <span class="comment">/* holds type in attr_pair rule */</span>
00092 
00093 <span class="keyword">static</span> vector&lt;AttrTable *&gt; *attr_tab_stack;
00094 
00095 <span class="comment">// I use a vector of AttrTable pointers for a stack</span>
00096 
00097 <span class="preprocessor">#define TOP_OF_STACK (attr_tab_stack-&gt;back())</span>
00098 <span class="preprocessor"></span><span class="preprocessor">#define PUSH(x) (attr_tab_stack-&gt;push_back((x)))</span>
00099 <span class="preprocessor"></span><span class="preprocessor">#define POP (attr_tab_stack-&gt;pop_back())</span>
00100 <span class="preprocessor"></span><span class="preprocessor">#define STACK_LENGTH (attr_tab_stack-&gt;size())</span>
00101 <span class="preprocessor"></span><span class="preprocessor">#define OUTER_TABLE_ONLY (attr_tab_stack-&gt;size() == 1)</span>
00102 <span class="preprocessor"></span><span class="preprocessor">#define STACK_EMPTY (attr_tab_stack-&gt;empty())</span>
00103 <span class="preprocessor"></span>
00104 <span class="preprocessor">#define TYPE_NAME_VALUE(x) *type &lt;&lt; " " &lt;&lt; *name &lt;&lt; " " &lt;&lt; (x)</span>
00105 <span class="preprocessor"></span>
00106 <span class="keyword">static</span> <span class="keywordtype">char</span> *ATTR_TUPLE_MSG = 
00107 <span class="stringliteral">"Expected an attribute type (Byte, Int16, UInt16, Int32, UInt32, Float32,\n\</span>
00108 <span class="stringliteral">Float64, String or Url) followed by a name and value."</span>;
00109 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="das_8y.html#a12">NO_DAS_MSG</a> =
00110 <span class="stringliteral">"The attribute object returned from the dataset was null\n\</span>
00111 <span class="stringliteral">Check that the URL is correct."</span>;
00112 
00113 <span class="keyword">typedef</span> <span class="keywordtype">int</span> checker(<span class="keyword">const</span> <span class="keywordtype">char</span> *);
00114 
00115 <span class="keywordtype">int</span> <a class="code" href="das-test_8cc.html#a10">daslex</a>(<span class="keywordtype">void</span>);
00116 <span class="keyword">static</span> <span class="keywordtype">void</span> daserror(<span class="keywordtype">char</span> *s);
00117 <span class="keyword">static</span> <span class="keywordtype">void</span> add_attribute(<span class="keyword">const</span> string &amp;type, <span class="keyword">const</span> string &amp;<a class="code" href="das_8y.html#a18">name</a>, 
00118               <span class="keyword">const</span> string &amp;<a class="code" href="structvalue.html">value</a>, checker *chk) <span class="keywordflow">throw</span> (Error);
00119 <span class="keyword">static</span> <span class="keywordtype">void</span> add_alias(<a class="code" href="classAttrTable.html">AttrTable</a> *das, <a class="code" href="classAttrTable.html">AttrTable</a> *<a class="code" href="dds_8y.html#a8">current</a>, <span class="keyword">const</span> string &amp;<a class="code" href="das_8y.html#a18">name</a>, 
00120               <span class="keyword">const</span> string &amp;src) <span class="keywordflow">throw</span> (Error);
00121 <span class="keyword">static</span> <span class="keywordtype">void</span> add_bad_attribute(<a class="code" href="classAttrTable.html">AttrTable</a> *attr, <span class="keyword">const</span> string &amp;type,
00122                   <span class="keyword">const</span> string &amp;<a class="code" href="das_8y.html#a18">name</a>, <span class="keyword">const</span> string &amp;<a class="code" href="structvalue.html">value</a>,
00123                   <span class="keyword">const</span> string &amp;<a class="code" href="dds_8y.html#a20">msg</a>);
00124 
00125 %}
00126 
00127 %expect 24
00128 
00129 %token SCAN_ATTR
00130 
00131 %token SCAN_WORD
00132 
00133 %token SCAN_ALIAS
00134 
00135 %token SCAN_BYTE
00136 %token SCAN_INT16
00137 %token SCAN_UINT16
00138 %token SCAN_INT32
00139 %token SCAN_UINT32
00140 %token SCAN_FLOAT32
00141 %token SCAN_FLOAT64
00142 %token SCAN_STRING
00143 %token SCAN_URL
00144 
00145 %%
00146 
00147 <span class="comment">/*</span>
00148 <span class="comment">  Parser algorithm: </span>
00149 <span class="comment"></span>
00150 <span class="comment">  Look for a `variable' name (this can be any identifier, but by convention</span>
00151 <span class="comment">  it is either the name of a variable in a dataset or the name of a grouping</span>
00152 <span class="comment">  of global attributes). Create a new attribute table for this identifier and</span>
00153 <span class="comment">  push the new attribute table onto a stack. If attribute tuples</span>
00154 <span class="comment">  (type-name-value tuples) are found, intern them in the attribute table</span>
00155 <span class="comment">  found on the top of the stack. If the start of a new attribute table if</span>
00156 <span class="comment">  found (before the current table is closed), create the new table and push</span>
00157 <span class="comment">  *it* on the stack. As attribute tables are closed, pop them off the stack.</span>
00158 <span class="comment">  This algorithm ensures that we can nest attribute tables to an arbitrary</span>
00159 <span class="comment">  depth.</span>
00160 <span class="comment"></span>
00161 <span class="comment">  Aliases are handled using mfuncs of both the DAS and AttrTable objects. This</span>
00162 <span class="comment">  is necessary because the first level of a DAS object can contain only</span>
00163 <span class="comment">  AttrTables, not attribute tuples. Whereas, the subsequent levels can</span>
00164 <span class="comment">  contain both. Thus the compete definition is split into two objects. In</span>
00165 <span class="comment">  part this is also a hold over from an older design which did not</span>
00166 <span class="comment">  have the recursive properties of the current design.</span>
00167 <span class="comment"></span>
00168 <span class="comment">  Aliases can be made between attributes within a given lexical level, from</span>
00169 <span class="comment">  one level to the next within a sub-hierarchy or across hierarchies.</span>
00170 <span class="comment"></span>
00171 <span class="comment">  Tokens:</span>
00172 <span class="comment"></span>
00173 <span class="comment">  BYTE, INT32, UINT32, FLOAT64, STRING and URL are tokens for the type</span>
00174 <span class="comment">  keywords. The tokens INT, FLOAT, STR and ID are returned by the scanner to</span>
00175 <span class="comment">  indicate the type of the value represented by the string contained in the</span>
00176 <span class="comment">  global DASLVAL. These two types of tokens are used to implement type</span>
00177 <span class="comment">  checking for the attributes. See the rules `bytes', etc. Additional tokens:</span>
00178 <span class="comment">  ATTR (indicates the start of an attribute object) and ALIAS (indicates an</span>
00179 <span class="comment">  alias). */</span>
00180 
00181 <span class="comment">/* This rule makes sure the objects needed by this parser are built. Because</span>
00182 <span class="comment">   the DODS DAP library is often used with linkers that are not C++-aware, we</span>
00183 <span class="comment">   cannot use global objects (because their constructors might never be</span>
00184 <span class="comment">   called). I had thought this was going to go away... 1/24/2000 jhrg */</span>
00185 
00186 attr_start:
00187                 {
00188             <a class="code" href="das_8y.html#a18">name</a> = <span class="keyword">new</span> string();
00189             type = <span class="keyword">new</span> string();
00190             attr_tab_stack = <span class="keyword">new</span> vector&lt;AttrTable *&gt;;
00191             PUSH(DAS_OBJ(arg)); <span class="comment">// push outermost AttrTable</span>
00192         }
00193                 attributes
00194                 {
00195             POP;    <span class="comment">// pop the DAS/AttrTable before stack's dtor</span>
00196             <span class="keyword">delete</span> <a class="code" href="das_8y.html#a18">name</a>;
00197             <span class="keyword">delete</span> type;
00198             <span class="keyword">delete</span> attr_tab_stack;
00199         }
00200 ;
00201 
00202 attributes:     attribute
00203                 | attributes attribute
00204 
00205 ;
00206                 
00207 attribute:      SCAN_ATTR <span class="charliteral">'{'</span> attr_list <span class="charliteral">'}'</span>
00208                 | error
00209                 {
00210             <a class="code" href="parser-util_8cc.html#a3">parse_error</a>((<a class="code" href="structparser__arg.html">parser_arg</a> *)arg, <a class="code" href="das_8y.html#a12">NO_DAS_MSG</a>, <a class="code" href="das_8y.html#a13">das_line_num</a>);
00211         }
00212 ;
00213 
00214 attr_list:      <span class="comment">/* empty */</span>
00215                 | attr_tuple
00216                 | attr_list attr_tuple
00217 ;
00218 
00219 attr_tuple: alias
00220 
00221                 | SCAN_BYTE { <a class="code" href="parser-util_8cc.html#a5">save_str</a>(*type, <span class="stringliteral">"Byte"</span>, <a class="code" href="das_8y.html#a13">das_line_num</a>); }
00222                 <a class="code" href="das_8y.html#a18">name</a> { <a class="code" href="parser-util_8cc.html#a5">save_str</a>(*<a class="code" href="das_8y.html#a18">name</a>, $3, <a class="code" href="das_8y.html#a13">das_line_num</a>); } 
00223         <a class="code" href="das_8y.html#a20">bytes</a> <span class="charliteral">';'</span>
00224 
00225         | SCAN_INT16 { <a class="code" href="parser-util_8cc.html#a5">save_str</a>(*type, <span class="stringliteral">"Int16"</span>, <a class="code" href="das_8y.html#a13">das_line_num</a>); } 
00226                 <a class="code" href="das_8y.html#a18">name</a> { <a class="code" href="parser-util_8cc.html#a5">save_str</a>(*<a class="code" href="das_8y.html#a18">name</a>, $3, <a class="code" href="das_8y.html#a13">das_line_num</a>); } 
00227         <a class="code" href="das_8y.html#a23">int16</a> <span class="charliteral">';'</span>
00228 
00229         | SCAN_UINT16 { <a class="code" href="parser-util_8cc.html#a5">save_str</a>(*type, <span class="stringliteral">"UInt16"</span>, <a class="code" href="das_8y.html#a13">das_line_num</a>); } 
00230                 <a class="code" href="das_8y.html#a18">name</a> { <a class="code" href="parser-util_8cc.html#a5">save_str</a>(*<a class="code" href="das_8y.html#a18">name</a>, $3, <a class="code" href="das_8y.html#a13">das_line_num</a>); } 
00231         <a class="code" href="das_8y.html#a26">uint16</a> <span class="charliteral">';'</span>
00232 
00233         | SCAN_INT32 { <a class="code" href="parser-util_8cc.html#a5">save_str</a>(*type, <span class="stringliteral">"Int32"</span>, <a class="code" href="das_8y.html#a13">das_line_num</a>); } 
00234                 <a class="code" href="das_8y.html#a18">name</a> { <a class="code" href="parser-util_8cc.html#a5">save_str</a>(*<a class="code" href="das_8y.html#a18">name</a>, $3, <a class="code" href="das_8y.html#a13">das_line_num</a>); } 
00235         <a class="code" href="das_8y.html#a29">int32</a> <span class="charliteral">';'</span>
00236 
00237         | SCAN_UINT32 { <a class="code" href="parser-util_8cc.html#a5">save_str</a>(*type, <span class="stringliteral">"UInt32"</span>, <a class="code" href="das_8y.html#a13">das_line_num</a>); } 
00238                 <a class="code" href="das_8y.html#a18">name</a> { <a class="code" href="parser-util_8cc.html#a5">save_str</a>(*<a class="code" href="das_8y.html#a18">name</a>, $3, <a class="code" href="das_8y.html#a13">das_line_num</a>); } 
00239         <a class="code" href="das_8y.html#a32">uint32</a> <span class="charliteral">';'</span>
00240 
00241         | SCAN_FLOAT32 { <a class="code" href="parser-util_8cc.html#a5">save_str</a>(*type, <span class="stringliteral">"Float32"</span>, <a class="code" href="das_8y.html#a13">das_line_num</a>); } 
00242                 <a class="code" href="das_8y.html#a18">name</a> { <a class="code" href="parser-util_8cc.html#a5">save_str</a>(*<a class="code" href="das_8y.html#a18">name</a>, $3, <a class="code" href="das_8y.html#a13">das_line_num</a>); } 
00243         <a class="code" href="das_8y.html#a35">float32</a> <span class="charliteral">';'</span>
00244 
00245         | SCAN_FLOAT64 { <a class="code" href="parser-util_8cc.html#a5">save_str</a>(*type, <span class="stringliteral">"Float64"</span>, <a class="code" href="das_8y.html#a13">das_line_num</a>); } 
00246                 <a class="code" href="das_8y.html#a18">name</a> { <a class="code" href="parser-util_8cc.html#a5">save_str</a>(*<a class="code" href="das_8y.html#a18">name</a>, $3, <a class="code" href="das_8y.html#a13">das_line_num</a>); } 
00247         <a class="code" href="das_8y.html#a38">float64</a> <span class="charliteral">';'</span>
00248 
00249         | SCAN_STRING { *type = <span class="stringliteral">"String"</span>; } 
00250                 <a class="code" href="das_8y.html#a18">name</a> { *<a class="code" href="das_8y.html#a18">name</a> = $3; } 
00251         <a class="code" href="das_8y.html#a40">strs</a> <span class="charliteral">';'</span>
00252 
00253         | SCAN_URL { *type = <span class="stringliteral">"Url"</span>; } 
00254                 <a class="code" href="das_8y.html#a18">name</a> { *<a class="code" href="das_8y.html#a18">name</a> = $3; } 
00255         <a class="code" href="das_8y.html#a43">urls</a> <span class="charliteral">';'</span>
00256 
00257         | SCAN_WORD
00258                 {
00259             <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Processing ID: "</span> &lt;&lt; $1 &lt;&lt; endl);
00260             
00261             <a class="code" href="classAttrTable.html">AttrTable</a> *at = TOP_OF_STACK-&gt;get_attr_table($1);
00262             <span class="keywordflow">if</span> (!at) {
00263             <span class="keywordflow">try</span> {
00264                 at = TOP_OF_STACK-&gt;append_container($1);
00265             }
00266             <span class="keywordflow">catch</span> (<a class="code" href="classError.html">Error</a> &amp;e) {
00267                 <span class="comment">// rethrow with line number info</span>
00268                 <a class="code" href="parser-util_8cc.html#a3">parse_error</a>(e.error_message().c_str(), 
00269                     <a class="code" href="das_8y.html#a13">das_line_num</a>);
00270             }
00271             }
00272             PUSH(at);
00273 
00274             <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">" Pushed attr_tab: "</span> &lt;&lt; at &lt;&lt; endl);
00275 
00276         }
00277         <span class="charliteral">'{'</span> attr_list 
00278                 {
00279             <span class="comment">/* pop top of stack; store in attr_tab */</span>
00280             <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">" Poped attr_tab: "</span> &lt;&lt; TOP_OF_STACK &lt;&lt; endl);
00281             POP;
00282         }
00283         <span class="charliteral">'}'</span>
00284 
00285         | error 
00286                 { 
00287             <a class="code" href="parser-util_8cc.html#a3">parse_error</a>(ATTR_TUPLE_MSG, <a class="code" href="das_8y.html#a13">das_line_num</a>, $1);
00288         } <span class="charliteral">';'</span>
00289 ;
00290 
00291 <a class="code" href="das_8y.html#a20">bytes</a>:      SCAN_WORD
00292         {
00293             add_attribute(*type, *<a class="code" href="das_8y.html#a18">name</a>, $1, &amp;<a class="code" href="das_8y.html#a19">check_byte</a>);
00294         }
00295         | <a class="code" href="das_8y.html#a20">bytes</a> <span class="charliteral">','</span> SCAN_WORD
00296         {
00297             add_attribute(*type, *<a class="code" href="das_8y.html#a18">name</a>, $3, &amp;<a class="code" href="das_8y.html#a19">check_byte</a>);
00298         }
00299 ;
00300 
00301 <a class="code" href="das_8y.html#a23">int16</a>:      SCAN_WORD
00302         {
00303             add_attribute(*type, *<a class="code" href="das_8y.html#a18">name</a>, $1, &amp;<a class="code" href="das_8y.html#a22">check_int16</a>);
00304         }
00305         | <a class="code" href="das_8y.html#a23">int16</a> <span class="charliteral">','</span> SCAN_WORD
00306         {
00307             add_attribute(*type, *<a class="code" href="das_8y.html#a18">name</a>, $3, &amp;<a class="code" href="das_8y.html#a22">check_int16</a>);
00308         }
00309 ;
00310 
00311 <a class="code" href="das_8y.html#a26">uint16</a>:     SCAN_WORD
00312         {
00313             add_attribute(*type, *<a class="code" href="das_8y.html#a18">name</a>, $1, &amp;<a class="code" href="das_8y.html#a25">check_uint16</a>);
00314         }
00315         | <a class="code" href="das_8y.html#a26">uint16</a> <span class="charliteral">','</span> SCAN_WORD
00316         {
00317             add_attribute(*type, *<a class="code" href="das_8y.html#a18">name</a>, $3, &amp;<a class="code" href="das_8y.html#a25">check_uint16</a>);
00318         }
00319 ;
00320 
00321 <a class="code" href="das_8y.html#a29">int32</a>:      SCAN_WORD
00322         {
00323             add_attribute(*type, *<a class="code" href="das_8y.html#a18">name</a>, $1, &amp;<a class="code" href="das_8y.html#a28">check_int32</a>);
00324         }
00325         | <a class="code" href="das_8y.html#a29">int32</a> <span class="charliteral">','</span> SCAN_WORD
00326         {
00327             add_attribute(*type, *<a class="code" href="das_8y.html#a18">name</a>, $3, &amp;<a class="code" href="das_8y.html#a28">check_int32</a>);
00328         }
00329 ;
00330 
00331 <a class="code" href="das_8y.html#a32">uint32</a>:     SCAN_WORD
00332         {
00333             add_attribute(*type, *<a class="code" href="das_8y.html#a18">name</a>, $1, &amp;<a class="code" href="das_8y.html#a31">check_uint32</a>);
00334         }
00335         | <a class="code" href="das_8y.html#a32">uint32</a> <span class="charliteral">','</span> SCAN_WORD
00336         {
00337             add_attribute(*type, *<a class="code" href="das_8y.html#a18">name</a>, $3, &amp;<a class="code" href="das_8y.html#a31">check_uint32</a>);
00338         }
00339 ;
00340 
00341 <a class="code" href="das_8y.html#a35">float32</a>:    float_or_int
00342         {
00343             add_attribute(*type, *<a class="code" href="das_8y.html#a18">name</a>, $1, &amp;<a class="code" href="das_8y.html#a34">check_float32</a>);
00344         }
00345         | <a class="code" href="das_8y.html#a35">float32</a> <span class="charliteral">','</span> float_or_int
00346         {
00347             add_attribute(*type, *<a class="code" href="das_8y.html#a18">name</a>, $3, &amp;<a class="code" href="das_8y.html#a34">check_float32</a>);
00348         }
00349 ;
00350 
00351 <a class="code" href="das_8y.html#a38">float64</a>:    float_or_int
00352         {
00353             add_attribute(*type, *<a class="code" href="das_8y.html#a18">name</a>, $1, &amp;<a class="code" href="das_8y.html#a37">check_float64</a>);
00354         }
00355         | <a class="code" href="das_8y.html#a38">float64</a> <span class="charliteral">','</span> float_or_int
00356         {
00357             add_attribute(*type, *<a class="code" href="das_8y.html#a18">name</a>, $3, &amp;<a class="code" href="das_8y.html#a37">check_float64</a>);
00358         }
00359 ;
00360 
00361 <a class="code" href="das_8y.html#a40">strs</a>:       str_or_id
00362         {
00363             add_attribute(*type, *<a class="code" href="das_8y.html#a18">name</a>, $1, 0);
00364         }
00365         | <a class="code" href="das_8y.html#a40">strs</a> <span class="charliteral">','</span> str_or_id
00366         {
00367             add_attribute(*type, *<a class="code" href="das_8y.html#a18">name</a>, $3, 0);
00368         }
00369 ;
00370 
00371 <a class="code" href="das_8y.html#a43">urls</a>:       url
00372         {
00373             add_attribute(*type, *<a class="code" href="das_8y.html#a18">name</a>, $1, &amp;<a class="code" href="das_8y.html#a42">check_url</a>);
00374         }
00375         | <a class="code" href="das_8y.html#a43">urls</a> <span class="charliteral">','</span> url
00376         {
00377             add_attribute(*type, *<a class="code" href="das_8y.html#a18">name</a>, $3, &amp;<a class="code" href="das_8y.html#a42">check_url</a>);
00378         }
00379 ;
00380 
00381 url:        SCAN_WORD
00382 ;
00383 
00384 str_or_id:  SCAN_WORD
00385 ;
00386 
00387 float_or_int:   SCAN_WORD
00388 ;
00389 
00390 <a class="code" href="das_8y.html#a18">name</a>:           SCAN_WORD | SCAN_ATTR | SCAN_ALIAS | SCAN_BYTE | SCAN_INT16 
00391                 | SCAN_UINT16 | SCAN_INT32 | SCAN_UINT32 | SCAN_FLOAT32 
00392                 | SCAN_FLOAT64 | SCAN_STRING | SCAN_URL
00393 ;
00394 
00395 alias:          SCAN_ALIAS SCAN_WORD
00396                 { 
00397             *<a class="code" href="das_8y.html#a18">name</a> = $2;
00398         } 
00399                 SCAN_WORD
00400                 {
00401             add_alias(DAS_OBJ(arg), TOP_OF_STACK, *<a class="code" href="das_8y.html#a18">name</a>, string($4))
00402                 }
00403                 <span class="charliteral">';'</span>
00404 ;
00405 
00406 %%
00407 
00408 <span class="comment">// This function is required for linking, but DODS uses its own error</span>
00409 <span class="comment">// reporting mechanism.</span>
00410 
00411 <span class="keyword">static</span> <span class="keywordtype">void</span>
00412 daserror(<span class="keywordtype">char</span> *)
00413 {
00414 }
00415 
00416 <span class="keyword">static</span> string
00417 a_or_an(<span class="keyword">const</span> string &amp;subject)
00418 {
00419     string first_char(1, subject[0]);
00420     string::size_type pos = first_char.find_first_of(<span class="stringliteral">"aeiouAEIOUyY"</span>);
00421     
00422     <span class="keywordflow">if</span> (pos == string::npos)
00423     <span class="keywordflow">return</span> <span class="stringliteral">"a"</span>;
00424     <span class="keywordflow">else</span>
00425     <span class="keywordflow">return</span> <span class="stringliteral">"an"</span>;
00426 }
00427 
00428 <span class="comment">// This code used to throw an exception when a bad attribute value came</span>
00429 <span class="comment">// along; now it dumps the errant value(s) into a sub container called *_DODS</span>
00430 <span class="comment">// and stores the parser's error message in a string attribute named</span>
00431 <span class="comment">// `explanation.' </span>
00432 <span class="keyword">static</span> <span class="keywordtype">void</span>
00433 add_attribute(<span class="keyword">const</span> string &amp;type, <span class="keyword">const</span> string &amp;<a class="code" href="das_8y.html#a18">name</a>, <span class="keyword">const</span> string &amp;<a class="code" href="structvalue.html">value</a>,
00434           checker *chk) <span class="keywordflow">throw</span> (Error)
00435 {
00436     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Adding: "</span> &lt;&lt; type &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; <a class="code" href="das_8y.html#a18">name</a> &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; <a class="code" href="structvalue.html">value</a> \
00437     &lt;&lt; <span class="stringliteral">" to Attrtable: "</span> &lt;&lt; TOP_OF_STACK &lt;&lt; endl);
00438 
00439     <span class="keywordflow">if</span> (chk &amp;&amp; !(*chk)(<a class="code" href="structvalue.html">value</a>.c_str())) {
00440     string <a class="code" href="dds_8y.html#a20">msg</a> = <span class="stringliteral">"`"</span>;
00441     <a class="code" href="dds_8y.html#a20">msg</a> += <a class="code" href="structvalue.html">value</a> + <span class="stringliteral">"' is not "</span> + a_or_an(type) + <span class="stringliteral">" "</span> + type + <span class="stringliteral">" value."</span>;
00442     add_bad_attribute(TOP_OF_STACK, type, <a class="code" href="das_8y.html#a18">name</a>, <a class="code" href="structvalue.html">value</a>, <a class="code" href="dds_8y.html#a20">msg</a>);
00443     <span class="keywordflow">return</span>;
00444     }
00445     
00446     <span class="keywordflow">if</span> (STACK_EMPTY) {
00447     string <a class="code" href="dds_8y.html#a20">msg</a> = <span class="stringliteral">"Whoa! Attribute table stack empty when adding `"</span> ;
00448     <a class="code" href="dds_8y.html#a20">msg</a> += <a class="code" href="das_8y.html#a18">name</a> + <span class="stringliteral">".' "</span>;
00449     <a class="code" href="parser-util_8cc.html#a3">parse_error</a>(<a class="code" href="dds_8y.html#a20">msg</a>.c_str(), <a class="code" href="das_8y.html#a13">das_line_num</a>);
00450     }
00451     
00452     <span class="keywordflow">try</span> {
00453     TOP_OF_STACK-&gt;append_attr(<a class="code" href="das_8y.html#a18">name</a>, type, <a class="code" href="structvalue.html">value</a>);
00454     }
00455     <span class="keywordflow">catch</span> (<a class="code" href="classError.html">Error</a> &amp;e) {
00456     <span class="comment">// rethrow with line number</span>
00457     <a class="code" href="parser-util_8cc.html#a3">parse_error</a>(e.error_message().c_str(), <a class="code" href="das_8y.html#a13">das_line_num</a>);
00458     }
00459 }
00460 
00461 <span class="keyword">static</span> <span class="keywordtype">void</span>
00462 add_alias(<a class="code" href="classAttrTable.html">AttrTable</a> *das, <a class="code" href="classAttrTable.html">AttrTable</a> *<a class="code" href="dds_8y.html#a8">current</a>, <span class="keyword">const</span> string &amp;<a class="code" href="das_8y.html#a18">name</a>, 
00463       <span class="keyword">const</span> string &amp;src) <span class="keywordflow">throw</span> (Error)
00464 {
00465     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Adding an alias: "</span> &lt;&lt; <a class="code" href="das_8y.html#a18">name</a> &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; src &lt;&lt; endl);
00466 
00467     <a class="code" href="classAttrTable.html">AttrTable</a> *table = das-&gt;get_attr_table(src);
00468     <span class="keywordflow">if</span> (table) {
00469     <span class="keywordflow">try</span> {
00470         <a class="code" href="dds_8y.html#a8">current</a>-&gt;add_container_alias(<a class="code" href="das_8y.html#a18">name</a>, table);
00471     }
00472     <span class="keywordflow">catch</span> (<a class="code" href="classError.html">Error</a> &amp;e) {
00473         <a class="code" href="parser-util_8cc.html#a3">parse_error</a>(e.error_message().c_str(), <a class="code" href="das_8y.html#a13">das_line_num</a>);
00474     }
00475     }
00476     <span class="keywordflow">else</span> {
00477     <span class="keywordflow">try</span> {
00478         <a class="code" href="dds_8y.html#a8">current</a>-&gt;add_value_alias(das, <a class="code" href="das_8y.html#a18">name</a>, src);
00479     }
00480     <span class="keywordflow">catch</span> (<a class="code" href="classError.html">Error</a> &amp;e) {
00481         <a class="code" href="parser-util_8cc.html#a3">parse_error</a>(e.error_message().c_str(), <a class="code" href="das_8y.html#a13">das_line_num</a>);
00482     }
00483     }
00484 }
00485 
00486 <span class="keyword">static</span> <span class="keywordtype">void</span>
00487 add_bad_attribute(<a class="code" href="classAttrTable.html">AttrTable</a> *attr, <span class="keyword">const</span> string &amp;type, <span class="keyword">const</span> string &amp;<a class="code" href="das_8y.html#a18">name</a>,
00488           <span class="keyword">const</span> string &amp;<a class="code" href="structvalue.html">value</a>, <span class="keyword">const</span> string &amp;<a class="code" href="dds_8y.html#a20">msg</a>)
00489 {
00490     <span class="comment">// First, if this bad value is already in a *_dods_errors container,</span>
00491     <span class="comment">// then just add it. This can happen when the server side processes a DAS</span>
00492     <span class="comment">// and then hands it off to a client which does the same.</span>
00493     <span class="comment">// Make a new container. Call it &lt;attr's name&gt;_errors. If that container</span>
00494     <span class="comment">// already exists, use it.</span>
00495     <span class="comment">// Add the attribute.</span>
00496     <span class="comment">// Add the error string to an attribute in the container called</span>
00497     <span class="comment">// `&lt;name_explanation.'. </span>
00498     
00499     <span class="keywordflow">if</span> (attr-&gt;<a class="code" href="classAttrTable.html#DASa13">get_name</a>().find(<span class="stringliteral">"_dods_errors"</span>) != string::npos) {
00500     attr-&gt;<a class="code" href="classAttrTable.html#DASa15">append_attr</a>(<a class="code" href="das_8y.html#a18">name</a>, type, <a class="code" href="structvalue.html">value</a>);
00501     }
00502     <span class="keywordflow">else</span> {
00503     string error_cont_name = attr-&gt;<a class="code" href="classAttrTable.html#DASa13">get_name</a>() + <span class="stringliteral">"_dods_errors"</span>;
00504     <a class="code" href="classAttrTable.html">AttrTable</a> *error_cont = attr-&gt;<a class="code" href="classAttrTable.html#DASz5_0">get_attr_table</a>(error_cont_name);
00505     <span class="keywordflow">if</span> (!error_cont)
00506         error_cont = attr-&gt;<a class="code" href="classAttrTable.html#DASa17">append_container</a>(error_cont_name);
00507 
00508     error_cont-&gt;<a class="code" href="classAttrTable.html#DASa15">append_attr</a>(<a class="code" href="das_8y.html#a18">name</a>, type, <a class="code" href="structvalue.html">value</a>);
00509     error_cont-&gt;<a class="code" href="classAttrTable.html#DASa15">append_attr</a>(<a class="code" href="das_8y.html#a18">name</a> + <span class="stringliteral">"_explanation"</span>, <span class="stringliteral">"String"</span>,
00510                 <span class="stringliteral">"\""</span> + <a class="code" href="dds_8y.html#a20">msg</a> + <span class="stringliteral">"\""</span>);
00511     }
00512 }
00513 
00514 <span class="comment">/* </span>
00515 <span class="comment"> * $Log: das_8y-source.html,v $
00515 <span class="comment"> * Revision 1.2  2004/01/30 22:51:15  jimg
00515 <span class="comment"> * Updated 2004/01/30.
00515 <span class="comment"> *</span>
00516 <span class="comment"> * Revision 1.47  2003/04/22 19:40:28  jimg</span>
00517 <span class="comment"> * Merged with 3.3.1.</span>
00518 <span class="comment"> *</span>
00519 <span class="comment"> * Revision 1.46  2003/02/21 00:14:25  jimg</span>
00520 <span class="comment"> * Repaired copyright.</span>
00521 <span class="comment"> *</span>
00522 <span class="comment"> * Revision 1.45.2.1  2003/02/21 00:10:07  jimg</span>
00523 <span class="comment"> * Repaired copyright.</span>
00524 <span class="comment"> *</span>
00525 <span class="comment"> * Revision 1.45  2003/01/23 00:22:24  jimg</span>
00526 <span class="comment"> * Updated the copyright notice; this implementation of the DAP is</span>
00527 <span class="comment"> * copyrighted by OPeNDAP, Inc.</span>
00528 <span class="comment"> *</span>
00529 <span class="comment"> * Revision 1.44  2003/01/10 19:46:41  jimg</span>
00530 <span class="comment"> * Merged with code tagged release-3-2-10 on the release-3-2 branch. In many</span>
00531 <span class="comment"> * cases files were added on that branch (so they appear on the trunk for</span>
00532 <span class="comment"> * the first time).</span>
00533 <span class="comment"> *</span>
00534 <span class="comment"> * Revision 1.43  2002/06/03 22:21:15  jimg</span>
00535 <span class="comment"> * Merged with release-3-2-9</span>
00536 <span class="comment"> *</span>
00537 <span class="comment"> * Revision 1.40.4.8  2002/05/31 21:33:34  jimg</span>
00538 <span class="comment"> * A name can now include the reserved word `attributes.'</span>
00539 <span class="comment"> *</span>
00540 <span class="comment"> * Revision 1.40.4.7  2002/03/14 20:03:08  jimg</span>
00541 <span class="comment"> * Changed the parser so that the attriute type names can also be names of</span>
00542 <span class="comment"> * attribbtues. For example String Url "http..."; is now legal. This fixes</span>
00543 <span class="comment"> * Bug 393.</span>
00544 <span class="comment"> *</span>
00545 <span class="comment"> * Revision 1.40.4.6  2002/01/28 20:34:25  jimg</span>
00546 <span class="comment"> * *** empty log message ***</span>
00547 <span class="comment"> *</span>
00548 <span class="comment"> * Revision 1.40.4.5  2001/11/01 00:43:51  jimg</span>
00549 <span class="comment"> * Fixes to the scanners and parsers so that dataset variable names may</span>
00550 <span class="comment"> * start with digits. I've expanded the set of characters that may appear</span>
00551 <span class="comment"> * in a variable name and made it so that all except `#' may appear at</span>
00552 <span class="comment"> * the start. Some characters are not allowed in variables that appear in</span>
00553 <span class="comment"> * a DDS or CE while they are allowed in the DAS. This makes it possible</span>
00554 <span class="comment"> * to define containers with names like `COARDS:long_name.' Putting a colon</span>
00555 <span class="comment"> * in a variable name makes the CE parser much more complex. Since the set</span>
00556 <span class="comment"> * of characters that people want seems pretty limited (compared to the</span>
00557 <span class="comment"> * complete ASCII set) I think this is an OK approach. If we have to open</span>
00558 <span class="comment"> * up the expr.lex scanner completely, then we can but not without adding</span>
00559 <span class="comment"> * lots of action clauses to teh parser. Note that colon is just an example,</span>
00560 <span class="comment"> * there's a host of characters that are used in CEs that are not allowed</span>
00561 <span class="comment"> * in IDs.</span>
00562 <span class="comment"> *</span>
00563 <span class="comment"> * Revision 1.42  2001/06/15 23:49:03  jimg</span>
00564 <span class="comment"> * Merged with release-3-2-4.</span>
00565 <span class="comment"> *</span>
00566 <span class="comment"> * Revision 1.40.4.4  2001/06/06 06:34:46  jimg</span>
00567 <span class="comment"> * Added double quotes around the explanation's when recording errors in the</span>
00568 <span class="comment"> * DAS.</span>
00569 <span class="comment"> * Added code that checks to see if a bad value is inside the special</span>
00570 <span class="comment"> * _dods_errors attribute container. If so, it leaves it alone. This allows the</span>
00571 <span class="comment"> * errors to be processed by the dap without themselves being errors.</span>
00572 <span class="comment"> * Changed the name of the error container to *_dods_errors.</span>
00573 <span class="comment"> *</span>
00574 <span class="comment"> * Revision 1.40.4.3  2001/06/06 04:08:07  jimg</span>
00575 <span class="comment"> * Changed the way errors are handled. Many errors still cause exceptions to</span>
00576 <span class="comment"> * be thrown. However, if an attribtue's value is wrong (e.g., a floating</span>
00577 <span class="comment"> * point value that is out of range), rather than throw an exception a note</span>
00578 <span class="comment"> * in the form of a container and explanation are added to the attribute</span>
00579 <span class="comment"> * table where the error occurred. This is particularly important for</span>
00580 <span class="comment"> * attributes like numerical values since they are often machine-dependent.</span>
00581 <span class="comment"> *</span>
00582 <span class="comment"> * Revision 1.41  2001/01/26 19:48:09  jimg</span>
00583 <span class="comment"> * Merged with release-3-2-3.</span>
00584 <span class="comment"> *</span>
00585 <span class="comment"> * Revision 1.40.4.2  2000/11/30 05:24:46  jimg</span>
00586 <span class="comment"> * Significant changes and improvements to the AttrTable and DAS classes. DAS</span>
00587 <span class="comment"> * now is a child of AttrTable, which makes attributes behave uniformly at</span>
00588 <span class="comment"> * all levels of the DAS object. Alias now work. I've added unit tests for</span>
00589 <span class="comment"> * several methods in AttrTable and some of the functions in parser-util.cc.</span>
00590 <span class="comment"> * In addition, all of the DAS tests now work.</span>
00591 <span class="comment"> *</span>
00592 <span class="comment"> * Revision 1.40.4.1  2000/11/22 21:47:42  jimg</span>
00593 <span class="comment"> * Changed the implementation of DAS; it now inherits from AttrTable</span>
00594 <span class="comment"> *</span>
00595 <span class="comment"> * Revision 1.40  2000/09/22 02:17:22  jimg</span>
00596 <span class="comment"> * Rearranged source files so that the CVS logs appear at the end rather than</span>
00597 <span class="comment"> * the start. Also made the ifdef guard symbols use the same naming scheme and</span>
00598 <span class="comment"> * wrapped headers included in other headers in those guard symbols (to cut</span>
00599 <span class="comment"> * down on extraneous file processing - See Lakos).</span>
00600 <span class="comment"> *</span>
00601 <span class="comment"> * Revision 1.39  2000/07/09 21:43:29  rmorris</span>
00602 <span class="comment"> * Mods to increase portability, minimize ifdef's for win32</span>
00603 <span class="comment"> *</span>
00604 <span class="comment"> * Revision 1.38  2000/06/07 19:33:21  jimg</span>
00605 <span class="comment"> * Merged with verson 3.1.6</span>
00606 <span class="comment"> *</span>
00607 <span class="comment"> * Revision 1.37  2000/06/07 18:07:00  jimg</span>
00608 <span class="comment"> * Merged the pc port branch</span>
00609 <span class="comment"> *</span>
00610 <span class="comment"> * Revision 1.36.6.1  2000/06/02 18:36:38  rmorris</span>
00611 <span class="comment"> * Mod's for port to Win32.</span>
00612 <span class="comment"> *</span>
00613 <span class="comment"> * Revision 1.35.6.3  2000/05/18 17:47:21  jimg</span>
00614 <span class="comment"> * Fixed a bug in the AttrTable. Container attributes below the top level were</span>
00615 <span class="comment"> * broken in the latest changes to the DAS code.</span>
00616 <span class="comment"> *</span>
00617 <span class="comment"> * Revision 1.36  2000/01/27 06:30:00  jimg</span>
00618 <span class="comment"> * Resolved conflicts from merge with release-3-1-4</span>
00619 <span class="comment"> *</span>
00620 <span class="comment"> * Revision 1.35.6.2  2000/01/24 22:25:10  jimg</span>
00621 <span class="comment"> * Removed static global objects</span>
00622 <span class="comment"> *</span>
00623 <span class="comment"> * Revision 1.35.6.1  1999/10/19 16:45:14  jimg</span>
00624 <span class="comment"> * Fixed a minor bug in the check of int16 attributes. the check_int16 was</span>
00625 <span class="comment"> * called when check_uint16 should have been called.</span>
00626 <span class="comment"> *</span>
00627 <span class="comment"> * Revision 1.35  1999/05/04 19:47:23  jimg</span>
00628 <span class="comment"> * Fixed copyright statements. Removed more of the GNU classes.</span>
00629 <span class="comment"> *</span>
00630 <span class="comment"> * Revision 1.34  1999/04/29 02:29:35  jimg</span>
00631 <span class="comment"> * Merge of no-gnu branch</span>
00632 <span class="comment"> *</span>
00633 <span class="comment"> * Revision 1.33  1999/03/24 23:33:44  jimg</span>
00634 <span class="comment"> * Added support for the new Int16, UInt16 and Float32 types.</span>
00635 <span class="comment"> *</span>
00636 <span class="comment"> * Revision 1.32.12.2  1999/02/05 09:32:35  jimg</span>
00637 <span class="comment"> * Fixed __unused__ so that it not longer clashes with Red Hat 5.2 inlined</span>
00638 <span class="comment"> * math code. </span>
00639 <span class="comment"> *</span>
00640 <span class="comment"> * Revision 1.32.12.1  1999/02/02 21:57:06  jimg</span>
00641 <span class="comment"> * String to string version</span>
00642 <span class="comment"> *</span>
00643 <span class="comment"> * Revision 1.32  1997/07/01 00:13:23  jimg</span>
00644 <span class="comment"> * Fixed a bug when vectors of UInt32 were used. I changed the way the type</span>
00645 <span class="comment"> * name was passed to AttrTable::append_attr() so that the names were always</span>
00646 <span class="comment"> * the same regardless of form of the name used in the DAS.</span>
00647 <span class="comment"> * Fixed a bug when Urls are used as an attribute type.</span>
00648 <span class="comment"> *</span>
00649 <span class="comment"> * Revision 1.31  1997/05/21 00:10:35  jimg</span>
00650 <span class="comment"> * Added a fix for aliases between top level groups of attributes.</span>
00651 <span class="comment"> *</span>
00652 <span class="comment"> * Revision 1.30  1997/05/13 23:32:19  jimg</span>
00653 <span class="comment"> * Added changes to handle the new Alias and lexical scoping rules.</span>
00654 <span class="comment"> *</span>
00655 <span class="comment"> * Revision 1.29  1997/05/06 22:09:57  jimg</span>
00656 <span class="comment"> * Added aliases to the grammar. An alias can appear in place of an attribute</span>
00657 <span class="comment"> * and uses the syntax `alias &lt;var1&gt; &lt;var2&gt;'. If var1 exists, var2 becomes an</span>
00658 <span class="comment"> * alias to it and vice versa. If neither var1 nor var2 exists or if they both</span>
00659 <span class="comment"> * exist, and error is reported and parsing stops.</span>
00660 <span class="comment"> *</span>
00661 <span class="comment"> * Revision 1.28  1997/02/28 01:01:07  jimg</span>
00662 <span class="comment"> * Tweaked error messages so that they no longer mumble about parse errors.</span>
00663 <span class="comment"> *</span>
00664 <span class="comment"> * Revision 1.27  1997/02/10 02:36:57  jimg</span>
00665 <span class="comment"> * Fixed bug where attribute type of int32 was broken on 64bit machines.</span>
00666 <span class="comment"> *</span>
00667 <span class="comment"> * Revision 1.26  1996/10/28 23:04:46  jimg</span>
00668 <span class="comment"> * Added unsigned int to set of possible attribute value types.</span>
00669 <span class="comment"> *</span>
00670 <span class="comment"> * Revision 1.25  1996/10/11 00:11:03  jimg</span>
00671 <span class="comment"> * Fixed DODS_BISON_VER preprocessor statement. &gt;= apparently is not recognized</span>
00672 <span class="comment"> * by g++'s preprocessor.</span>
00673 <span class="comment"> *</span>
00674 <span class="comment"> * Revision 1.24  1996/10/08 17:04:40  jimg</span>
00675 <span class="comment"> * Added a fix for Bison 1.25 so that PARSE_PARAM will still work</span>
00676 <span class="comment"> *</span>
00677 <span class="comment"> * Revision 1.23  1996/08/13 18:46:38  jimg</span>
00678 <span class="comment"> * Added parser_arg object macros.</span>
00679 <span class="comment"> * `Fixed' error messages.</span>
00680 <span class="comment"> * Changed return typw of daserror() from int to void.</span>
00681 <span class="comment"> *</span>
00682 <span class="comment"> * Revision 1.22  1996/06/07 15:05:16  jimg</span>
00683 <span class="comment"> * Removed old type checking code - use the type checkers in parser-util.cc.</span>
00684 <span class="comment"> *</span>
00685 <span class="comment"> * Revision 1.21  1996/05/31 23:30:52  jimg</span>
00686 <span class="comment"> * Updated copyright notice.</span>
00687 <span class="comment"> *</span>
00688 <span class="comment"> * Revision 1.20  1996/04/05 00:22:13  jimg</span>
00689 <span class="comment"> * Compiled with g++ -Wall and fixed various warnings.</span>
00690 <span class="comment"> *</span>
00691 <span class="comment"> * Revision 1.19  1995/12/06  19:46:29  jimg</span>
00692 <span class="comment"> * Added definition of YYSTYPE.</span>
00693 <span class="comment"> *</span>
00694 <span class="comment"> * Revision 1.18  1995/10/23  22:54:39  jimg</span>
00695 <span class="comment"> * Removed code that was NEVER'd.</span>
00696 <span class="comment"> * Changed some rules so that they call functions in parser_util.cc .</span>
00697 <span class="comment"> *</span>
00698 <span class="comment"> * Revision 1.17  1995/09/05  23:19:45  jimg</span>
00699 <span class="comment"> * Fixed a bug in check_float where `=' was used where `==' should have been.</span>
00700 <span class="comment"> *</span>
00701 <span class="comment"> * Revision 1.16  1995/08/23  00:25:54  jimg</span>
00702 <span class="comment"> * Added copyright notice.</span>
00703 <span class="comment"> * Fixed some bogus comments.</span>
00704 <span class="comment"> *</span>
00705 <span class="comment"> * Revision 1.15  1995/07/08  18:32:10  jimg</span>
00706 <span class="comment"> * Edited comments.</span>
00707 <span class="comment"> * Removed unnecessary declarations.</span>
00708 <span class="comment"> *</span>
00709 <span class="comment"> * Revision 1.14  1995/05/10  13:45:43  jimg</span>
00710 <span class="comment"> * Changed the name of the configuration header file from `config.h' to</span>
00711 <span class="comment"> * `config_dap.h' so that other libraries could have header files which were</span>
00712 <span class="comment"> * installed in the DODS include directory without overwriting this one. Each</span>
00713 <span class="comment"> * config header should follow the convention config_&lt;name&gt;.h.</span>
00714 <span class="comment"> *</span>
00715 <span class="comment"> * Revision 1.13  1995/02/16  15:30:46  jimg</span>
00716 <span class="comment"> * Fixed bug which caused Byte, ... values which were out of range to be</span>
00717 <span class="comment"> * added to the attribute table anyway.</span>
00718 <span class="comment"> * Corrected the number of expected shift-reduce conflicts.</span>
00719 <span class="comment"> *</span>
00720 <span class="comment"> * Revision 1.12  1995/02/10  02:56:21  jimg</span>
00721 <span class="comment"> * Added type checking.</span>
00722 <span class="comment"> *</span>
00723 <span class="comment"> * Revision 1.11  1994/12/22  04:30:56  reza</span>
00724 <span class="comment"> * Made save_str static to avoid linking conflict.</span>
00725 <span class="comment"> *</span>
00726 <span class="comment"> * Revision 1.10  1994/12/16  22:06:23  jimg</span>
00727 <span class="comment"> * Fixed a bug in save_str() where the global NAME was used instead of the</span>
00728 <span class="comment"> * parameter DST.</span>
00729 <span class="comment"> *</span>
00730 <span class="comment"> * Revision 1.9  1994/12/07  21:19:45  jimg</span>
00731 <span class="comment"> * Added a new rule (var) and modified attr_val to handle attribute vectors.</span>
00732 <span class="comment"> * Each element in the vector is seaprated by a comma.</span>
00733 <span class="comment"> * Replaces some old instrumentation code with newer code using the DGB</span>
00734 <span class="comment"> * macros.</span>
00735 <span class="comment"> *</span>
00736 <span class="comment"> * Revision 1.8  1994/11/10  19:50:55  jimg</span>
00737 <span class="comment"> * In the past it was possible to have a null file correctly parse as a</span>
00738 <span class="comment"> * DAS or DDS. However, now that is not possible. It is possible to have</span>
00739 <span class="comment"> * a file that contains no variables parse, but the keyword `Attribute'</span>
00740 <span class="comment"> * or `Dataset' *must* be present. This was changed so that errors from</span>
00741 <span class="comment"> * the CGIs could be detected (since they return nothing in the case of</span>
00742 <span class="comment"> * a error).</span>
00743 <span class="comment"> *</span>
00744 <span class="comment"> * Revision 1.7  1994/10/18  00:23:18  jimg</span>
00745 <span class="comment"> * Added debugging statements.</span>
00746 <span class="comment"> *</span>
00747 <span class="comment"> * Revision 1.6  1994/10/05  16:46:51  jimg</span>
00748 <span class="comment"> * Modified the DAS grammar so that TYPE tokens (from the scanner) were</span>
00749 <span class="comment"> * parsed correcly and added to the new AttrTable class.</span>
00750 <span class="comment"> * Changed the code used to add entries based on changes to AttrTable.</span>
00751 <span class="comment"> * Consoladated error reporting code.</span>
00752 <span class="comment"> *</span>
00753 <span class="comment"> * Revision 1.5  1994/09/27  23:00:39  jimg</span>
00754 <span class="comment"> * Modified to use the new DAS class and new AttrTable class.</span>
00755 <span class="comment"> *</span>
00756 <span class="comment"> * Revision 1.4  1994/09/15  21:10:56  jimg</span>
00757 <span class="comment"> * Added commentary to das.y -- how does it work.</span>
00758 <span class="comment"> *</span>
00759 <span class="comment"> * Revision 1.3  1994/09/09  16:16:38  jimg</span>
00760 <span class="comment"> * Changed the include name to correspond with the class name changes (Var*</span>
00761 <span class="comment"> * to DAS*).</span>
00762 <span class="comment"> *</span>
00763 <span class="comment"> * Revision 1.2  1994/08/02  18:54:15  jimg</span>
00764 <span class="comment"> * Added C++ statements to grammar to generate a table of parsed attributes.</span>
00765 <span class="comment"> * Added a single parameter to dasparse - an object of class DAS.</span>
00766 <span class="comment"> * Solved strange `string accumulation' bug with $1 %2 ... by copying</span>
00767 <span class="comment"> * token's semantic values to temps using mid rule actions.</span>
00768 <span class="comment"> * Added code to create new attribute tables as each variable is parsed (unless</span>
00769 <span class="comment"> * a table has already been allocated, in which case that one is used).</span>
00770 <span class="comment"> *</span>
00771 <span class="comment"> * Revision 1.2  1994/07/25  19:01:21  jimg</span>
00772 <span class="comment"> * Modified scanner and parser so that they can be compiled with g++ and</span>
00773 <span class="comment"> * so that they can be linked using g++. They will be combined with a C++</span>
00774 <span class="comment"> * method using a global instance variable.</span>
00775 <span class="comment"> * Changed the name of line_num in the scanner to das_line_num so that</span>
00776 <span class="comment"> * global symbol won't conflict in executables/libraries with multiple</span>
00777 <span class="comment"> * scanners.</span>
00778 <span class="comment"> *</span>
00779 <span class="comment"> * Revision 1.1  1994/07/25  14:26:45  jimg</span>
00780 <span class="comment"> * Test files for the DAS/DDS parsers and symbol table software.</span>
00781 <span class="comment"> */</span>
00782 
</pre></div><hr><address style="align: right;"><small>Generated on Tue Aug 19 12:42:02 2003 for OPeNDAP by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>
