<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libdap++: BaseType.cc Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>BaseType.cc</h1><a href="BaseType_8cc.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00002 <span class="comment">// -*- mode: c++; c-basic-offset:4 -*-</span>
00003 
00004 <span class="comment">// This file is part of libdap, A C++ implementation of the OPeNDAP Data</span>
00005 <span class="comment">// Access Protocol.</span>
00006 
00007 <span class="comment">// Copyright (c) 2002,2003 OPeNDAP, Inc.</span>
00008 <span class="comment">// Author: James Gallagher &lt;jgallagher@opendap.org&gt;</span>
00009 <span class="comment">//</span>
00010 <span class="comment">// This library is free software; you can redistribute it and/or</span>
00011 <span class="comment">// modify it under the terms of the GNU Lesser General Public</span>
00012 <span class="comment">// License as published by the Free Software Foundation; either</span>
00013 <span class="comment">// version 2.1 of the License, or (at your option) any later version.</span>
00014 <span class="comment">// </span>
00015 <span class="comment">// This library is distributed in the hope that it will be useful,</span>
00016 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00017 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00018 <span class="comment">// Lesser General Public License for more details.</span>
00019 <span class="comment">// </span>
00020 <span class="comment">// You should have received a copy of the GNU Lesser General Public</span>
00021 <span class="comment">// License along with this library; if not, write to the Free Software</span>
00022 <span class="comment">// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00023 <span class="comment">//</span>
00024 <span class="comment">// You can contact OPeNDAP, Inc. at PO Box 112, Saunderstown, RI. 02874-0112.</span>
00025  
00026 <span class="comment">// (c) COPYRIGHT URI/MIT 1994-1999</span>
00027 <span class="comment">// Please read the full copyright statement in the file COPYRIGHT_URI.</span>
00028 <span class="comment">//</span>
00029 <span class="comment">// Authors:</span>
00030 <span class="comment">//      jhrg,jimg       James Gallagher &lt;jgallagher@gso.uri.edu&gt;</span>
00031 
00032 <span class="comment">// Implementation for BaseType.</span>
00033 <span class="comment">//</span>
00034 <span class="comment">// jhrg 9/6/94</span>
00035 
00036 <span class="preprocessor">#ifdef __GNUG__</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#pragma implementation</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00039 <span class="preprocessor"></span>
00040 <span class="preprocessor">#include "<a class="code" href="config__dap_8h.html">config_dap.h</a>"</span>
00041 
00042 <span class="preprocessor">#include &lt;stdio.h&gt;</span>      <span class="comment">// for stdin and stdout</span>
00043 
00044 <span class="preprocessor">#include &lt;sstream&gt;</span>
00045 <span class="preprocessor">#include &lt;string&gt;</span>
00046 
00047 <span class="comment">// #define DODS_DEBUG</span>
00048 
00049 <span class="preprocessor">#include "<a class="code" href="debug_8h.html">debug.h</a>"</span>
00050 <span class="preprocessor">#include "<a class="code" href="BaseType_8h.html">BaseType.h</a>"</span>
00051 <span class="preprocessor">#include "<a class="code" href="util_8h.html">util.h</a>"</span>
00052 <span class="preprocessor">#include "<a class="code" href="InternalErr_8h.html">InternalErr.h</a>"</span>
00053 <span class="preprocessor">#include "<a class="code" href="escaping_8h.html">escaping.h</a>"</span>
00054 
00055 <span class="keyword">using</span> std::cerr;
00056 <span class="keyword">using</span> std::endl;
00057 <span class="keyword">using</span> std::ends;
00058 <span class="keyword">using</span> std::ostringstream;
00059 
00060 <span class="comment">// Protected copy mfunc</span>
00061 
00068 <span class="keywordtype">void</span>
<a name="l00069"></a><a class="code" href="classBaseType.html#Vectorb1">00069</a> <a class="code" href="classBaseType.html#Vectorb1">BaseType::_duplicate</a>(<span class="keyword">const</span> <a class="code" href="classBaseType.html">BaseType</a> &amp;bt)
00070 {
00071     _name = bt.<a class="code" href="classBaseType.html#BaseTyper0">_name</a>;
00072     _type = bt.<a class="code" href="classBaseType.html#BaseTyper1">_type</a>;
00073     _read_p = bt.<a class="code" href="classBaseType.html#BaseTyper3">_read_p</a>;   <span class="comment">// added, reza</span>
00074     _send_p = bt.<a class="code" href="classBaseType.html#BaseTyper4">_send_p</a>;   <span class="comment">// added, reza</span>
00075     d_in_selection = bt.<a class="code" href="classBaseType.html#BaseTyper5">d_in_selection</a>;
00076     _synthesized_p = bt.<a class="code" href="classBaseType.html#BaseTyper6">_synthesized_p</a>; <span class="comment">// 5/11/2001 jhrg</span>
00077     _xdr_coder = bt.<a class="code" href="classBaseType.html#BaseTyper2">_xdr_coder</a>; <span class="comment">// just copy this function pointer</span>
00078 
00079     d_parent = bt.<a class="code" href="classBaseType.html#BaseTyper7">d_parent</a>; <span class="comment">// copy pointers 6/4/2001 jhrg</span>
00080 }
00081 
00082 <span class="comment">// Public mfuncs</span>
00083 
<a name="l00104"></a><a class="code" href="classBaseType.html#BaseTypea0">00104</a> <a class="code" href="classBaseType.html#BaseTypea0">BaseType::BaseType</a>(<span class="keyword">const</span> string &amp;n, <span class="keyword">const</span> Type &amp;t, xdrproc_t xdr)
00105     : _name(n), _type(t), _xdr_coder(xdr), _read_p(false), _send_p(false),
00106       d_in_selection(false), _synthesized_p(false), d_parent(0)
00107 {
00108 } 
00109 
<a name="l00111"></a><a class="code" href="classBaseType.html#BaseTypea1">00111</a> <a class="code" href="classBaseType.html#BaseTypea0">BaseType::BaseType</a>(<span class="keyword">const</span> <a class="code" href="classBaseType.html">BaseType</a> &amp;copy_from)
00112 {
00113     <a class="code" href="classBaseType.html#Vectorb1">_duplicate</a>(copy_from);
00114 }
00115     
<a name="l00116"></a><a class="code" href="classBaseType.html#BaseTypea2">00116</a> <a class="code" href="classBaseType.html#BaseTypea2">BaseType::~BaseType</a>()
00117 {
00118     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Entering ~BaseType ("</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="stringliteral">")"</span> &lt;&lt; endl);
00119     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Exiting ~BaseType"</span> &lt;&lt; endl);
00120 }
00121 
00122 <a class="code" href="classBaseType.html">BaseType</a> &amp;
<a name="l00123"></a><a class="code" href="classBaseType.html#BaseTypea4">00123</a> <a class="code" href="classBaseType.html#BaseTypea4">BaseType::operator=</a>(<span class="keyword">const</span> <a class="code" href="classBaseType.html">BaseType</a> &amp;rhs)
00124 {
00125     <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;rhs)
00126     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00127 
00128     <a class="code" href="classBaseType.html#Vectorb1">_duplicate</a>(rhs);
00129 
00130     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00131 }
00132 
00137 string
<a name="l00138"></a><a class="code" href="classBaseType.html#Vectora26">00138</a> <a class="code" href="classBaseType.html#Vectora26">BaseType::toString</a>()
00139 {
00140     ostringstream oss;
00141     oss &lt;&lt; <span class="stringliteral">"BaseType ("</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="stringliteral">"):"</span> &lt;&lt; endl
00142     &lt;&lt; <span class="stringliteral">"          _name: "</span> &lt;&lt; _name &lt;&lt; endl
00143     &lt;&lt; <span class="stringliteral">"          _type: "</span> &lt;&lt; _type &lt;&lt; endl
00144     &lt;&lt; <span class="stringliteral">"          _read_p: "</span> &lt;&lt; _read_p &lt;&lt; endl
00145     &lt;&lt; <span class="stringliteral">"          _send_p: "</span> &lt;&lt; _send_p &lt;&lt; endl
00146     &lt;&lt; <span class="stringliteral">"          _synthesized_p: "</span> &lt;&lt; _synthesized_p &lt;&lt; endl 
00147     &lt;&lt; <span class="stringliteral">"          d_parent: "</span> &lt;&lt; d_parent &lt;&lt; endl;
00148 
00149     <span class="keywordflow">return</span> oss.str();
00150 }
00151 
00154 string 
<a name="l00155"></a><a class="code" href="classBaseType.html#Vectora27">00155</a> <a class="code" href="classBaseType.html#Vectora27">BaseType::name</a>()<span class="keyword"> const</span>
00156 <span class="keyword"></span>{
00157     <span class="keywordflow">return</span> _name; 
00158 }
00159 
00161 <span class="keywordtype">void</span> 
<a name="l00162"></a><a class="code" href="classBaseType.html#Vectora28">00162</a> <a class="code" href="classBaseType.html#Vectora28">BaseType::set_name</a>(<span class="keyword">const</span> string &amp;n)
00163 { 
00164     string <a class="code" href="classBaseType.html#Vectora27">name</a> = n;
00165     _name = <a class="code" href="escaping_8cc.html#a7">www2id</a>(name);   <span class="comment">// www2id writes into its param.</span>
00166 }
00167 
00169 <a class="code" href="BaseType_8h.html#a21">Type</a>
<a name="l00170"></a><a class="code" href="classBaseType.html#Vectora29">00170</a> <a class="code" href="classBaseType.html#Vectora29">BaseType::type</a>()<span class="keyword"> const</span>
00171 <span class="keyword"></span>{
00172     <span class="keywordflow">return</span> _type;
00173 }
00174 
00176 <span class="keywordtype">void</span>
<a name="l00177"></a><a class="code" href="classBaseType.html#Vectora30">00177</a> <a class="code" href="classBaseType.html#Vectora30">BaseType::set_type</a>(<span class="keyword">const</span> Type &amp;t)
00178 {
00179     _type = t;
00180 }
00181 
00183 string
<a name="l00184"></a><a class="code" href="classBaseType.html#Vectora31">00184</a> <a class="code" href="classBaseType.html#Vectora31">BaseType::type_name</a>()<span class="keyword"> const</span>
00185 <span class="keyword"></span>{
00186     <span class="keywordflow">switch</span>(_type) {
00187       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a5">dods_null_c</a>:
00188     <span class="keywordflow">return</span> string(<span class="stringliteral">"Null"</span>);
00189       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a6">dods_byte_c</a>:
00190     <span class="keywordflow">return</span> string(<span class="stringliteral">"Byte"</span>);
00191       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a7">dods_int16_c</a>:
00192     <span class="keywordflow">return</span> string(<span class="stringliteral">"Int16"</span>);
00193       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a8">dods_uint16_c</a>:
00194     <span class="keywordflow">return</span> string(<span class="stringliteral">"UInt16"</span>);
00195       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a9">dods_int32_c</a>:
00196     <span class="keywordflow">return</span> string(<span class="stringliteral">"Int32"</span>);
00197       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a10">dods_uint32_c</a>:
00198     <span class="keywordflow">return</span> string(<span class="stringliteral">"UInt32"</span>);
00199       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a11">dods_float32_c</a>:
00200     <span class="keywordflow">return</span> string(<span class="stringliteral">"Float32"</span>);
00201       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a12">dods_float64_c</a>:
00202     <span class="keywordflow">return</span> string(<span class="stringliteral">"Float64"</span>);
00203       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a13">dods_str_c</a>:
00204     <span class="keywordflow">return</span> string(<span class="stringliteral">"String"</span>);
00205       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a14">dods_url_c</a>:
00206     <span class="keywordflow">return</span> string(<span class="stringliteral">"Url"</span>);
00207       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a15">dods_array_c</a>:
00208     <span class="keywordflow">return</span> string(<span class="stringliteral">"Array"</span>);
00209       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a16">dods_list_c</a>:
00210     <span class="keywordflow">return</span> string(<span class="stringliteral">"List"</span>);
00211       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a17">dods_structure_c</a>:
00212     <span class="keywordflow">return</span> string(<span class="stringliteral">"Structure"</span>);
00213       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a18">dods_sequence_c</a>:
00214     <span class="keywordflow">return</span> string(<span class="stringliteral">"Sequence"</span>);
00215       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a19">dods_grid_c</a>:
00216     <span class="keywordflow">return</span> string(<span class="stringliteral">"Grid"</span>);
00217       <span class="keywordflow">default</span>:
00218     cerr &lt;&lt; <span class="stringliteral">"BaseType::type_name: Undefined type"</span> &lt;&lt; endl;
00219     <span class="keywordflow">return</span> string(<span class="stringliteral">""</span>);
00220     }
00221 }
00222 
00224 <span class="keywordtype">bool</span>
<a name="l00225"></a><a class="code" href="classBaseType.html#Vectora32">00225</a> <a class="code" href="classBaseType.html#Vectora32">BaseType::is_simple_type</a>()
00226 {
00227     <span class="keywordflow">switch</span> (<a class="code" href="classBaseType.html#Vectora29">type</a>()) {
00228       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a5">dods_null_c</a>:
00229       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a6">dods_byte_c</a>:
00230       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a7">dods_int16_c</a>:
00231       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a8">dods_uint16_c</a>:
00232       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a9">dods_int32_c</a>:
00233       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a10">dods_uint32_c</a>:
00234       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a11">dods_float32_c</a>:
00235       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a12">dods_float64_c</a>:
00236       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a13">dods_str_c</a>:
00237       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a14">dods_url_c</a>:
00238     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00239 
00240       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a15">dods_array_c</a>:
00241       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a16">dods_list_c</a>:
00242       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a17">dods_structure_c</a>:
00243       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a18">dods_sequence_c</a>:
00244       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a19">dods_grid_c</a>:
00245     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00246     }
00247 
00248     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00249 }
00250 
00252 <span class="keywordtype">bool</span>
<a name="l00253"></a><a class="code" href="classBaseType.html#Vectora33">00253</a> <a class="code" href="classBaseType.html#Vectora33">BaseType::is_vector_type</a>()
00254 {
00255     <span class="keywordflow">switch</span> (<a class="code" href="classBaseType.html#Vectora29">type</a>()) {
00256       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a5">dods_null_c</a>:
00257       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a6">dods_byte_c</a>:
00258       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a7">dods_int16_c</a>:
00259       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a8">dods_uint16_c</a>:
00260       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a9">dods_int32_c</a>:
00261       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a10">dods_uint32_c</a>:
00262       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a11">dods_float32_c</a>:
00263       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a12">dods_float64_c</a>:
00264       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a13">dods_str_c</a>:
00265       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a14">dods_url_c</a>:
00266     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00267 
00268       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a15">dods_array_c</a>:
00269       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a16">dods_list_c</a>:
00270     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00271 
00272       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a17">dods_structure_c</a>:
00273       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a18">dods_sequence_c</a>:
00274       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a19">dods_grid_c</a>:
00275     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00276     }
00277     
00278     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00279 }
00280 
00282 <span class="keywordtype">bool</span>
<a name="l00283"></a><a class="code" href="classBaseType.html#Vectora34">00283</a> <a class="code" href="classBaseType.html#Vectora34">BaseType::is_constructor_type</a>()
00284 {
00285     <span class="keywordflow">switch</span> (<a class="code" href="classBaseType.html#Vectora29">type</a>()) {
00286       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a5">dods_null_c</a>:
00287       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a6">dods_byte_c</a>:
00288       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a7">dods_int16_c</a>:
00289       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a8">dods_uint16_c</a>:
00290       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a9">dods_int32_c</a>:
00291       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a10">dods_uint32_c</a>:
00292       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a11">dods_float32_c</a>:
00293       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a12">dods_float64_c</a>:
00294       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a13">dods_str_c</a>:
00295       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a14">dods_url_c</a>:
00296       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a15">dods_array_c</a>:
00297       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a16">dods_list_c</a>:
00298     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00299 
00300       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a17">dods_structure_c</a>:
00301       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a18">dods_sequence_c</a>:
00302       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a19">dods_grid_c</a>:
00303     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00304     }
00305 
00306     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00307 }
00308 
00334 <span class="keywordtype">int</span>
<a name="l00335"></a><a class="code" href="classBaseType.html#Urla21">00335</a> <a class="code" href="classBaseType.html#Urla21">BaseType::element_count</a>(<span class="keywordtype">bool</span>)
00336 {
00337     <span class="keywordflow">return</span> 1;
00338 }
00339 
00343 <span class="keywordtype">bool</span>
<a name="l00344"></a><a class="code" href="classBaseType.html#Vectora35">00344</a> <a class="code" href="classBaseType.html#Vectora35">BaseType::synthesized_p</a>()
00345 {
00346     <span class="keywordflow">return</span> _synthesized_p;
00347 }
00348 
00354 <span class="keywordtype">void</span>
<a name="l00355"></a><a class="code" href="classBaseType.html#Vectora36">00355</a> <a class="code" href="classBaseType.html#Vectora36">BaseType::set_synthesized_p</a>(<span class="keywordtype">bool</span> state)
00356 {
00357     _synthesized_p = state;
00358 }
00359 
00360 <span class="comment">// Return the state of _read_p (true if the value of the variable has been</span>
00361 <span class="comment">// read (and is in memory) false otherwise).</span>
00362 
00371 <span class="keywordtype">bool</span>
<a name="l00372"></a><a class="code" href="classBaseType.html#Vectora37">00372</a> <a class="code" href="classBaseType.html#Vectora37">BaseType::read_p</a>()
00373 {
00374     <span class="keywordflow">return</span> _read_p;
00375 }
00376 
00398 <span class="keywordtype">void</span>
<a name="l00399"></a><a class="code" href="classBaseType.html#Urla25">00399</a> <a class="code" href="classBaseType.html#Urla25">BaseType::set_read_p</a>(<span class="keywordtype">bool</span> state)
00400 {
00401     <span class="keywordflow">if</span> (! _synthesized_p) {
00402     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Changing read_p state of "</span> &lt;&lt; <a class="code" href="classBaseType.html#Vectora27">name</a>() &lt;&lt; endl);
00403     _read_p = state;
00404     }
00405 }
00406 
00417 <span class="keywordtype">bool</span>
<a name="l00418"></a><a class="code" href="classBaseType.html#Vectora38">00418</a> <a class="code" href="classBaseType.html#Vectora38">BaseType::send_p</a>()
00419 {
00420     <span class="keywordflow">return</span> _send_p;
00421 }
00422 
00430 <span class="keywordtype">void</span> 
<a name="l00431"></a><a class="code" href="classBaseType.html#Urla27">00431</a> <a class="code" href="classBaseType.html#Urla27">BaseType::set_send_p</a>(<span class="keywordtype">bool</span> state)
00432 {
00433     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Calling BaseType::set_send_p() for: "</span> &lt;&lt; this-&gt;name() 
00434     &lt;&lt; endl);
00435     _send_p = state;
00436 }
00437 
00445 <span class="keywordtype">bool</span> 
<a name="l00446"></a><a class="code" href="classBaseType.html#Vectora39">00446</a> <a class="code" href="classBaseType.html#Vectora39">BaseType::is_in_selection</a>()
00447 {
00448     <span class="keywordflow">return</span> d_in_selection;
00449 }
00450 
00459 <span class="keywordtype">void</span>
<a name="l00460"></a><a class="code" href="classBaseType.html#Vectora40">00460</a> <a class="code" href="classBaseType.html#Vectora40">BaseType::set_in_selection</a>(<span class="keywordtype">bool</span> state)
00461 {
00462     d_in_selection = state;
00463 }
00464 
00465 <span class="comment">// Protected method.</span>
00473 <span class="comment"></span><span class="keywordtype">void</span>
<a name="l00474"></a><a class="code" href="classBaseType.html#Vectora42">00474</a> <a class="code" href="classBaseType.html#Vectora42">BaseType::set_parent</a>(<a class="code" href="classBaseType.html">BaseType</a> *parent) <span class="keywordflow">throw</span>(<a class="code" href="classInternalErr.html">InternalErr</a>)
00475 {
00476     <span class="keywordflow">if</span> (!dynamic_cast&lt;Constructor *&gt;(parent)
00477     &amp;&amp; !dynamic_cast&lt;Vector *&gt;(parent))
00478     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(<span class="stringliteral">"Call to set_parent with incorrect variable type."</span>);
00479 
00480     d_parent = parent;
00481 }
00482 
00483 <span class="comment">// Public method.</span>
00484 
00493 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00494"></a><a class="code" href="classBaseType.html#Vectora43">00494</a> <a class="code" href="classBaseType.html#Vectora43">BaseType::get_parent</a>()
00495 {
00496     <span class="keywordflow">return</span> d_parent;
00497 }
00498 
00499 <span class="comment">// Defined by constructor types (Array, ...)</span>
00500 <span class="comment">//</span>
00501 <span class="comment">// Return a pointer to the contained variable in a ctor class.</span>
00502 
00533 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00534"></a><a class="code" href="classBaseType.html#Vectora44">00534</a> <a class="code" href="classBaseType.html#Vectora44">BaseType::var</a>(<span class="keyword">const</span> string &amp;, <span class="keywordtype">bool</span>, <a class="code" href="BaseType_8h.html#a1">btp_stack</a>*)
00535 {
00536     <span class="keywordflow">return</span> static_cast&lt;BaseType *&gt;(0);
00537 }
00538 
00555 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00556"></a><a class="code" href="classBaseType.html#Urla34">00556</a> <a class="code" href="classBaseType.html#Vectora44">BaseType::var</a>(<span class="keyword">const</span> string &amp;, <a class="code" href="BaseType_8h.html#a1">btp_stack</a> &amp;)
00557 {
00558     <span class="keywordflow">return</span> static_cast&lt;BaseType *&gt;(0);
00559 }
00560 
00593 <span class="keywordtype">void</span>
<a name="l00594"></a><a class="code" href="classBaseType.html#Urla35">00594</a> <a class="code" href="classBaseType.html#Urla35">BaseType::add_var</a>(<a class="code" href="classBaseType.html">BaseType</a> *, Part)
00595 {
00596 }
00597 
00638 <span class="keywordtype">bool</span> 
<a name="l00639"></a><a class="code" href="classBaseType.html#Vectora45">00639</a> <a class="code" href="classBaseType.html#Vectora45">BaseType::read</a>(<span class="keyword">const</span> string &amp;dataset)
00640 {
00641     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(<span class="stringliteral">"Unimplemented BaseType::read() method called."</span>);
00642 }
00643 
00658 xdrproc_t
<a name="l00659"></a><a class="code" href="classBaseType.html#Vectora41">00659</a> <a class="code" href="classBaseType.html#Vectora41">BaseType::xdr_coder</a>()
00660 {
00661     <span class="keywordflow">return</span> _xdr_coder;
00662 }
00663 
00664 <span class="comment">// send a printed representation of the variable's declaration to cout. If</span>
00665 <span class="comment">// print_semi is true, append a semicolon and newline.</span>
00666 
00711 <span class="keywordtype">void</span> 
<a name="l00712"></a><a class="code" href="classBaseType.html#Urla39">00712</a> <a class="code" href="classBaseType.html#Urla38">BaseType::print_decl</a>(ostream &amp;os, string space, <span class="keywordtype">bool</span> print_semi, 
00713              <span class="keywordtype">bool</span> constraint_info, <span class="keywordtype">bool</span> constrained)
00714 {
00715     <span class="comment">// if printing the constrained declaration, exit if this variable was not</span>
00716     <span class="comment">// selected. </span>
00717     <span class="keywordflow">if</span> (constrained &amp;&amp; !<a class="code" href="classBaseType.html#Vectora38">send_p</a>())
00718     <span class="keywordflow">return</span>;
00719 
00720     os &lt;&lt; space &lt;&lt; <a class="code" href="classBaseType.html#Vectora31">type_name</a>() &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; <a class="code" href="escaping_8cc.html#a5">id2www</a>(_name);
00721 
00722     <span class="keywordflow">if</span> (constraint_info) {
00723     <span class="keywordflow">if</span> (<a class="code" href="classBaseType.html#Vectora38">send_p</a>())
00724         cout &lt;&lt; <span class="stringliteral">": Send True"</span>;
00725     <span class="keywordflow">else</span>
00726         cout &lt;&lt; <span class="stringliteral">": Send False"</span>;
00727     }
00728 
00729     <span class="keywordflow">if</span> (print_semi)
00730     os &lt;&lt; <span class="stringliteral">";"</span> &lt;&lt; endl;
00731 }
00732 
00775 <span class="keywordtype">void</span> 
<a name="l00776"></a><a class="code" href="classBaseType.html#Urla38">00776</a> <a class="code" href="classBaseType.html#Urla38">BaseType::print_decl</a>(FILE *out, string space, <span class="keywordtype">bool</span> print_semi, 
00777              <span class="keywordtype">bool</span> constraint_info, <span class="keywordtype">bool</span> constrained)
00778 {
00779     <span class="comment">// if printing the constrained declaration, exit if this variable was not</span>
00780     <span class="comment">// selected. </span>
00781     <span class="keywordflow">if</span> (constrained &amp;&amp; !<a class="code" href="classBaseType.html#Vectora38">send_p</a>())
00782     <span class="keywordflow">return</span>;
00783 
00784     fprintf( out, <span class="stringliteral">"%s%s %s"</span>, space.c_str(), <a class="code" href="classBaseType.html#Vectora31">type_name</a>().c_str(),
00785          <a class="code" href="escaping_8cc.html#a5">id2www</a>(_name).c_str() ) ;
00786 
00787     <span class="keywordflow">if</span> (constraint_info) {
00788     <span class="keywordflow">if</span> (<a class="code" href="classBaseType.html#Vectora38">send_p</a>())
00789         fprintf( stdout, <span class="stringliteral">": Send True"</span> ) ;
00790     <span class="keywordflow">else</span>
00791         fprintf( stdout, <span class="stringliteral">": Send False"</span> ) ;
00792     }
00793 
00794     <span class="keywordflow">if</span> (print_semi)
00795     fprintf( out, <span class="stringliteral">";\n"</span> ) ;
00796 }
00797 
00798 <span class="comment">// Compares the object's current state with the semantics of a particular</span>
00799 <span class="comment">// type. This will typically be defined in ctor classes (which have</span>
00800 <span class="comment">// complicated semantics). For BaseType, an object is semantically correct if</span>
00801 <span class="comment">// it has both a non-null name and type.</span>
00802 <span class="comment">//</span>
00803 <span class="comment">// NB: This is not the same as an invariant -- during the parse objects exist</span>
00804 <span class="comment">// but have no name. Also, the bool ALL defaults to false for BaseType. It is</span>
00805 <span class="comment">// used by children of CtorType.</span>
00806 <span class="comment">//</span>
00807 <span class="comment">// Returns: true if the object is semantically correct, false otherwise.</span>
00808 
00837 <span class="keywordtype">bool</span>
<a name="l00838"></a><a class="code" href="classBaseType.html#Urla40">00838</a> <a class="code" href="classBaseType.html#Urla40">BaseType::check_semantics</a>(string &amp;msg, <span class="keywordtype">bool</span>)
00839 {
00840     <span class="keywordtype">bool</span> sem = (_type != <a class="code" href="BaseType_8h.html#a21a5">dods_null_c</a> &amp;&amp; _name.length());
00841 
00842     <span class="keywordflow">if</span> (!sem) 
00843     msg = <span class="stringliteral">"Every variable must have both a name and a type\n"</span>;
00844 
00845     <span class="keywordflow">return</span> sem;
00846 }
00847 
00884 <span class="keywordtype">bool</span> 
<a name="l00885"></a><a class="code" href="classBaseType.html#Vectora47">00885</a> <a class="code" href="classBaseType.html#Vectora47">BaseType::ops</a>(<a class="code" href="classBaseType.html">BaseType</a> *, <span class="keywordtype">int</span>, <span class="keyword">const</span> string &amp;)
00886 {
00887     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, <span class="stringliteral">"Unimplemented operator."</span>);
00888 }
00889 
00890 <span class="comment">// $Log: BaseType_8cc-source.html,v $
00890 <span class="comment">// Revision 1.4  2004/02/05 06:51:15  jimg
00890 <span class="comment">// Added/update.
00890 <span class="comment">//</span>
00891 <span class="comment">// Revision 1.51.2.5  2004/01/22 17:09:52  jimg</span>
00892 <span class="comment">// Added std namespace declarations since the DBG() macro uses cerr.</span>
00893 <span class="comment">//</span>
00894 <span class="comment">// Revision 1.51.2.4  2004/01/08 20:36:57  jimg</span>
00895 <span class="comment">// Minor addition to the docuementation for set_parent().</span>
00896 <span class="comment">//</span>
00897 <span class="comment">// Revision 1.51.2.3  2003/09/28 20:57:22  rmorris</span>
00898 <span class="comment">// Discontinued use of XDR_PROC typedef, using xdrproc_t instead - a</span>
00899 <span class="comment">// define from the xdr portion of the rpc library.</span>
00900 <span class="comment">//</span>
00901 <span class="comment">// Revision 1.51.2.2  2003/09/06 22:23:24  jimg</span>
00902 <span class="comment">// Significant changes to the documentation. Added the in_selection property and</span>
00903 <span class="comment">// accessor/mutator methods for it. Added use of the typedef XDR_PROC which</span>
00904 <span class="comment">// allowed me to remove some of the #if WIN32 code (see dods-datatypes.h.in).</span>
00905 <span class="comment">//</span>
00906 <span class="comment">// Revision 1.51.2.1  2003/06/05 20:15:25  jimg</span>
00907 <span class="comment">// Removed many uses of strstream and replaced them with stringstream.</span>
00908 <span class="comment">//</span>
00909 <span class="comment">// Revision 1.51  2003/04/22 19:40:27  jimg</span>
00910 <span class="comment">// Merged with 3.3.1.</span>
00911 <span class="comment">//</span>
00912 <span class="comment">// Revision 1.50  2003/02/21 00:14:24  jimg</span>
00913 <span class="comment">// Repaired copyright.</span>
00914 <span class="comment">//</span>
00915 <span class="comment">// Revision 1.49.2.1  2003/02/21 00:10:06  jimg</span>
00916 <span class="comment">// Repaired copyright.</span>
00917 <span class="comment">//</span>
00918 <span class="comment">// Revision 1.49  2003/01/23 00:22:23  jimg</span>
00919 <span class="comment">// Updated the copyright notice; this implementation of the DAP is</span>
00920 <span class="comment">// copyrighted by OPeNDAP, Inc.</span>
00921 <span class="comment">//</span>
00922 <span class="comment">// Revision 1.48  2003/01/10 19:46:39  jimg</span>
00923 <span class="comment">// Merged with code tagged release-3-2-10 on the release-3-2 branch. In many</span>
00924 <span class="comment">// cases files were added on that branch (so they appear on the trunk for</span>
00925 <span class="comment">// the first time).</span>
00926 <span class="comment">//</span>
00927 <span class="comment">// Revision 1.42.4.10  2002/12/17 22:35:02  pwest</span>
00928 <span class="comment">// Added and updated methods using stdio. Deprecated methods using iostream.</span>
00929 <span class="comment">//</span>
00930 <span class="comment">// Revision 1.47  2002/06/27 16:26:48  tom</span>
00931 <span class="comment">// typo</span>
00932 <span class="comment">//</span>
00933 <span class="comment">// Revision 1.46  2002/06/18 15:36:24  tom</span>
00934 <span class="comment">// Moved comments and edited to accommodate doxygen documentation-generator.</span>
00935 <span class="comment">//</span>
00936 <span class="comment">// Revision 1.45  2002/06/03 22:21:15  jimg</span>
00937 <span class="comment">// Merged with release-3-2-9</span>
00938 <span class="comment">//</span>
00939 <span class="comment">// Revision 1.42.4.9  2002/05/09 16:55:08  jimg</span>
00940 <span class="comment">// Added a definition for read(). This method was abstract; now it has an</span>
00941 <span class="comment">// implementation, albeit one that just throws an InternalErr exception. This</span>
00942 <span class="comment">// means that clients do not have to subclass the datatypes anymore! Simple</span>
00943 <span class="comment">// clients such as geturl should work just fine linking to the library without a</span>
00944 <span class="comment">// dummy set of specializations for the datatypes.</span>
00945 <span class="comment">//</span>
00946 <span class="comment">// Revision 1.42.4.8  2002/04/03 13:34:29  jimg</span>
00947 <span class="comment">// Added using std::endl and std::ends.</span>
00948 <span class="comment">//</span>
00949 <span class="comment">// Revision 1.42.4.7  2002/03/01 21:03:08  jimg</span>
00950 <span class="comment">// Significant changes to the var(...) methods. These now take a btp_stack</span>
00951 <span class="comment">// pointer and are used by DDS::mark(...). The exact_match methods have also</span>
00952 <span class="comment">// been updated so that leaf variables which contain dots in their names</span>
00953 <span class="comment">// will be found. Note that constructor variables with dots in their names</span>
00954 <span class="comment">// will break the lookup routines unless the ctor is the last field in the</span>
00955 <span class="comment">// constraint expression. These changes were made to fix bug 330.</span>
00956 <span class="comment">//</span>
00957 <span class="comment">// Revision 1.42.4.6  2001/10/30 06:55:45  rmorris</span>
00958 <span class="comment">// Win32 porting changes.  Brings core win32 port up-to-date.</span>
00959 <span class="comment">//</span>
00960 <span class="comment">// Revision 1.44  2001/08/24 17:46:22  jimg</span>
00961 <span class="comment">// Resolved conflicts from the merge of release 3.2.6</span>
00962 <span class="comment">//</span>
00963 <span class="comment">// Revision 1.42.4.5  2001/08/18 01:48:30  jimg</span>
00964 <span class="comment">// Removed WIN32 compile guards from using statements.</span>
00965 <span class="comment">//</span>
00966 <span class="comment">// Revision 1.42.4.4  2001/07/28 01:10:41  jimg</span>
00967 <span class="comment">// Some of the numeric type classes did not have copy ctors or operator=.</span>
00968 <span class="comment">// I added those where they were needed.</span>
00969 <span class="comment">// In every place where delete (or delete []) was called, I set the pointer</span>
00970 <span class="comment">// just deleted to zero. Thus if for some reason delete is called again</span>
00971 <span class="comment">// before new memory is allocated there won't be a mysterious crash. This is</span>
00972 <span class="comment">// just good form when using delete.</span>
00973 <span class="comment">// I added calls to www2id and id2www where appropriate. The DAP now handles</span>
00974 <span class="comment">// making sure that names are escaped and unescaped as needed. Connect is</span>
00975 <span class="comment">// set to handle CEs that contain names as they are in the dataset (see the</span>
00976 <span class="comment">// comments/Log there). Servers should not handle escaping or unescaping</span>
00977 <span class="comment">// characters on their own.</span>
00978 <span class="comment">//</span>
00979 <span class="comment">// Revision 1.43  2001/06/15 23:49:01  jimg</span>
00980 <span class="comment">// Merged with release-3-2-4.</span>
00981 <span class="comment">//</span>
00982 <span class="comment">// Revision 1.42.4.3  2001/06/07 16:58:06  jimg</span>
00983 <span class="comment">// Added explicit include of debug.h.</span>
00984 <span class="comment">//</span>
00985 <span class="comment">// Revision 1.42.4.2  2001/06/05 06:49:19  jimg</span>
00986 <span class="comment">// Added the Constructor class which is to Structures, Sequences and Grids</span>
00987 <span class="comment">// what Vector is to Arrays and Lists. This should be used in future</span>
00988 <span class="comment">// refactorings (I thought it was going to be used for the back pointers).</span>
00989 <span class="comment">// Introduced back pointers so children can refer to their parents in</span>
00990 <span class="comment">// hierarchies of variables.</span>
00991 <span class="comment">// Added to Sequence methods to tell if a child sequence is done</span>
00992 <span class="comment">// deserializing its data.</span>
00993 <span class="comment">// Fixed the operator=() and copy ctors; removed redundency from</span>
00994 <span class="comment">// _duplicate().</span>
00995 <span class="comment">// Changed the way serialize and deserialize work for sequences. Now SOI and</span>
00996 <span class="comment">// EOS markers are written for every `level' of a nested Sequence. This</span>
00997 <span class="comment">// should fixed nested Sequences. There is still considerable work to do</span>
00998 <span class="comment">// for these to work in all cases.</span>
00999 <span class="comment">//</span>
01000 <span class="comment">// Revision 1.42.4.1  2001/05/12 00:00:26  jimg</span>
01001 <span class="comment">// Fixed a bug where the field _synthesized_p was not copied in _duplicate.</span>
01002 <span class="comment">// Added an implementation of toString(). Used for debugging.</span>
01003 <span class="comment">//</span>
01004 <span class="comment">// Revision 1.42  2000/09/22 02:17:18  jimg</span>
01005 <span class="comment">// Rearranged source files so that the CVS logs appear at the end rather than</span>
01006 <span class="comment">// the start. Also made the ifdef guard symbols use the same naming scheme and</span>
01007 <span class="comment">// wrapped headers included in other headers in those guard symbols (to cut</span>
01008 <span class="comment">// down on extraneous file processing - See Lakos).</span>
01009 <span class="comment">//</span>
01010 <span class="comment">// Revision 1.41  2000/09/21 16:22:07  jimg</span>
01011 <span class="comment">// Merged changes from Jose Garcia that add exceptions to the software.</span>
01012 <span class="comment">// Many methods that returned error codes now throw exectptions. There are</span>
01013 <span class="comment">// two classes which are thrown by the software, Error and InternalErr.</span>
01014 <span class="comment">// InternalErr is used to report errors within the library or errors using</span>
01015 <span class="comment">// the library. Error is used to reprot all other errors. Since InternalErr</span>
01016 <span class="comment">// is a subclass of Error, programs need only to catch Error.</span>
01017 <span class="comment">//</span>
01018 <span class="comment">// Revision 1.40  2000/07/09 22:05:35  rmorris</span>
01019 <span class="comment">// Changes to increase portability, minimize ifdef's for win32 and account</span>
01020 <span class="comment">// for differences in the iostreams implementations.</span>
01021 <span class="comment">//</span>
01022 <span class="comment">// Revision 1.39  2000/06/16 18:14:59  jimg</span>
01023 <span class="comment">// Merged with 3.1.7</span>
01024 <span class="comment">//</span>
01025 <span class="comment">// Revision 1.37.6.1  2000/06/14 16:59:01  jimg</span>
01026 <span class="comment">// Added instrumentation for the dtor.</span>
01027 <span class="comment">//</span>
01028 <span class="comment">// Revision 1.38  2000/06/07 18:06:57  jimg</span>
01029 <span class="comment">// Merged the pc port branch</span>
01030 <span class="comment">//</span>
01031 <span class="comment">// Revision 1.37.20.1  2000/06/02 18:11:19  rmorris</span>
01032 <span class="comment">// Mod's for Port to Win32.</span>
01033 <span class="comment">//</span>
01034 <span class="comment">// Revision 1.37.14.2  2000/02/17 05:03:12  jimg</span>
01035 <span class="comment">// Added file and line number information to calls to InternalErr.</span>
01036 <span class="comment">// Resolved compile-time problems with read due to a change in its</span>
01037 <span class="comment">// parameter list given that errors are now reported using exceptions.</span>
01038 <span class="comment">//</span>
01039 <span class="comment">// Revision 1.37.14.1  2000/01/28 22:14:04  jgarcia</span>
01040 <span class="comment">// Added exception handling and modify add_var to get a copy of the object</span>
01041 <span class="comment">//</span>
01042 <span class="comment">// Revision 1.37  1999/05/04 19:47:20  jimg</span>
01043 <span class="comment">// Fixed copyright statements. Removed more of the GNU classes.</span>
01044 <span class="comment">//</span>
01045 <span class="comment">// Revision 1.36  1999/04/29 02:29:27  jimg</span>
01046 <span class="comment">// Merge of no-gnu branch</span>
01047 <span class="comment">//</span>
01048 <span class="comment">// Revision 1.35  1999/03/24 23:37:13  jimg</span>
01049 <span class="comment">// Added support for the Int16, UInt16 and Float32 types</span>
01050 <span class="comment">//</span>
01051 <span class="comment">// Revision 1.34 1998/10/21 16:18:19 jimg Added the two member functions:</span>
01052 <span class="comment">// synthesized_p() and set_synthesized_p(). These are used to test and record</span>
01053 <span class="comment">// (resp) whether a variable has been synthesized by the server or is part of</span>
01054 <span class="comment">// the data set. This feature was added to help support the creation of</span>
01055 <span class="comment">// variables by the new projection functions. Variables that are created by</span>
01056 <span class="comment">// projection function calls are called `synthesized variables'.</span>
01057 <span class="comment">//</span>
01058 <span class="comment">// Revision 1.33  1998/09/17 17:23:20  jimg</span>
01059 <span class="comment">// Changes for the new variable lookup scheme. Fields of ctor types no longer</span>
01060 <span class="comment">// need to be fully qualified. my.thing.f1 can now be named `f1' in a CE. Note</span>
01061 <span class="comment">// that if there are two `f1's in a dataset, the first will be silently used;</span>
01062 <span class="comment">// There's no warning about the situation. The new code in the var member</span>
01063 <span class="comment">// function passes a stack of BaseType pointers so that the projection</span>
01064 <span class="comment">// information (send_p field) can be set properly.</span>
01065 <span class="comment">//</span>
01066 <span class="comment">// Revision 1.32.6.1  1999/02/02 21:56:55  jimg</span>
01067 <span class="comment">// String to string version</span>
01068 <span class="comment">//</span>
01069 <span class="comment">// Revision 1.32  1998/03/19 23:20:05  jimg</span>
01070 <span class="comment">// Removed old code (that was surrounded by #if 0 ... #endif).</span>
01071 <span class="comment">//</span>
01072 <span class="comment">// Revision 1.31  1998/03/17 17:18:32  jimg</span>
01073 <span class="comment">// Added mfuncs element_count(), is_simple_type(), is_vector_type() and</span>
01074 <span class="comment">// is_comstructor_type().</span>
01075 <span class="comment">//</span>
01076 <span class="comment">// Revision 1.30  1997/03/08 19:01:55  jimg</span>
01077 <span class="comment">// Changed default param to check_semantics() from  to String()</span>
01078 <span class="comment">// and removed the default from the argument list in the mfunc definition</span>
01079 <span class="comment">//</span>
01080 <span class="comment">// Revision 1.29  1997/02/28 01:27:50  jimg</span>
01081 <span class="comment">// Changed check_semantics() so that it now returns error messages in a String</span>
01082 <span class="comment">// object (passed by reference).</span>
01083 <span class="comment">//</span>
01084 <span class="comment">// Revision 1.28  1996/12/02 23:10:02  jimg</span>
01085 <span class="comment">// Added dataset as a parameter to the ops member function.</span>
01086 <span class="comment">//</span>
01087 <span class="comment">// Revision 1.27  1996/10/28 23:43:55  jimg</span>
01088 <span class="comment">// Added UInt32 to type names returned by type_name() member function.</span>
01089 <span class="comment">//</span>
01090 <span class="comment">// Revision 1.26  1996/06/04 21:33:09  jimg</span>
01091 <span class="comment">// Multiple connections are now possible. It is now possible to open several</span>
01092 <span class="comment">// URLs at the same time and read from them in a round-robin fashion. To do</span>
01093 <span class="comment">// this I added data source and sink parameters to the serialize and</span>
01094 <span class="comment">// deserialize mfuncs. Connect was also modified so that it manages the data</span>
01095 <span class="comment">// source `object' (which is just an XDR pointer).</span>
01096 <span class="comment">//</span>
01097 <span class="comment">// Revision 1.25  1996/05/31 23:29:24  jimg</span>
01098 <span class="comment">// Updated copyright notice.</span>
01099 <span class="comment">//</span>
01100 <span class="comment">// Revision 1.24  1996/05/30 17:17:14  jimg</span>
01101 <span class="comment">// Added read_p and send_p to the set of members copied by _duplicate(). From</span>
01102 <span class="comment">// Reza.</span>
01103 <span class="comment">//</span>
01104 <span class="comment">// Revision 1.23  1996/05/14 15:38:14  jimg</span>
01105 <span class="comment">// These changes have already been checked in once before. However, I</span>
01106 <span class="comment">// corrupted the source repository and restored it from a 5/9/96 backup</span>
01107 <span class="comment">// tape. The previous version's log entry should cover the changes.</span>
01108 <span class="comment">//</span>
01109 <span class="comment">// Revision 1.22  1996/04/05 00:21:21  jimg</span>
01110 <span class="comment">// Compiled with g++ -Wall and fixed various warnings.</span>
01111 <span class="comment">//</span>
01112 <span class="comment">// Revision 1.21  1996/04/04 19:18:32  jimg</span>
01113 <span class="comment">// Merged changes from version 1.1.1.</span>
01114 <span class="comment">//</span>
01115 <span class="comment">// Revision 1.20  1996/03/05 18:45:29  jimg</span>
01116 <span class="comment">// Added ops member function.</span>
01117 <span class="comment">//</span>
01118 <span class="comment">// Revision 1.19  1995/12/06  21:49:53  jimg</span>
01119 <span class="comment">// var(): now returns null for anything that does not define its own version.</span>
01120 <span class="comment">// print_decl(): uses `constrained' flag.</span>
01121 <span class="comment">//</span>
01122 <span class="comment">// Revision 1.18  1995/10/23  23:20:47  jimg</span>
01123 <span class="comment">// Added _send_p and _read_p fields (and their accessors) along with the</span>
01124 <span class="comment">// virtual mfuncs set_send_p() and set_read_p().</span>
01125 <span class="comment">//</span>
01126 <span class="comment">// Revision 1.17  1995/08/26  00:31:24  jimg</span>
01127 <span class="comment">// Removed code enclosed in #ifdef NEVER #endif.</span>
01128 <span class="comment">//</span>
01129 <span class="comment">// Revision 1.16  1995/08/23  00:04:45  jimg</span>
01130 <span class="comment">// Switched from String representation of data type to Type enum.</span>
01131 <span class="comment">// Added type_name() member function so that it is simple to get the string</span>
01132 <span class="comment">// representation of a variable's type.</span>
01133 <span class="comment">// Changed the name of read_val/store_val to buf2val/val2buf.</span>
01134 <span class="comment">//</span>
01135 <span class="comment">// Revision 1.15.2.2  1996/03/01 00:06:07  jimg</span>
01136 <span class="comment">// Removed bad attempt at multiple connect implementation.</span>
01137 <span class="comment">//</span>
01138 <span class="comment">// Revision 1.15.2.1  1996/02/23 21:37:21  jimg</span>
01139 <span class="comment">// Updated for new configure.in.</span>
01140 <span class="comment">// Fixed problems on Solaris 2.4.</span>
01141 <span class="comment">//</span>
01142 <span class="comment">// Revision 1.15  1995/07/09  21:28:52  jimg</span>
01143 <span class="comment">// Added copyright notice.</span>
01144 <span class="comment">//</span>
01145 <span class="comment">// Revision 1.14  1995/05/10  15:33:54  jimg</span>
01146 <span class="comment">// Failed to change `config.h' to `config_dap.h' in these files.</span>
01147 <span class="comment">//</span>
01148 <span class="comment">// Revision 1.13  1995/05/10  13:45:06  jimg</span>
01149 <span class="comment">// Changed the name of the configuration header file from `config.h' to</span>
01150 <span class="comment">// `config_dap.h' so that other libraries could have header files which were</span>
01151 <span class="comment">// installed in the DODS include directory without overwriting this one. Each</span>
01152 <span class="comment">// config header should follow the convention config_&lt;name&gt;.h.</span>
01153 <span class="comment">//</span>
01154 <span class="comment">// Revision 1.12  1995/03/16  17:26:36  jimg</span>
01155 <span class="comment">// Moved include of config_dap.h to top of includes.</span>
01156 <span class="comment">// Added TRACE_NEW switched dbnew debugging includes.</span>
01157 <span class="comment">//</span>
01158 <span class="comment">// Revision 1.11  1995/02/16  22:46:00  jimg</span>
01159 <span class="comment">// Added _in private member. It is used to keep a copy of the input FILE *</span>
01160 <span class="comment">// so that when the next chunk of data is read in the previous one can be</span>
01161 <span class="comment">// closed. Since the netio library unlinks the tmp file before returning</span>
01162 <span class="comment">// the FILE *, closing it effectively deletes the tmp file.</span>
01163 <span class="comment">//</span>
01164 <span class="comment">// Revision 1.10  1995/02/10  02:41:56  jimg</span>
01165 <span class="comment">// Added new mfuncs to access _name and _type.</span>
01166 <span class="comment">// Made private and protected filed's names start with `_'.</span>
01167 <span class="comment">// Added store_val() as a abstract virtual mfunc.</span>
01168 <span class="comment">//</span>
01169 <span class="comment">// Revision 1.9  1995/01/18  18:33:25  dan</span>
01170 <span class="comment">// Added external declarations for utility functions, new_xdrstdio and</span>
01171 <span class="comment">// delete_xdrstdio.</span>
01172 <span class="comment">//</span>
01173 <span class="comment">// Revision 1.8  1995/01/11  16:06:47  jimg</span>
01174 <span class="comment">// Added static XDR pointers to BaseType class and removed the XDR pointers</span>
01175 <span class="comment">// that were class members - now there is only one xdrin and one xdrout</span>
01176 <span class="comment">// for all children of BaseType.</span>
01177 <span class="comment">// Added friend functions to help in setting the FILE * associated with</span>
01178 <span class="comment">// the XDR *s.</span>
01179 <span class="comment">// Removed FILE *in member (but FILE *out was kept as FILE * _out, mfunc</span>
01180 <span class="comment">// expunge()).</span>
01181 <span class="comment">// Changed ctor so that it no longer takes FILE * params.</span>
01182 <span class="comment">//</span>
01183 <span class="comment">// Revision 1.7  1994/12/16  22:01:42  jimg</span>
01184 <span class="comment">// Added mfuncs var() and add_var() to BaseType. These print an error</span>
01185 <span class="comment">// message when called with a simple BaseType (Int32, ...). Classes like</span>
01186 <span class="comment">// Array use them and provide their own definitions.</span>
01187 <span class="comment">//</span>
01188 <span class="comment">// Revision 1.6  1994/11/29  19:59:01  jimg</span>
01189 <span class="comment">// Added FILE * input and output buffers. All data set and all data received</span>
01190 <span class="comment">// passes through these buffers. This simplifies testing and makes using</span>
01191 <span class="comment">// the toolkit with files a little easier.</span>
01192 <span class="comment">// Added xdrin and xdrout members (both are XDR *). These are the source and</span>
01193 <span class="comment">// sink for xdr data.</span>
01194 <span class="comment">// Modified ctor and duplicate() to correctly handle xdrin/out.</span>
01195 <span class="comment">// Added expunge() which flushes the output buffer.</span>
01196 <span class="comment">//</span>
01197 <span class="comment">// Revision 1.5  1994/11/22  14:05:26  jimg</span>
01198 <span class="comment">// Added code for data transmission to parts of the type hierarchy. Not</span>
01199 <span class="comment">// complete yet.</span>
01200 <span class="comment">// Fixed erros in type hierarchy headers (typos, incorrect comments, ...).</span>
01201 <span class="comment">//</span>
01202 <span class="comment">// Revision 1.4  1994/10/17  23:30:46  jimg</span>
01203 <span class="comment">// Added ptr_duplicate virtual mfunc. Child classes can also define this</span>
01204 <span class="comment">// to copy parts that BaseType does not have (and allocate correctly sized</span>
01205 <span class="comment">// pointers.</span>
01206 <span class="comment">// Removed protected mfunc error() -- use errmsg library instead.</span>
01207 <span class="comment">// Added formatted printing of types (works with DDS::print()).</span>
01208 <span class="comment">//</span>
01209 <span class="comment">// Revision 1.3  1994/09/23  14:34:42  jimg</span>
01210 <span class="comment">// Added mfunc check_semantics().</span>
01211 <span class="comment">// Moved definition of dtor to BaseType.cc.</span>
01212 <span class="comment">//</span>
01213 <span class="comment">// Revision 1.2  1994/09/15  21:08:36  jimg</span>
01214 <span class="comment">// Added many classes to the BaseType hierarchy - the complete set of types</span>
01215 <span class="comment">// described in the DODS API design documet is now represented.</span>
01216 <span class="comment">// The parser can parse DDS files.</span>
01217 <span class="comment">// Fixed many small problems with BaseType.</span>
01218 <span class="comment">// Added CtorType.</span>
01219 <span class="comment">//</span>
01220 <span class="comment">// Revision 1.1  1994/09/09  15:28:41  jimg</span>
01221 <span class="comment">// Class for base type variables. Int32, ... inherit from this class.</span>
01222 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Feb 4 23:42:56 2004 for libdap++ by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
