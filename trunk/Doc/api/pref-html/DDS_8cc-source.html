<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libdap++: DDS.cc Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>DDS.cc</h1><a href="DDS_8cc.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00002 <span class="comment">// -*- mode: c++; c-basic-offset:4 -*-</span>
00003 
00004 <span class="comment">// This file is part of libdap, A C++ implementation of the OPeNDAP Data</span>
00005 <span class="comment">// Access Protocol.</span>
00006 
00007 <span class="comment">// Copyright (c) 2002,2003 OPeNDAP, Inc.</span>
00008 <span class="comment">// Author: James Gallagher &lt;jgallagher@opendap.org&gt;</span>
00009 <span class="comment">//</span>
00010 <span class="comment">// This library is free software; you can redistribute it and/or</span>
00011 <span class="comment">// modify it under the terms of the GNU Lesser General Public</span>
00012 <span class="comment">// License as published by the Free Software Foundation; either</span>
00013 <span class="comment">// version 2.1 of the License, or (at your option) any later version.</span>
00014 <span class="comment">// </span>
00015 <span class="comment">// This library is distributed in the hope that it will be useful,</span>
00016 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00017 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00018 <span class="comment">// Lesser General Public License for more details.</span>
00019 <span class="comment">// </span>
00020 <span class="comment">// You should have received a copy of the GNU Lesser General Public</span>
00021 <span class="comment">// License along with this library; if not, write to the Free Software</span>
00022 <span class="comment">// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00023 <span class="comment">//</span>
00024 <span class="comment">// You can contact OPeNDAP, Inc. at PO Box 112, Saunderstown, RI. 02874-0112.</span>
00025  
00026 <span class="comment">// (c) COPYRIGHT URI/MIT 1994-1999</span>
00027 <span class="comment">// Please read the full copyright statement in the file COPYRIGHT_URI.</span>
00028 <span class="comment">//</span>
00029 <span class="comment">// Authors:</span>
00030 <span class="comment">//      jhrg,jimg       James Gallagher &lt;jgallagher@gso.uri.edu&gt;</span>
00031 
00032 <span class="comment">//</span>
00033 <span class="comment">// jhrg 9/7/94</span>
00034 
00035 <span class="preprocessor">#include "<a class="code" href="config__dap_8h.html">config_dap.h</a>"</span>
00036 
00037 <span class="keyword">static</span> <span class="keywordtype">char</span> rcsid[] <a class="code" href="config__dap_8h.html#a49">not_used</a> = {<span class="stringliteral">"$Id$"</span>};
00038 
00039 <span class="preprocessor">#ifdef __GNUG__</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#pragma implementation</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00042 <span class="preprocessor"></span>
00043 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00044 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00045 
00046 <span class="preprocessor">#ifdef WIN32</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#include &lt;io.h&gt;</span>
00048 <span class="preprocessor">#include &lt;process.h&gt;</span>
00049 <span class="preprocessor">#include &lt;fstream&gt;</span>
00050 <span class="preprocessor">#else</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#include &lt;unistd.h&gt;</span>
00052 <span class="preprocessor">#include &lt;sys/wait.h&gt;</span>
00053 <span class="preprocessor">#endif</span>
00054 <span class="preprocessor"></span>
00055 <span class="preprocessor">#include &lt;iostream&gt;</span>
00056 
00057 <span class="comment">// #define DODS_DEBUG</span>
00058 
00059 <span class="preprocessor">#include "expr.h"</span>
00060 <span class="preprocessor">#include "<a class="code" href="Clause_8h.html">Clause.h</a>"</span>
00061 <span class="preprocessor">#include "<a class="code" href="DDS_8h.html">DDS.h</a>"</span>
00062 <span class="preprocessor">#include "<a class="code" href="Error_8h.html">Error.h</a>"</span>
00063 <span class="preprocessor">#include "<a class="code" href="parser_8h.html">parser.h</a>"</span>
00064 <span class="preprocessor">#include "<a class="code" href="debug_8h.html">debug.h</a>"</span>
00065 <span class="preprocessor">#include "<a class="code" href="util_8h.html">util.h</a>"</span>
00066 <span class="preprocessor">#include "<a class="code" href="escaping_8h.html">escaping.h</a>"</span>
00067 <span class="preprocessor">#include "<a class="code" href="ce__functions_8h.html">ce_functions.h</a>"</span>
00068 <span class="preprocessor">#include "<a class="code" href="cgi__util_8h.html">cgi_util.h</a>"</span>
00069 <span class="preprocessor">#include "<a class="code" href="InternalErr_8h.html">InternalErr.h</a>"</span>
00070 <span class="preprocessor">#include "<a class="code" href="BTIterAdapter_8h.html">BTIterAdapter.h</a>"</span>
00071 <span class="preprocessor">#include "<a class="code" href="ClauseIterAdapter_8h.html">ClauseIterAdapter.h</a>"</span>
00072 
00073 <span class="preprocessor">#ifdef TRACE_NEW</span>
00074 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="trace__new_8h.html">trace_new.h</a>"</span>
00075 <span class="preprocessor">#endif</span>
00076 <span class="preprocessor"></span>
00077 <span class="keyword">using</span> std::cerr;
00078 <span class="keyword">using</span> std::endl;
00079 <span class="keyword">using</span> std::ofstream;
00080 
00081 <span class="keywordtype">void</span> <a class="code" href="DDS_8cc.html#a1">ddsrestart</a>(FILE *yyin);    <span class="comment">// Defined in dds.tab.c</span>
00082 <span class="keywordtype">int</span> <a class="code" href="DDS_8cc.html#a2">ddsparse</a>(<span class="keywordtype">void</span> *arg);
00083 
00084 <span class="keyword">struct </span>yy_buffer_state;
00085 yy_buffer_state *<a class="code" href="DDS_8cc.html#a3">expr_scan_string</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *str);
00086 <span class="keywordtype">int</span> <a class="code" href="expr-test_8cc.html#a18">exprparse</a>(<span class="keywordtype">void</span> *arg);
00087 
00088 <span class="comment">// Glue routines declared in expr.lex</span>
00089 <span class="keywordtype">void</span> <a class="code" href="expr-test_8cc.html#a20">expr_switch_to_buffer</a>(<span class="keywordtype">void</span> *new_buffer);
00090 <span class="keywordtype">void</span> <a class="code" href="expr-test_8cc.html#a21">expr_delete_buffer</a>(<span class="keywordtype">void</span> * buffer);
00091 <span class="keywordtype">void</span> *<a class="code" href="expr-test_8cc.html#a22">expr_string</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *yy_str);
00092 
00093 <span class="comment">// Glue for the DDS parser defined in dds.lex</span>
00094 <span class="keywordtype">void</span> <a class="code" href="DDS_8cc.html#a8">dds_switch_to_buffer</a>(<span class="keywordtype">void</span> *new_buffer);
00095 <span class="keywordtype">void</span> <a class="code" href="DDS_8cc.html#a9">dds_delete_buffer</a>(<span class="keywordtype">void</span> * buffer);
00096 <span class="keywordtype">void</span> *<a class="code" href="DDS_8cc.html#a10">dds_buffer</a>(FILE *fp);
00097 
00098 <span class="comment">// Copy the stuff in DDS to THIS. The mfunc returns void because THIS gets</span>
00099 <span class="comment">// the `result' of the mfunc.</span>
00100 <span class="comment">//</span>
00101 <span class="comment">// NB: This can't define the formal param to be const since SLList&lt;&gt;first()</span>
00102 <span class="comment">// (which is what DDS::first_var() calls) does not define THIS to be const.</span>
00103 
00104 <span class="keywordtype">void</span>
<a name="l00105"></a><a class="code" href="classDDS.html#DDSb0">00105</a> <a class="code" href="classDDS.html#DDSb0">DDS::duplicate</a>(<span class="keyword">const</span> <a class="code" href="classDDS.html">DDS</a> &amp;dds)
00106 {
00107     name = dds.<a class="code" href="classDDS.html#DDSr0">name</a>;
00108 
00109     <a class="code" href="classDDS.html">DDS</a> &amp;dds_tmp = const_cast&lt;DDS &amp;&gt;(dds);
00110 
00111     <span class="comment">// copy the things pointed to by the list, not just the pointers</span>
00112     <span class="keywordflow">for</span> (<a class="code" href="classDDS.html#DDSw1">Vars_iter</a> i = dds_tmp.<a class="code" href="classDDS.html#DDSa13">var_begin</a>(); i != dds_tmp.<a class="code" href="classDDS.html#DDSa14">var_end</a>(); i++)
00113     {
00114     <a class="code" href="classDDS.html#DDSa4">add_var</a>(*i); <span class="comment">// add_var() dups the BaseType.</span>
00115     }
00116 }
00117 
<a name="l00119"></a><a class="code" href="classDDS.html#DDSa0">00119</a> <a class="code" href="classDDS.html#DDSa0">DDS::DDS</a>(<span class="keyword">const</span> string &amp;n) : name(n), d_timeout(0)
00120 {
00121     <a class="code" href="classDDS.html#DDSz25_0">add_function</a>(<span class="stringliteral">"member"</span>, <a class="code" href="ce__functions_8cc.html#a7">func_member</a>);
00122     <a class="code" href="classDDS.html#DDSz25_0">add_function</a>(<span class="stringliteral">"null"</span>, <a class="code" href="ce__functions_8cc.html#a8">func_null</a>);
00123     <a class="code" href="classDDS.html#DDSz25_0">add_function</a>(<span class="stringliteral">"nth"</span>, <a class="code" href="ce__functions_8cc.html#a10">func_nth</a>);
00124     <a class="code" href="classDDS.html#DDSz25_0">add_function</a>(<span class="stringliteral">"length"</span>, <a class="code" href="ce__functions_8cc.html#a9">func_length</a>);
00125     <a class="code" href="classDDS.html#DDSz25_0">add_function</a>(<span class="stringliteral">"grid"</span>, <a class="code" href="ce__functions_8cc.html#a12">func_grid_select</a>);
00126 }
00127 
<a name="l00129"></a><a class="code" href="classDDS.html#DDSa1">00129</a> <a class="code" href="classDDS.html#DDSa0">DDS::DDS</a>(<span class="keyword">const</span> <a class="code" href="classDDS.html">DDS</a> &amp;rhs)
00130 {
00131     <a class="code" href="classDDS.html#DDSb0">duplicate</a>(rhs);
00132 }
00133 
<a name="l00134"></a><a class="code" href="classDDS.html#DDSa2">00134</a> <a class="code" href="classDDS.html#DDSa2">DDS::~DDS</a>()
00135 {
00136     <span class="comment">// delete all the variables in this DDS</span>
00137     <span class="keywordflow">for</span> (<a class="code" href="classDDS.html#DDSw1">Vars_iter</a> i = vars.begin(); i != vars.end(); i++)
00138     {
00139     <a class="code" href="classBaseType.html">BaseType</a> *btp = *i ;
00140     <span class="keyword">delete</span> btp ;
00141     }
00142     
00143     <span class="comment">// delete all the constants created by the parser for CE evaluation</span>
00144     <span class="keywordflow">for</span> (<a class="code" href="classDDS.html#DDSw5">Constants_iter</a> j = constants.begin(); j != constants.end(); j++)
00145     {
00146     <a class="code" href="classBaseType.html">BaseType</a> *btp = *j ;
00147     <span class="keyword">delete</span> btp ;
00148     }
00149 
00150     <span class="keywordflow">if</span> (!expr.empty()) {
00151     <span class="keywordflow">for</span> (<a class="code" href="classDDS.html#DDSw3">Clause_iter</a> k = expr.begin(); k != expr.end(); k++)
00152     {
00153         <a class="code" href="structClause.html">Clause</a> *cp = *k ;
00154         <span class="keyword">delete</span> cp ;
00155     }
00156     }
00157 }
00158 
00159 <a class="code" href="classDDS.html">DDS</a> &amp;
<a name="l00160"></a><a class="code" href="classDDS.html#DDSa3">00160</a> <a class="code" href="classDDS.html#DDSa3">DDS::operator=</a>(<span class="keyword">const</span> <a class="code" href="classDDS.html">DDS</a> &amp;rhs)
00161 {
00162     <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;rhs)
00163     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00164 
00165     <a class="code" href="classDDS.html#DDSb0">duplicate</a>(rhs);
00166 
00167     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00168 }
00169 
00177       
00179 string 
<a name="l00180"></a><a class="code" href="classDDS.html#DDSz21_0">00180</a> <a class="code" href="classDDS.html#DDSz21_0">DDS::get_dataset_name</a>()
00181 { 
00182     <span class="keywordflow">return</span> name; 
00183 }
00184 
00186 <span class="keywordtype">void</span>
<a name="l00187"></a><a class="code" href="classDDS.html#DDSz21_1">00187</a> <a class="code" href="classDDS.html#DDSz21_1">DDS::set_dataset_name</a>(<span class="keyword">const</span> string &amp;n) 
00188 { 
00189     name = n; 
00190 }
00191 
00193 
00203 string
<a name="l00204"></a><a class="code" href="classDDS.html#DDSz23_0">00204</a> <a class="code" href="classDDS.html#DDSz23_0">DDS::filename</a>()
00205 {
00206     <span class="keywordflow">return</span> _filename;
00207 }
00208 
00210 <span class="keywordtype">void</span>
<a name="l00211"></a><a class="code" href="classDDS.html#DDSz23_1">00211</a> <a class="code" href="classDDS.html#DDSz23_0">DDS::filename</a>(<span class="keyword">const</span> string &amp;fn)
00212 {
00213     _filename = fn;
00214 }
00216 
00218 <span class="keywordtype">void</span>
<a name="l00219"></a><a class="code" href="classDDS.html#DDSa4">00219</a> <a class="code" href="classDDS.html#DDSa4">DDS::add_var</a>(<a class="code" href="classBaseType.html">BaseType</a> *bt)
00220 { 
00221     <span class="keywordflow">if</span>(!bt)
00222     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, 
00223           <span class="stringliteral">"Trying to add a BaseType object with a NULL pointer."</span>);
00224 
00225     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"In DDS::add_var(), bt's addres is: "</span> &lt;&lt; bt &lt;&lt; endl);
00226 
00227     <a class="code" href="classBaseType.html">BaseType</a> *btp = bt-&gt;<a class="code" href="classBaseType.html#Constructora6">ptr_duplicate</a>();
00228     vars.push_back(btp);
00229 }
00230 
00232 <span class="keywordtype">void</span> 
<a name="l00233"></a><a class="code" href="classDDS.html#DDSa5">00233</a> <a class="code" href="classDDS.html#DDSa5">DDS::del_var</a>(<span class="keyword">const</span> string &amp;n)
00234 { 
00235     <span class="keywordflow">for</span> (<a class="code" href="classDDS.html#DDSw1">Vars_iter</a> i = vars.begin(); i != vars.end(); i++)
00236     {
00237     <span class="keywordflow">if</span> ((*i)-&gt;name() == n) {
00238         <a class="code" href="classBaseType.html">BaseType</a> *bt = *i ;
00239         vars.erase(i) ;
00240         <span class="keyword">delete</span> bt ;
00241         <span class="keywordflow">return</span>;
00242     }
00243     }
00244 }
00245 
00246 <span class="keywordtype">void</span>
<a name="l00247"></a><a class="code" href="classDDS.html#DDSa16">00247</a> <a class="code" href="classDDS.html#DDSa5">DDS::del_var</a>(<a class="code" href="classDDS.html#DDSw1">Vars_iter</a> &amp;i)
00248 {
00249     <span class="keywordflow">if</span>( i != vars.end() )
00250     {
00251     <a class="code" href="classBaseType.html">BaseType</a> *bt = *i ;
00252     vars.erase(i) ;
00253     <span class="keyword">delete</span> bt ;
00254     }
00255 }
00256 
00257 <span class="keywordtype">void</span>
<a name="l00258"></a><a class="code" href="classDDS.html#DDSa17">00258</a> <a class="code" href="classDDS.html#DDSa5">DDS::del_var</a>(<a class="code" href="classDDS.html#DDSw1">Vars_iter</a> &amp;i1, <a class="code" href="classDDS.html#DDSw1">Vars_iter</a> &amp;i2)
00259 {
00260     <span class="keywordflow">for</span>( <a class="code" href="classDDS.html#DDSw1">Vars_iter</a> i_tmp = i1; i_tmp != i2; i_tmp++ )
00261     {
00262     <a class="code" href="classBaseType.html">BaseType</a> *bt = *i_tmp ;
00263     <span class="keyword">delete</span> bt ;
00264     }
00265     vars.erase(i1, i2) ;
00266 }
00267 
00275 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00276"></a><a class="code" href="classDDS.html#DDSa6">00276</a> <a class="code" href="classDDS.html#DDSa6">DDS::var</a>(<span class="keyword">const</span> string &amp;n, <a class="code" href="BaseType_8h.html#a1">btp_stack</a> &amp;s)
00277 {
00278     <span class="keywordflow">return</span> <a class="code" href="classDDS.html#DDSa6">var</a>(n, &amp;s);
00279 }    
00280 
00292 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00293"></a><a class="code" href="classDDS.html#DDSa8">00293</a> <a class="code" href="classDDS.html#DDSa6">DDS::var</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *n, <a class="code" href="BaseType_8h.html#a1">btp_stack</a> *s)
00294 {
00295     <span class="keywordflow">return</span> <a class="code" href="classDDS.html#DDSa6">var</a>((string)n, s);
00296 }
00297 
00313 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00314"></a><a class="code" href="classDDS.html#DDSa7">00314</a> <a class="code" href="classDDS.html#DDSa6">DDS::var</a>(<span class="keyword">const</span> string &amp;n, <a class="code" href="BaseType_8h.html#a1">btp_stack</a> *s)
00315 {
00316     string name = <a class="code" href="escaping_8cc.html#a7">www2id</a>(n);
00317     <a class="code" href="classBaseType.html">BaseType</a> *v = <a class="code" href="classDDS.html#DDSb2">exact_match</a>(name, s);
00318     <span class="keywordflow">if</span> (v)
00319     <span class="keywordflow">return</span> v;
00320 
00321     <span class="keywordflow">return</span> <a class="code" href="classDDS.html#DDSb1">leaf_match</a>(name, s);
00322 }
00323 
00324 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00325"></a><a class="code" href="classDDS.html#DDSb1">00325</a> <a class="code" href="classDDS.html#DDSb1">DDS::leaf_match</a>(<span class="keyword">const</span> string &amp;n, <a class="code" href="BaseType_8h.html#a1">btp_stack</a> *s) 
00326 {
00327     <span class="keywordflow">for</span> (<a class="code" href="classDDS.html#DDSw1">Vars_iter</a> i = vars.begin(); i != vars.end(); i++) {
00328     <a class="code" href="classBaseType.html">BaseType</a> *btp = *i;
00329     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Looking at "</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">" in: "</span> &lt;&lt; btp &lt;&lt; endl);
00330     <span class="comment">// Look for the name in the dataset's top-level</span>
00331     <span class="keywordflow">if</span> (btp-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>() == n) {
00332         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Found "</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">" in: "</span> &lt;&lt; btp &lt;&lt; endl);
00333         <span class="keywordflow">return</span> btp;
00334     }
00335     <span class="keywordflow">if</span> (btp-&gt;<a class="code" href="classBaseType.html#Vectora34">is_constructor_type</a>() &amp;&amp; (btp = btp-&gt;<a class="code" href="classBaseType.html#Vectora44">var</a>(n, <span class="keyword">false</span>, s))) {
00336         <span class="keywordflow">return</span> btp;
00337     }
00338     }
00339 
00340     <span class="keywordflow">return</span> 0;           <span class="comment">// It is not here.</span>
00341 }
00342 
00343 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00344"></a><a class="code" href="classDDS.html#DDSb2">00344</a> <a class="code" href="classDDS.html#DDSb2">DDS::exact_match</a>(<span class="keyword">const</span> string &amp;name, <a class="code" href="BaseType_8h.html#a1">btp_stack</a> *s)
00345 {
00346     <span class="keywordflow">for</span> (<a class="code" href="classDDS.html#DDSw1">Vars_iter</a> i = vars.begin(); i != vars.end(); i++) {
00347     <a class="code" href="classBaseType.html">BaseType</a> *btp = *i;
00348     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Looking for "</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">" in: "</span> &lt;&lt; btp &lt;&lt; endl);
00349     <span class="comment">// Look for the name in the current ctor type or the top level</span>
00350     <span class="keywordflow">if</span> (btp-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>() == name) {
00351         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Found "</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">" in: "</span> &lt;&lt; btp &lt;&lt; endl);
00352         <span class="keywordflow">return</span> btp;
00353     }
00354     }
00355 
00356     string::size_type dot_pos = name.find(<span class="stringliteral">"."</span>);
00357     <span class="keywordflow">if</span> (dot_pos != string::npos) {
00358     string aggregate = name.substr(0, dot_pos);
00359     string field = name.substr(dot_pos + 1);
00360 
00361     <a class="code" href="classBaseType.html">BaseType</a> *agg_ptr = <a class="code" href="classDDS.html#DDSa6">var</a>(aggregate, s);
00362     <span class="keywordflow">if</span> (agg_ptr) {
00363         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Descending into "</span> &lt;&lt; agg_ptr-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>() &lt;&lt; endl);
00364         <span class="keywordflow">return</span> agg_ptr-&gt;<a class="code" href="classBaseType.html#Vectora44">var</a>(field, <span class="keyword">true</span>, s);
00365     }
00366     <span class="keywordflow">else</span>
00367         <span class="keywordflow">return</span> 0;       <span class="comment">// qualified names must be *fully* qualified</span>
00368     }
00369 
00370     <span class="keywordflow">return</span> 0;           <span class="comment">// It is not here.</span>
00371 }
00372 
00373 
00375 Pix 
<a name="l00376"></a><a class="code" href="classDDS.html#DDSa10">00376</a> <a class="code" href="classDDS.html#DDSa10">DDS::first_var</a>()
00377 {
00378     <a class="code" href="classBTIterAdapter.html">BTIterAdapter</a> *i = <span class="keyword">new</span> <a class="code" href="classBTIterAdapter.html">BTIterAdapter</a>( vars ) ;
00379     i-&gt;<a class="code" href="classBTIterAdapter.html#BTIterAdapterz62_0">first</a>();
00380     <span class="keywordflow">return</span> i;
00381 }
00382 
00383 <a class="code" href="classDDS.html#DDSw1">DDS::Vars_iter</a>
<a name="l00384"></a><a class="code" href="classDDS.html#DDSa13">00384</a> <a class="code" href="classDDS.html#DDSa13">DDS::var_begin</a>()
00385 {
00386     <span class="keywordflow">return</span> vars.begin();
00387 }
00388 
00389 <a class="code" href="classDDS.html#DDSw1">DDS::Vars_iter</a>
<a name="l00390"></a><a class="code" href="classDDS.html#DDSa14">00390</a> <a class="code" href="classDDS.html#DDSa14">DDS::var_end</a>()
00391 {
00392     <span class="keywordflow">return</span> vars.end() ;
00393 }
00394 
00398 <a class="code" href="classDDS.html#DDSw1">DDS::Vars_iter</a>
<a name="l00399"></a><a class="code" href="classDDS.html#DDSa15">00399</a> <a class="code" href="classDDS.html#DDSa15">DDS::get_vars_iter</a>(<span class="keywordtype">int</span> i)
00400 {
00401     <span class="keywordflow">return</span> vars.begin() + i;
00402 }
00403 
00406 <span class="keywordtype">void</span> 
<a name="l00407"></a><a class="code" href="classDDS.html#DDSa11">00407</a> <a class="code" href="classDDS.html#DDSa11">DDS::next_var</a>(Pix p)
00408 { 
00409     p.next() ;
00410 }
00411 
00413 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00414"></a><a class="code" href="classDDS.html#DDSa9">00414</a> <a class="code" href="classDDS.html#DDSa6">DDS::var</a>(Pix p)
00415 {
00416     <a class="code" href="classBTIterAdapter.html">BTIterAdapter</a> *i = (<a class="code" href="classBTIterAdapter.html">BTIterAdapter</a> *)p.getIterator() ;
00417     <span class="keywordflow">if</span>( i ) {
00418     <span class="keywordflow">return</span> i-&gt;<a class="code" href="classBTIterAdapter.html#BTIterAdapterz64_0">entry</a>() ;
00419     }
00420     <span class="keywordflow">return</span> 0 ;
00421 }
00422 
00424 <span class="keywordtype">int</span>
<a name="l00425"></a><a class="code" href="classDDS.html#DDSa12">00425</a> <a class="code" href="classDDS.html#DDSa12">DDS::num_var</a>()
00426 {
00427     <span class="keywordflow">return</span> vars.size();
00428 }
00429 
00431 
00432 <span class="keywordtype">void</span>
<a name="l00433"></a><a class="code" href="classDDS.html#DDSa18">00433</a> <a class="code" href="classDDS.html#DDSa18">DDS::timeout_on</a>()
00434 {
00435 <span class="preprocessor">#ifndef WIN32</span>
00436 <span class="preprocessor"></span>    alarm(d_timeout);
00437 <span class="preprocessor">#endif</span>
00438 <span class="preprocessor"></span>}
00439 
00440 <span class="keywordtype">void</span> 
<a name="l00441"></a><a class="code" href="classDDS.html#DDSa19">00441</a> <a class="code" href="classDDS.html#DDSa19">DDS::timeout_off</a>()
00442 {
00443 <span class="preprocessor">#ifndef WIN32</span>
00444 <span class="preprocessor"></span>    d_timeout = alarm(0);
00445 <span class="preprocessor">#endif</span>
00446 <span class="preprocessor"></span>}
00447 
00448 <span class="keywordtype">void</span>
<a name="l00449"></a><a class="code" href="classDDS.html#DDSa20">00449</a> <a class="code" href="classDDS.html#DDSa20">DDS::set_timeout</a>(<span class="keywordtype">int</span> t)
00450 {
00451     <span class="comment">//  Has no effect under win32</span>
00452     d_timeout = t;
00453 }
00454 
00455 <span class="keywordtype">int</span>
<a name="l00456"></a><a class="code" href="classDDS.html#DDSa21">00456</a> <a class="code" href="classDDS.html#DDSa21">DDS::get_timeout</a>()
00457 {
00458     <span class="comment">//  Has to effect under win32</span>
00459     <span class="keywordflow">return</span> d_timeout;
00460 }
00461 
00464 Pix
<a name="l00465"></a><a class="code" href="classDDS.html#DDSa22">00465</a> <a class="code" href="classDDS.html#DDSa22">DDS::first_clause</a>()
00466 {
00467     <span class="keywordflow">if</span>(expr.empty())
00468     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, 
00469               <span class="stringliteral">"There are no CE clauses for *this* DDS object."</span>);
00470 
00471     <a class="code" href="classClauseIterAdapter.html">ClauseIterAdapter</a> *i = <span class="keyword">new</span> <a class="code" href="classClauseIterAdapter.html">ClauseIterAdapter</a>( expr ) ;
00472 
00473     i-&gt;<a class="code" href="classClauseIterAdapter.html#ClauseIterAdapterz70_0">first</a>() ;
00474     <span class="keywordflow">return</span> i ;
00475 }
00476 
00477 <a class="code" href="classDDS.html#DDSw3">DDS::Clause_iter</a>
<a name="l00478"></a><a class="code" href="classDDS.html#DDSa33">00478</a> <a class="code" href="classDDS.html#DDSa33">DDS::clause_begin</a>()
00479 {
00480     <span class="keywordflow">return</span> expr.begin() ;
00481 }
00482 
00483 <a class="code" href="classDDS.html#DDSw3">DDS::Clause_iter</a>
<a name="l00484"></a><a class="code" href="classDDS.html#DDSa34">00484</a> <a class="code" href="classDDS.html#DDSa34">DDS::clause_end</a>()
00485 {
00486     <span class="keywordflow">return</span> expr.end() ;
00487 }
00488 
00491 <span class="keywordtype">void</span>
<a name="l00492"></a><a class="code" href="classDDS.html#DDSa23">00492</a> <a class="code" href="classDDS.html#DDSa23">DDS::next_clause</a>(Pix p)
00493 {
00494     <span class="keywordflow">if</span>(expr.empty())
00495     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, 
00496               <span class="stringliteral">"There are no CE clauses for *this* DDS object."</span>);
00497     p.next() ;
00498 }
00499 
00503 <a class="code" href="structClause.html">Clause</a> *
<a name="l00504"></a><a class="code" href="classDDS.html#DDSa24">00504</a> <a class="code" href="classDDS.html#DDSa24">DDS::clause</a>(Pix p)
00505 {
00506     <span class="keywordflow">if</span>(expr.empty())
00507     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, 
00508               <span class="stringliteral">"There are no CE clauses for *this* DDS object."</span>);
00509     <a class="code" href="classClauseIterAdapter.html">ClauseIterAdapter</a> *i = (<a class="code" href="classClauseIterAdapter.html">ClauseIterAdapter</a> *)p.getIterator() ;
00510     <span class="keywordflow">if</span>( !i )
00511     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, 
00512              <span class="stringliteral">"No ClauseIterAdapter defined for *this* DDS object."</span>);
00513 
00514     <span class="keywordflow">return</span> i-&gt;<a class="code" href="classClauseIterAdapter.html#ClauseIterAdapterz72_0">entry</a>() ;
00515 }
00516 
00519 <span class="keywordtype">bool</span>
<a name="l00520"></a><a class="code" href="classDDS.html#DDSa25">00520</a> <a class="code" href="classDDS.html#DDSa25">DDS::clause_value</a>(Pix p, <span class="keyword">const</span> string &amp;dataset)
00521 {
00522     <span class="keywordflow">if</span>(expr.empty())
00523     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, 
00524               <span class="stringliteral">"There are no CE clauses for *this* DDS object."</span>);
00525 
00526     <a class="code" href="classClauseIterAdapter.html">ClauseIterAdapter</a> *i = (<a class="code" href="classClauseIterAdapter.html">ClauseIterAdapter</a> *)p.getIterator() ;
00527     <span class="keywordflow">if</span>( !i )
00528     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, 
00529              <span class="stringliteral">"No ClauseIterAdapter defined for *this* DDS object."</span>);
00530 
00531     <span class="keywordflow">return</span> i-&gt;<a class="code" href="classClauseIterAdapter.html#ClauseIterAdapterz72_0">entry</a>()-&gt;<a class="code" href="structClause.html#Clausea8">value</a>(dataset, *<span class="keyword">this</span>);
00532 }
00533 
00534 <span class="keywordtype">bool</span>
<a name="l00535"></a><a class="code" href="classDDS.html#DDSa35">00535</a> <a class="code" href="classDDS.html#DDSa25">DDS::clause_value</a>(<a class="code" href="classDDS.html#DDSw3">Clause_iter</a> &amp;iter, <span class="keyword">const</span> string &amp;dataset)
00536 {
00537     <span class="keywordflow">if</span>(expr.empty())
00538     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, 
00539               <span class="stringliteral">"There are no CE clauses for *this* DDS object."</span>);
00540 
00541     <span class="keywordflow">return</span> (*iter)-&gt;value(dataset, *<span class="keyword">this</span>);
00542 }
00543 
00556 <span class="keywordtype">void</span>
<a name="l00557"></a><a class="code" href="classDDS.html#DDSa26">00557</a> <a class="code" href="classDDS.html#DDSa26">DDS::append_clause</a>(<span class="keywordtype">int</span> op, <a class="code" href="classrvalue.html">rvalue</a> *arg1, <a class="code" href="RValue_8h.html#a0">rvalue_list</a> *arg2)
00558 {
00559     <a class="code" href="structClause.html">Clause</a> *<a class="code" href="classDDS.html#DDSa24">clause</a> = <span class="keyword">new</span> <a class="code" href="structClause.html">Clause</a>(op, arg1, arg2);
00560 
00561     expr.push_back(clause);
00562 }
00563 
00573 <span class="keywordtype">void</span>
<a name="l00574"></a><a class="code" href="classDDS.html#DDSa27">00574</a> <a class="code" href="classDDS.html#DDSa26">DDS::append_clause</a>(bool_func func, <a class="code" href="RValue_8h.html#a0">rvalue_list</a> *args)
00575 {
00576     <a class="code" href="structClause.html">Clause</a> *<a class="code" href="classDDS.html#DDSa24">clause</a> = <span class="keyword">new</span> <a class="code" href="structClause.html">Clause</a>(func, args);
00577 
00578     expr.push_back(clause);
00579 }
00580 
00590 <span class="keywordtype">void</span>
<a name="l00591"></a><a class="code" href="classDDS.html#DDSa28">00591</a> <a class="code" href="classDDS.html#DDSa26">DDS::append_clause</a>(btp_func func, <a class="code" href="RValue_8h.html#a0">rvalue_list</a> *args)
00592 {
00593     <a class="code" href="structClause.html">Clause</a> *<a class="code" href="classDDS.html#DDSa24">clause</a> = <span class="keyword">new</span> <a class="code" href="structClause.html">Clause</a>(func, args);
00594 
00595     expr.push_back(clause);
00596 }
00597 
00605 <span class="keywordtype">void</span>
<a name="l00606"></a><a class="code" href="classDDS.html#DDSa39">00606</a> <a class="code" href="classDDS.html#DDSa39">DDS::append_constant</a>(<a class="code" href="classBaseType.html">BaseType</a> *btp)
00607 {
00608     constants.push_back(btp);
00609 }
00610 
00623 
00625 <span class="keywordtype">void</span>
<a name="l00626"></a><a class="code" href="classDDS.html#DDSz25_0">00626</a> <a class="code" href="classDDS.html#DDSz25_0">DDS::add_function</a>(<span class="keyword">const</span> string &amp;name, bool_func f)
00627 {
00628     function func(name, f);
00629     functions.push_back(func);
00630 }
00631 
00633 <span class="keywordtype">void</span>
<a name="l00634"></a><a class="code" href="classDDS.html#DDSz25_1">00634</a> <a class="code" href="classDDS.html#DDSz25_0">DDS::add_function</a>(<span class="keyword">const</span> string &amp;name, btp_func f)
00635 {
00636     function func(name, f);
00637     functions.push_back(func);
00638 }
00639 
00641 <span class="keywordtype">void</span>
<a name="l00642"></a><a class="code" href="classDDS.html#DDSz25_2">00642</a> <a class="code" href="classDDS.html#DDSz25_0">DDS::add_function</a>(<span class="keyword">const</span> string &amp;name, proj_func f)
00643 {
00644     function func(name, f);
00645     functions.push_back(func);
00646 }
00647 
00649 <span class="keywordtype">bool</span>
<a name="l00650"></a><a class="code" href="classDDS.html#DDSz25_3">00650</a> <a class="code" href="classDDS.html#DDSz25_3">DDS::find_function</a>(<span class="keyword">const</span> string &amp;name, bool_func *f)<span class="keyword"> const</span>
00651 <span class="keyword"></span>{
00652     <span class="keywordflow">if</span> (functions.empty())
00653     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00654 
00655     <span class="keywordflow">for</span> (<a class="code" href="classDDS.html#DDSw6">Functions_citer</a> i = functions.begin(); i != functions.end(); i++)
00656     {
00657         <span class="keywordflow">if</span> (name == (*i).name &amp;&amp; (*f = (*i).b_func)) {
00658         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00659         }
00660     }
00661 
00662     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00663 }
00664 
00666 <span class="keywordtype">bool</span>
<a name="l00667"></a><a class="code" href="classDDS.html#DDSz25_4">00667</a> <a class="code" href="classDDS.html#DDSz25_3">DDS::find_function</a>(<span class="keyword">const</span> string &amp;name, btp_func *f)<span class="keyword"> const</span>
00668 <span class="keyword"></span>{
00669     <span class="keywordflow">if</span> (functions.empty())
00670     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00671 
00672     <span class="keywordflow">for</span> (<a class="code" href="classDDS.html#DDSw6">Functions_citer</a> i = functions.begin(); i != functions.end(); i++)
00673     {
00674         <span class="keywordflow">if</span> (name == (*i).name &amp;&amp; (*f = (*i).bt_func)) {
00675         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00676         }
00677     }
00678 
00679     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00680 }
00681 
00683 <span class="keywordtype">bool</span>
<a name="l00684"></a><a class="code" href="classDDS.html#DDSz25_5">00684</a> <a class="code" href="classDDS.html#DDSz25_3">DDS::find_function</a>(<span class="keyword">const</span> string &amp;name, proj_func *f)<span class="keyword"> const</span>
00685 <span class="keyword"></span>{
00686     <span class="keywordflow">if</span> (functions.empty())
00687     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00688 
00689     <span class="keywordflow">for</span> (<a class="code" href="classDDS.html#DDSw6">Functions_citer</a> i = functions.begin(); i != functions.end(); i++)
00690     <span class="keywordflow">if</span> (name == (*i).name &amp;&amp; (*f = (*i).p_func)) {
00691         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00692     }
00693 
00694     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00695 }
00697 
00700 <span class="keywordtype">bool</span>
<a name="l00701"></a><a class="code" href="classDDS.html#DDSa29">00701</a> <a class="code" href="classDDS.html#DDSa29">DDS::functional_expression</a>()
00702 {
00703     <span class="keywordflow">if</span> (expr.empty())
00704     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00705 
00706     <a class="code" href="structClause.html">Clause</a> *cp = expr[0] ;
00707     <span class="keywordflow">return</span> cp-&gt;<a class="code" href="structClause.html#Clausea7">value_clause</a>();
00708 }
00709 
00711 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00712"></a><a class="code" href="classDDS.html#DDSa32">00712</a> <a class="code" href="classDDS.html#DDSa32">DDS::eval_function</a>(<span class="keyword">const</span> string &amp;dataset)
00713 {
00714     <span class="keywordflow">if</span> (expr.size() != 1)
00715     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, 
00716               <span class="stringliteral">"The length of the list of CE clauses is not 1."</span>);
00717 
00718     <a class="code" href="structClause.html">Clause</a> *cp = expr[0] ;
00719     <a class="code" href="classBaseType.html">BaseType</a> *result;
00720     <span class="keywordflow">if</span> (cp-&gt;<a class="code" href="structClause.html#Clausea8">value</a>(dataset, *<span class="keyword">this</span>, &amp;result))
00721     <span class="keywordflow">return</span> result;
00722     <span class="keywordflow">else</span>
00723     <span class="keywordflow">return</span> NULL;
00724 }
00725 
00727 <span class="keywordtype">bool</span>
<a name="l00728"></a><a class="code" href="classDDS.html#DDSa30">00728</a> <a class="code" href="classDDS.html#DDSa30">DDS::boolean_expression</a>()
00729 {
00730     <span class="keywordflow">if</span> (expr.empty())
00731     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00732 
00733     <span class="keywordtype">bool</span> <span class="keywordtype">boolean</span> = <span class="keyword">true</span>;
00734     <span class="keywordflow">for</span> (<a class="code" href="classDDS.html#DDSw3">Clause_iter</a> i = expr.begin(); i != expr.end(); i++)
00735     {
00736     <span class="keywordtype">boolean</span> = <span class="keywordtype">boolean</span> &amp;&amp; (*i)-&gt;boolean_clause();
00737     }
00738     
00739     <span class="keywordflow">return</span> <span class="keywordtype">boolean</span>;
00740 }
00741 
00743 <span class="keywordtype">bool</span>
<a name="l00744"></a><a class="code" href="classDDS.html#DDSa31">00744</a> <a class="code" href="classDDS.html#DDSa31">DDS::eval_selection</a>(<span class="keyword">const</span> string &amp;dataset)
00745 {
00746     <span class="keywordflow">if</span> (expr.empty()) {
00747     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"No selection recorded"</span> &lt;&lt; endl);
00748     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00749     }
00750 
00751     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Eval selection"</span> &lt;&lt; endl);
00752 
00753     <span class="comment">// A CE is made up of zero or more clauses, each of which has a boolean</span>
00754     <span class="comment">// value. The value of the CE is the logical AND of the clause</span>
00755     <span class="comment">// values. See DDS::clause::value(...) for inforamtion on logical ORs in</span>
00756     <span class="comment">// CEs. </span>
00757     <span class="keywordtype">bool</span> result = <span class="keyword">true</span>;
00758     <span class="keywordflow">for</span> (<a class="code" href="classDDS.html#DDSw3">Clause_iter</a> i = expr.begin(); i != expr.end() &amp;&amp; result; i++)
00759     {
00760     <span class="comment">// A selection expression *must* contain only boolean clauses!</span>
00761     <span class="keywordflow">if</span>(!((*i)-&gt;boolean_clause()))
00762         <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, 
00763                 <span class="stringliteral">"A selection expression must contain only boolean clauses."</span>);
00764     result = result &amp;&amp; (*i)-&gt;value(dataset, *<span class="keyword">this</span>);
00765     }
00766 
00767     <span class="keywordflow">return</span> result;
00768 }
00769 
00771 <span class="keywordtype">void</span>
<a name="l00772"></a><a class="code" href="classDDS.html#DDSa40">00772</a> <a class="code" href="classDDS.html#DDSa40">DDS::parse</a>(string fname)
00773 {
00774     FILE *in = fopen(fname.c_str(), <span class="stringliteral">"r"</span>);
00775 
00776     <span class="keywordflow">if</span> (!in) {
00777     <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(<a class="code" href="Error_8h.html#a7">can_not_read_file</a>, <span class="stringliteral">"Could not open: "</span> + fname);
00778     }
00779 
00780     <a class="code" href="classDDS.html#DDSa40">parse</a>(in);
00781 
00782     <span class="keywordtype">int</span> res = fclose(in);
00783     <span class="keywordflow">if</span>( res ) {
00784     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"DDS::parse - Failed to close file "</span> &lt;&lt; (<span class="keywordtype">void</span> *)in &lt;&lt; endl ;) ;
00785     }
00786 }
00787 
00788 
00790 <span class="keywordtype">void</span>
<a name="l00791"></a><a class="code" href="classDDS.html#DDSa41">00791</a> <a class="code" href="classDDS.html#DDSa40">DDS::parse</a>(<span class="keywordtype">int</span> fd)
00792 {
00793 <span class="preprocessor">#ifdef WIN32</span>
00794 <span class="preprocessor"></span>    FILE *in = fdopen(_dup(fd), <span class="stringliteral">"r"</span>);
00795 <span class="preprocessor">#else</span>
00796 <span class="preprocessor"></span>    FILE *in = fdopen(dup(fd), <span class="stringliteral">"r"</span>);
00797 <span class="preprocessor">#endif</span>
00798 <span class="preprocessor"></span>
00799     <span class="keywordflow">if</span> (!in) {
00800     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, <span class="stringliteral">"Could not access file."</span>);
00801     }
00802 
00803     <a class="code" href="classDDS.html#DDSa40">parse</a>(in);
00804 
00805     <span class="keywordtype">int</span> res = fclose(in);
00806     <span class="keywordflow">if</span> (res) {
00807     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"DDS::parse(fd) - Failed to close "</span> &lt;&lt; (<span class="keywordtype">void</span> *)in &lt;&lt; endl);
00808     }
00809 }
00810 
00817 <span class="keywordtype">void</span>
<a name="l00818"></a><a class="code" href="classDDS.html#DDSa42">00818</a> <a class="code" href="classDDS.html#DDSa40">DDS::parse</a>(FILE *in)
00819 {
00820     <span class="keywordflow">if</span> (!in) {
00821     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, <span class="stringliteral">"Null input stream."</span>);
00822     }
00823 
00824 <span class="preprocessor">#if 0</span>
00825 <span class="preprocessor"></span>    <a class="code" href="DDS_8cc.html#a1">ddsrestart</a>(in);
00826 <span class="preprocessor">#endif</span>
00827 <span class="preprocessor"></span>    <span class="keywordtype">void</span> *buffer = <a class="code" href="DDS_8cc.html#a10">dds_buffer</a>(in);
00828     <a class="code" href="DDS_8cc.html#a8">dds_switch_to_buffer</a>(buffer);
00829 
00830     <a class="code" href="structparser__arg.html">parser_arg</a> arg(<span class="keyword">this</span>);
00831 
00832     <span class="keywordtype">bool</span> status = <a class="code" href="DDS_8cc.html#a2">ddsparse</a>((<span class="keywordtype">void</span> *)&amp;arg) == 0;
00833 
00834     <a class="code" href="DDS_8cc.html#a9">dds_delete_buffer</a>(buffer);
00835 
00836     <a class="code" href="debug_8h.html#a1">DBG</a>(cout &lt;&lt; <span class="stringliteral">"Status from parser: "</span> &lt;&lt; status &lt;&lt; endl);
00837 
00838     <span class="comment">//  STATUS is the result of the parser function; if a recoverable error</span>
00839     <span class="comment">//  was found it will be true but arg.status() will be false.</span>
00840     <span class="keywordflow">if</span> (!status || !arg.<a class="code" href="structparser__arg.html#parser__arga7">status</a>()) {<span class="comment">// Check parse result</span>
00841     <span class="keywordflow">if</span> (arg.<a class="code" href="structparser__arg.html#parser__arga5">error</a>())
00842       <span class="keywordflow">throw</span> *arg.<a class="code" href="structparser__arg.html#parser__arga5">error</a>();
00843     }
00844 }
00845 
00852 <span class="keywordtype">void</span>
<a name="l00853"></a><a class="code" href="classDDS.html#DDSa43">00853</a> <a class="code" href="classDDS.html#DDSa43">DDS::print</a>(ostream &amp;os)
00854 {
00855     os &lt;&lt; <span class="stringliteral">"Dataset {"</span> &lt;&lt; endl;
00856 
00857     <span class="keywordflow">for</span> (<a class="code" href="classDDS.html#DDSw1">Vars_iter</a> i = vars.begin(); i != vars.end(); i++)
00858     (*i)-&gt;print_decl(os);
00859 
00860     os &lt;&lt; <span class="stringliteral">"} "</span> &lt;&lt; <a class="code" href="escaping_8cc.html#a5">id2www</a>(name) &lt;&lt; <span class="stringliteral">";"</span> &lt;&lt; endl;
00861 }
00862 
00864 <span class="keywordtype">void</span>
<a name="l00865"></a><a class="code" href="classDDS.html#DDSa44">00865</a> <a class="code" href="classDDS.html#DDSa43">DDS::print</a>(FILE *out)
00866 {
00867     fprintf( out, <span class="stringliteral">"Dataset {\n"</span> ) ;
00868 
00869     <span class="keywordflow">for</span>( <a class="code" href="classDDS.html#DDSw0">Vars_citer</a> i = vars.begin(); i != vars.end(); i++ )
00870     {
00871     (*i)-&gt;print_decl( out ) ;
00872     }
00873 
00874     fprintf( out, <span class="stringliteral">"} %s;\n"</span>, <a class="code" href="escaping_8cc.html#a5">id2www</a>(name).c_str() ) ;
00875 
00876     <span class="keywordflow">return</span> ;
00877 }
00878 
00890 <span class="keywordtype">void</span>
<a name="l00891"></a><a class="code" href="classDDS.html#DDSa45">00891</a> <a class="code" href="classDDS.html#DDSa45">DDS::print_constrained</a>(ostream &amp;os)
00892 {
00893     os &lt;&lt; <span class="stringliteral">"Dataset {"</span> &lt;&lt; endl;
00894 
00895     <span class="keywordflow">for</span> (<a class="code" href="classDDS.html#DDSw1">Vars_iter</a> i = vars.begin(); i != vars.end(); i++)
00896     <span class="comment">// for each variable, indent with four spaces, print a trailing</span>
00897     <span class="comment">// semi-colon, do not print debugging information, print only</span>
00898     <span class="comment">// variables in the current projection.</span>
00899     (*i)-&gt;print_decl(os, <span class="stringliteral">"    "</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);
00900 
00901     os &lt;&lt; <span class="stringliteral">"} "</span> &lt;&lt; <a class="code" href="escaping_8cc.html#a5">id2www</a>(name) &lt;&lt; <span class="stringliteral">";"</span> &lt;&lt; endl;
00902 }
00913 <span class="keywordtype">void</span>
<a name="l00914"></a><a class="code" href="classDDS.html#DDSa46">00914</a> <a class="code" href="classDDS.html#DDSa45">DDS::print_constrained</a>(FILE *out)
00915 {
00916     fprintf( out, <span class="stringliteral">"Dataset {\n"</span> ) ;
00917 
00918     <span class="keywordflow">for</span> (<a class="code" href="classDDS.html#DDSw0">Vars_citer</a> i = vars.begin(); i != vars.end(); i++)
00919     {
00920     <span class="comment">// for each variable, indent with four spaces, print a trailing</span>
00921     <span class="comment">// semi-colon, do not print debugging information, print only</span>
00922     <span class="comment">// variables in the current projection.</span>
00923     (*i)-&gt;print_decl( out, <span class="stringliteral">"    "</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span> ) ;
00924     }
00925 
00926     fprintf( out, <span class="stringliteral">"} %s;\n"</span>, <a class="code" href="escaping_8cc.html#a5">id2www</a>(name).c_str() ) ;
00927 
00928     <span class="keywordflow">return</span>;
00929 }
00930 
00945 <span class="keywordtype">bool</span>
<a name="l00946"></a><a class="code" href="classDDS.html#DDSa50">00946</a> <a class="code" href="classDDS.html#DDSa50">DDS::check_semantics</a>(<span class="keywordtype">bool</span> all)
00947 {
00948     <span class="comment">// The dataset must have a name</span>
00949     <span class="keywordflow">if</span> (name == <span class="stringliteral">""</span>) {
00950     cerr &lt;&lt; <span class="stringliteral">"A dataset must have a name"</span> &lt;&lt; endl;
00951     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00952     }
00953 
00954     string msg;
00955     <span class="keywordflow">if</span> (!<a class="code" href="util_8cc.html#a3">unique_names</a>(vars, name, <span class="stringliteral">"Dataset"</span>, msg))
00956     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00957 
00958     <span class="keywordflow">if</span> (all) 
00959     <span class="keywordflow">for</span> (<a class="code" href="classDDS.html#DDSw1">Vars_iter</a> i = vars.begin(); i != vars.end(); i++)
00960         <span class="keywordflow">if</span> (!(*i)-&gt;check_semantics(msg, <span class="keyword">true</span>))
00961         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00962 
00963     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00964 }
00965 
00974 <span class="keywordtype">void</span>
<a name="l00975"></a><a class="code" href="classDDS.html#DDSa36">00975</a> <a class="code" href="classDDS.html#DDSa36">DDS::parse_constraint</a>(<span class="keyword">const</span> string &amp;constraint)
00976 {
00977     <span class="keywordtype">void</span> *buffer = <a class="code" href="expr-test_8cc.html#a22">expr_string</a>(constraint.c_str());
00978     <a class="code" href="expr-test_8cc.html#a20">expr_switch_to_buffer</a>(buffer);
00979 
00980     <a class="code" href="structparser__arg.html">parser_arg</a> arg(<span class="keyword">this</span>);
00981 
00982     <span class="comment">// For all errors, exprparse will throw Error. </span>
00983     <a class="code" href="expr-test_8cc.html#a18">exprparse</a>((<span class="keywordtype">void</span> *)&amp;arg);
00984 
00985     <a class="code" href="expr-test_8cc.html#a21">expr_delete_buffer</a>(buffer);
00986 }
00987 
01003 <span class="keywordtype">void</span>
<a name="l01004"></a><a class="code" href="classDDS.html#DDSa37">01004</a> <a class="code" href="classDDS.html#DDSa36">DDS::parse_constraint</a>(<span class="keyword">const</span> string &amp;constraint, ostream &amp;os, <span class="keywordtype">bool</span> server)
01005 {
01006     <span class="keywordtype">void</span> *buffer = <a class="code" href="expr-test_8cc.html#a22">expr_string</a>(constraint.c_str());
01007     <a class="code" href="expr-test_8cc.html#a20">expr_switch_to_buffer</a>(buffer);
01008 
01009     <a class="code" href="structparser__arg.html">parser_arg</a> arg(<span class="keyword">this</span>);
01010 
01011     <span class="comment">// For all errors, exprparse will throw Error. </span>
01012     <a class="code" href="expr-test_8cc.html#a18">exprparse</a>((<span class="keywordtype">void</span> *)&amp;arg);
01013 
01014     <a class="code" href="expr-test_8cc.html#a21">expr_delete_buffer</a>(buffer);
01015 }
01016 
01034 <span class="keywordtype">void</span>
<a name="l01035"></a><a class="code" href="classDDS.html#DDSa38">01035</a> <a class="code" href="classDDS.html#DDSa36">DDS::parse_constraint</a>(<span class="keyword">const</span> string &amp;constraint, FILE *out, <span class="keywordtype">bool</span> server)
01036 {
01037     <span class="keywordtype">void</span> *buffer = <a class="code" href="expr-test_8cc.html#a22">expr_string</a>( constraint.c_str( ) ) ;
01038     <a class="code" href="expr-test_8cc.html#a20">expr_switch_to_buffer</a>( buffer ) ;
01039 
01040     <a class="code" href="structparser__arg.html">parser_arg</a> arg( <span class="keyword">this</span> ) ;
01041 
01042     <span class="comment">// For all errors, exprparse will throw Error. </span>
01043     <a class="code" href="expr-test_8cc.html#a18">exprparse</a>( (<span class="keywordtype">void</span> *)&amp;arg ) ;
01044 
01045     <a class="code" href="expr-test_8cc.html#a21">expr_delete_buffer</a>( buffer ) ;
01046 
01047     <span class="keywordflow">return</span>;
01048 }
01049 
01050 <span class="comment">// These three functions are defined here because they are used by the</span>
01051 <span class="comment">// deprecated DDS::send method. 07/24/03 jhrg</span>
01052 
01053 <span class="comment">// We start two sinks, one for regular data and one for XDR encoded data.</span>
01054 <span class="keyword">static</span> <span class="keywordtype">int</span>
01055 get_sinks(FILE *out, <span class="keywordtype">bool</span> compressed, FILE **comp_sink, XDR **xdr_sink)
01056 {
01057     <span class="comment">// If compressing, start up the sub process.</span>
01058     <span class="keywordtype">int</span> childpid;   <span class="comment">// Used to wait for compressor sub proc</span>
01059     <span class="keywordflow">if</span> (compressed) {
01060     *comp_sink = <a class="code" href="util_8cc.html#a10">compressor</a>(out, childpid);
01061     *xdr_sink = <a class="code" href="util_8cc.html#a4">new_xdrstdio</a>(*comp_sink, XDR_ENCODE);
01062     }
01063     <span class="keywordflow">else</span> {
01064     *xdr_sink = <a class="code" href="util_8cc.html#a4">new_xdrstdio</a>(out, XDR_ENCODE);
01065     }
01066     
01067     <span class="keywordflow">return</span> childpid;
01068 }
01069 
01070 <span class="comment">// Clean up after sinks; might have to wait for the compressor process to</span>
01071 <span class="comment">// stop. </span>
01072 <span class="keyword">static</span> <span class="keywordtype">void</span>
01073 clean_sinks(<span class="keywordtype">int</span> childpid, <span class="keywordtype">bool</span> compressed, XDR *xdr_sink, FILE *comp_sink)
01074 {
01075     <a class="code" href="util_8cc.html#a6">delete_xdrstdio</a>(xdr_sink);
01076     
01077     <span class="keywordflow">if</span> (compressed) {
01078     <span class="keywordflow">if</span> (fclose(comp_sink)) {
01079         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"clean_sinks - Failed to close "</span> &lt;&lt; (<span class="keywordtype">void</span> *)comp_sink 
01080         &lt;&lt; endl);
01081     }
01082 
01083     <span class="keywordtype">int</span> pid = 0 ;
01084 <span class="preprocessor">#ifdef WIN32</span>
01085 <span class="preprocessor"></span>    <span class="keywordflow">while</span> ((pid = _cwait(NULL, childpid, NULL)) &gt; 0)
01086 <span class="preprocessor">#else</span>
01087 <span class="preprocessor"></span>    <span class="keywordflow">while</span> ((pid = waitpid(childpid, 0, 0)) &gt; 0)
01088 <span class="preprocessor">#endif</span>
01089 <span class="preprocessor"></span>        <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"pid: "</span> &lt;&lt; pid &lt;&lt; endl);
01090     }
01091 }
01092 
01093 <span class="keyword">static</span> <span class="keywordtype">void</span>
01094 print_variable(FILE *out, <a class="code" href="classBaseType.html">BaseType</a> *var, <span class="keywordtype">bool</span> constrained = <span class="keyword">false</span>)
01095 {
01096     <span class="keywordflow">if</span>(!out)
01097     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, 
01098               <span class="stringliteral">"Invalid file descriptor, NULL pointer!"</span>);
01099     <span class="keywordflow">if</span>(!var)
01100     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, 
01101               <span class="stringliteral">"Passing NULL variable to function print_variable."</span>);
01102 
01103     fprintf( out, <span class="stringliteral">"Dataset {\n"</span> ) ;
01104 
01105     var-&gt;<a class="code" href="classBaseType.html#Urla38">print_decl</a>( out, <span class="stringliteral">"    "</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, constrained ) ;
01106 
01107     fprintf( out, <span class="stringliteral">"} function_value;\n"</span> ) ;
01108 }
01109 
01130 <span class="keywordtype">bool</span> 
<a name="l01131"></a><a class="code" href="classDDS.html#DDSa47">01131</a> <a class="code" href="classDDS.html#DDSa47">DDS::send</a>(<span class="keyword">const</span> string &amp;dataset, <span class="keyword">const</span> string &amp;constraint, FILE *out, 
01132       <span class="keywordtype">bool</span> compressed, <span class="keyword">const</span> string &amp;cgi_ver, time_t lmt)
01133 {
01134     <span class="comment">// Jose Garcia</span>
01135     <span class="comment">// If there is a parse error the method parse_constraint will throw </span>
01136     <span class="comment">// an exception that will terminate the method send.</span>
01137     <span class="comment">// If parse_constraint executes with no exception</span>
01138     <span class="comment">// we will proceed with the algorithm to send the data.</span>
01139 
01140     <a class="code" href="classDDS.html#DDSa36">parse_constraint</a>(constraint, out, <span class="keyword">true</span>);
01141   
01142     <span class="keywordtype">bool</span> status = <span class="keyword">true</span>;
01143   
01144     <span class="comment">// Handle *functional* constraint expressions specially </span>
01145     <span class="keywordflow">if</span> (<a class="code" href="classDDS.html#DDSa29">functional_expression</a>()) {
01146     <a class="code" href="classBaseType.html">BaseType</a> *<a class="code" href="classDDS.html#DDSa6">var</a> = <a class="code" href="classDDS.html#DDSa32">eval_function</a>(dataset);
01147     <span class="keywordflow">if</span> (!var)
01148         <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(<a class="code" href="Error_8h.html#a1">unknown_error</a>, <span class="stringliteral">"Error calling the CE function."</span>);
01149 
01150     <a class="code" href="cgi__util_8cc.html#a18">set_mime_binary</a>(out, <a class="code" href="ObjectType_8h.html#a6a3">dods_data</a>, cgi_ver,
01151             (compressed) ? <a class="code" href="EncodingType_8h.html#a3a1">deflate</a> : <a class="code" href="EncodingType_8h.html#a3a2">x_plain</a>, lmt);
01152     fflush(out);
01153       
01154     FILE *comp_sink;
01155     XDR *xdr_sink;
01156     <span class="keywordtype">int</span> childpid = get_sinks(out, compressed, &amp;comp_sink, &amp;xdr_sink);
01157       
01158     print_variable((compressed) ? comp_sink : out, var, <span class="keyword">true</span>);
01159     fprintf((compressed) ? comp_sink : out, <span class="stringliteral">"Data:\n"</span>);
01160     fflush((compressed) ? comp_sink : out);
01161       
01162     <span class="comment">// In the following call to serialize, suppress CE evaluation.</span>
01163     status = var-&gt;<a class="code" href="classBaseType.html#Constructora34">serialize</a>(dataset, *<span class="keyword">this</span>, xdr_sink, <span class="keyword">false</span>);
01164       
01165     clean_sinks(childpid, compressed, xdr_sink, comp_sink);
01166     }
01167     <span class="keywordflow">else</span> {
01168     <a class="code" href="cgi__util_8cc.html#a18">set_mime_binary</a>(out, <a class="code" href="ObjectType_8h.html#a6a3">dods_data</a>, cgi_ver,
01169             (compressed) ? <a class="code" href="EncodingType_8h.html#a3a1">deflate</a> : <a class="code" href="EncodingType_8h.html#a3a2">x_plain</a>, lmt);
01170     fflush(out);
01171 
01172     FILE *comp_sink;
01173     XDR *xdr_sink;
01174     <span class="keywordtype">int</span> childpid = get_sinks(out, compressed, &amp;comp_sink, &amp;xdr_sink);
01175 
01176     <span class="comment">// send constrained DDS     </span>
01177     <a class="code" href="classDDS.html#DDSa45">print_constrained</a>((compressed) ? comp_sink : out);
01178     fprintf((compressed) ? comp_sink : out, <span class="stringliteral">"Data:\n"</span>);
01179     fflush((compressed) ? comp_sink : out);
01180 
01181     <span class="keywordflow">for</span> (<a class="code" href="classDDS.html#DDSw1">Vars_iter</a> i = vars.begin(); i != vars.end(); i++)
01182         <span class="keywordflow">if</span> ((*i)-&gt;send_p()) <span class="comment">// only process projected variables</span>
01183         status = status &amp;&amp; (*i)-&gt;serialize(dataset, *<span class="keyword">this</span>,
01184                            xdr_sink, <span class="keyword">true</span>);
01185 
01186     clean_sinks(childpid, compressed, xdr_sink, comp_sink);
01187     }
01188 
01189     <span class="keywordflow">return</span> status;
01190 }
01191 
01217 <span class="keywordtype">bool</span>
<a name="l01218"></a><a class="code" href="classDDS.html#DDSa49">01218</a> <a class="code" href="classDDS.html#DDSa49">DDS::mark</a>(<span class="keyword">const</span> string &amp;n, <span class="keywordtype">bool</span> state)
01219 {
01220     <a class="code" href="BaseType_8h.html#a1">btp_stack</a> *s = <span class="keyword">new</span> <a class="code" href="BaseType_8h.html#a1">btp_stack</a>;
01221 
01222     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Looking for "</span> &lt;&lt; n &lt;&lt; endl);
01223 
01224     <a class="code" href="classBaseType.html">BaseType</a> *variable = <a class="code" href="classDDS.html#DDSa6">var</a>(n, s);
01225     <span class="keywordflow">if</span> (!variable) {
01226     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Could not find variable "</span> &lt;&lt; n &lt;&lt; endl);
01227     <span class="keywordflow">return</span> <span class="keyword">false</span>;
01228     }
01229     variable-&gt;<a class="code" href="classBaseType.html#Urla27">set_send_p</a>(state);
01230     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Set variable "</span> &lt;&lt; variable-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>() &lt;&lt; endl);
01231 
01232     <span class="comment">// Now check the btp_stack and run BaseType::set_send_p for every</span>
01233     <span class="comment">// BaseType pointer on the stack.</span>
01234     <span class="keywordflow">while</span> (!s-&gt;empty()) {
01235     s-&gt;top()-&gt;BaseType::set_send_p(state);
01236     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Set variable "</span> &lt;&lt; s-&gt;top()-&gt;name() &lt;&lt; endl);
01237     s-&gt;pop();
01238     }
01239 
01240     <span class="keyword">delete</span> s ;
01241 
01242     <span class="keywordflow">return</span> <span class="keyword">true</span>;
01243 }
01244 
01250 <span class="keywordtype">void</span>
<a name="l01251"></a><a class="code" href="classDDS.html#DDSa48">01251</a> <a class="code" href="classDDS.html#DDSa48">DDS::mark_all</a>(<span class="keywordtype">bool</span> state)
01252 {
01253     <span class="keywordflow">for</span> (<a class="code" href="classDDS.html#DDSw1">Vars_iter</a> i = vars.begin(); i != vars.end(); i++)
01254     (*i)-&gt;set_send_p(state);
01255 }
01256     
01257 <span class="comment">// $Log: DDS_8cc-source.html,v $
01257 <span class="comment">// Revision 1.4  2004/02/05 06:51:16  jimg
01257 <span class="comment">// Added/update.
01257 <span class="comment">//</span>
01258 <span class="comment">// Revision 1.62.2.6  2004/02/04 00:05:11  jimg</span>
01259 <span class="comment">// Memory errors: I've fixed a number of memory errors (leaks, references)</span>
01260 <span class="comment">// found using valgrind. Many remain. I need to come up with a systematic</span>
01261 <span class="comment">// way of running the tests under valgrind.</span>
01262 <span class="comment">//</span>
01263 <span class="comment">// Revision 1.62.2.5  2003/09/06 22:27:26  jimg</span>
01264 <span class="comment">// Updated the documentation. Removed some old code.</span>
01265 <span class="comment">//</span>
01266 <span class="comment">// Revision 1.62.2.4  2003/08/17 01:37:54  rmorris</span>
01267 <span class="comment">// Removed "smart timeout" functionality under win32.  alarm() and</span>
01268 <span class="comment">// SIGALRM are not supported under win32 - plus that functionality</span>
01269 <span class="comment">// appears to be server-side only and win32 is client-side only.</span>
01270 <span class="comment">//</span>
01271 <span class="comment">// Revision 1.62.2.3  2003/07/25 06:04:28  jimg</span>
01272 <span class="comment">// Refactored the code so that DDS:send() is now incorporated into</span>
01273 <span class="comment">// DODSFilter::send_data(). The old DDS::send() is still there but is</span>
01274 <span class="comment">// depracated.</span>
01275 <span class="comment">// Added 'smart timeouts' to all the variable classes. This means that</span>
01276 <span class="comment">// the new server timeouts are active only for the data read and CE</span>
01277 <span class="comment">// evaluation. This went inthe BaseType::serialize() methods because it</span>
01278 <span class="comment">// needed to time both the read() calls and the dds::eval() calls.</span>
01279 <span class="comment">//</span>
01280 <span class="comment">// Revision 1.62.2.2  2003/07/23 23:56:36  jimg</span>
01281 <span class="comment">// Now supports a simple timeout system.</span>
01282 <span class="comment">//</span>
01283 <span class="comment">// Revision 1.62.2.1  2003/07/16 04:22:39  jimg</span>
01284 <span class="comment">// Fixed a bug (part of #635) where compressed data responses needed to have the</span>
01285 <span class="comment">// stream flushed. I added calls to make sure the stream was flushed at two</span>
01286 <span class="comment">// critical spots, one where the headers are written and one where the DDS is</span>
01287 <span class="comment">// written.</span>
01288 <span class="comment">//</span>
01289 <span class="comment">// Revision 1.62  2003/04/22 19:40:27  jimg</span>
01290 <span class="comment">// Merged with 3.3.1.</span>
01291 <span class="comment">//</span>
01292 <span class="comment">// Revision 1.60.2.3  2003/04/18 03:09:58  jimg</span>
01293 <span class="comment">// I combined some of the win32 #ifdef code and removed some old code.</span>
01294 <span class="comment">//</span>
01295 <span class="comment">// Revision 1.60.2.2  2003/04/15 01:17:12  jimg</span>
01296 <span class="comment">// Added a method to get the iterator for a variable (or map) given its</span>
01297 <span class="comment">// index. To get the iterator for the ith variable/map, call</span>
01298 <span class="comment">// get_vars_iter(i).</span>
01299 <span class="comment">//</span>
01300 <span class="comment">// Revision 1.61  2003/02/21 00:14:24  jimg</span>
01301 <span class="comment">// Repaired copyright.</span>
01302 <span class="comment">//</span>
01303 <span class="comment">// Revision 1.60.2.1  2003/02/21 00:10:07  jimg</span>
01304 <span class="comment">// Repaired copyright.</span>
01305 <span class="comment">//</span>
01306 <span class="comment">// Revision 1.60  2003/01/23 00:22:24  jimg</span>
01307 <span class="comment">// Updated the copyright notice; this implementation of the DAP is</span>
01308 <span class="comment">// copyrighted by OPeNDAP, Inc.</span>
01309 <span class="comment">//</span>
01310 <span class="comment">// Revision 1.59  2003/01/15 19:24:39  pwest</span>
01311 <span class="comment">// Removing IteratorAdapterT and replacing with non-templated versions.</span>
01312 <span class="comment">//</span>
01313 <span class="comment">// Revision 1.58  2003/01/10 19:46:40  jimg</span>
01314 <span class="comment">// Merged with code tagged release-3-2-10 on the release-3-2 branch. In many</span>
01315 <span class="comment">// cases files were added on that branch (so they appear on the trunk for</span>
01316 <span class="comment">// the first time).</span>
01317 <span class="comment">//</span>
01318 <span class="comment">// Revision 1.53.4.22  2002/12/31 16:43:20  rmorris</span>
01319 <span class="comment">// Patches to handle some of the fancier template code under VC++ 6.0.</span>
01320 <span class="comment">//</span>
01321 <span class="comment">// Revision 1.53.4.21  2002/12/27 19:34:42  jimg</span>
01322 <span class="comment">// Modified the var() methods so that www2id() is called before looking</span>
01323 <span class="comment">// up identifier names. See bug 563.</span>
01324 <span class="comment">//</span>
01325 <span class="comment">// Revision 1.53.4.20  2002/12/20 00:53:52  jimg</span>
01326 <span class="comment">// I removed the static void print_variable(...) because it's no longer</span>
01327 <span class="comment">// used by our code.</span>
01328 <span class="comment">//</span>
01329 <span class="comment">// Revision 1.53.4.19  2002/12/17 22:35:02  pwest</span>
01330 <span class="comment">// Added and updated methods using stdio. Deprecated methods using iostream.</span>
01331 <span class="comment">//</span>
01332 <span class="comment">// Revision 1.53.4.18  2002/11/21 21:24:17  pwest</span>
01333 <span class="comment">// memory leak cleanup and file descriptor cleanup</span>
01334 <span class="comment">//</span>
01335 <span class="comment">// Revision 1.53.4.17  2002/11/06 22:56:52  pwest</span>
01336 <span class="comment">// Memory delete errors and uninitialized memory read errors corrected</span>
01337 <span class="comment">//</span>
01338 <span class="comment">// Revision 1.53.4.16  2002/10/28 21:17:44  pwest</span>
01339 <span class="comment">// Converted all return values and method parameters to use non-const iterator.</span>
01340 <span class="comment">// Added operator== and operator!= methods to IteratorAdapter to handle Pix</span>
01341 <span class="comment">// problems.</span>
01342 <span class="comment">//</span>
01343 <span class="comment">// Revision 1.53.4.15  2002/10/02 17:50:36  pwest</span>
01344 <span class="comment">// Added two new del_vars methods. The first takes an iterator and deltes the</span>
01345 <span class="comment">// variable referenced by that iterator. The iterator now points to the element</span>
01346 <span class="comment">// after the deleted element. The second method takes two iterators and will</span>
01347 <span class="comment">// delete the variables starting from the first iterator and up to, not</span>
01348 <span class="comment">// including the second iterator.</span>
01349 <span class="comment">//</span>
01350 <span class="comment">// Revision 1.53.4.14  2002/09/22 14:27:51  rmorris</span>
01351 <span class="comment">// VC++ doesn't allow consider x in 'for(int x,...)' to be only for that</span>
01352 <span class="comment">// scope of the block for that loop - therefor multiple of these in the</span>
01353 <span class="comment">// same function are illegal because the 'x' is considered multiply</span>
01354 <span class="comment">// declared.  Removed.</span>
01355 <span class="comment">//</span>
01356 <span class="comment">// Revision 1.53.4.13  2002/09/12 22:49:57  pwest</span>
01357 <span class="comment">// Corrected signature changes made with Pix to IteratorAdapter changes. Rather</span>
01358 <span class="comment">// than taking a reference to a Pix, taking a Pix value.</span>
01359 <span class="comment">//</span>
01360 <span class="comment">// Revision 1.53.4.12  2002/09/05 22:52:54  pwest</span>
01361 <span class="comment">// Replaced the GNU data structures SLList and DLList with the STL container</span>
01362 <span class="comment">// class vector&lt;&gt;. To maintain use of Pix, changed the Pix.h header file to</span>
01363 <span class="comment">// redefine Pix to be an IteratorAdapter. Usage remains the same and all code</span>
01364 <span class="comment">// outside of the DAP should compile and link with no problems. Added methods</span>
01365 <span class="comment">// to the different classes where Pix is used to include methods to use STL</span>
01366 <span class="comment">// iterators. Replaced the use of Pix within the DAP to use iterators instead.</span>
01367 <span class="comment">// Updated comments for documentation, updated the test suites, and added some</span>
01368 <span class="comment">// unit tests. Updated the Makefile to remove GNU/SLList and GNU/DLList.</span>
01369 <span class="comment">//</span>
01370 <span class="comment">// Revision 1.53.4.11  2002/08/22 21:23:23  jimg</span>
01371 <span class="comment">// Fixes for the Win32 Build made at ESRI by Vlad Plenchoy and myslef.</span>
01372 <span class="comment">//</span>
01373 <span class="comment">// Revision 1.53.4.10  2002/08/08 06:54:57  jimg</span>
01374 <span class="comment">// Changes for thread-safety. In many cases I found ugly places at the</span>
01375 <span class="comment">// tops of files while looking for globals, et c., and I fixed them up</span>
01376 <span class="comment">// (hopefully making them easier to read, ...). Only the files RCReader.cc</span>
01377 <span class="comment">// and usage.cc actually use pthreads synchronization functions. In other</span>
01378 <span class="comment">// cases I removed static objects where they were used for supposed</span>
01379 <span class="comment">// improvements in efficiency which had never actually been verifiied (and</span>
01380 <span class="comment">// which looked dubious).</span>
01381 <span class="comment">//</span>
01382 <span class="comment">// Revision 1.53.4.9  2002/06/20 03:18:48  jimg</span>
01383 <span class="comment">// Fixes and modifications to the Connect and HTTPConnect classes. Neither</span>
01384 <span class="comment">// of these two classes is complete, but they should compile and their</span>
01385 <span class="comment">// basic functions should work.</span>
01386 <span class="comment">//</span>
01387 <span class="comment">// Revision 1.57  2002/06/18 15:36:24  tom</span>
01388 <span class="comment">// Moved comments and edited to accommodate doxygen documentation-generator.</span>
01389 <span class="comment">//</span>
01390 <span class="comment">// Revision 1.56  2002/06/03 22:21:15  jimg</span>
01391 <span class="comment">// Merged with release-3-2-9</span>
01392 <span class="comment">//</span>
01393 <span class="comment">// Revision 1.53.4.8  2002/04/02 19:11:47  jimg</span>
01394 <span class="comment">// Wrapped using std::strstream in #ifdef WIN32 since that's the only time this</span>
01395 <span class="comment">// file includes the strstream header.</span>
01396 <span class="comment">//</span>
01397 <span class="comment">// Revision 1.53.4.7  2002/03/01 21:03:08  jimg</span>
01398 <span class="comment">// Significant changes to the var(...) methods. These now take a btp_stack</span>
01399 <span class="comment">// pointer and are used by DDS::mark(...). The exact_match methods have also</span>
01400 <span class="comment">// been updated so that leaf variables which contain dots in their names</span>
01401 <span class="comment">// will be found. Note that constructor variables with dots in their names</span>
01402 <span class="comment">// will break the lookup routines unless the ctor is the last field in the</span>
01403 <span class="comment">// constraint expression. These changes were made to fix bug 330.</span>
01404 <span class="comment">//</span>
01405 <span class="comment">// Revision 1.53.4.6  2002/01/30 18:53:09  jimg</span>
01406 <span class="comment">// Fixes to the comments.</span>
01407 <span class="comment">//</span>
01408 <span class="comment">// Revision 1.53.4.5  2001/10/30 06:55:45  rmorris</span>
01409 <span class="comment">// Win32 porting changes.  Brings core win32 port up-to-date.</span>
01410 <span class="comment">//</span>
01411 <span class="comment">// Revision 1.55  2001/08/24 17:46:22  jimg</span>
01412 <span class="comment">// Resolved conflicts from the merge of release 3.2.6</span>
01413 <span class="comment">//</span>
01414 <span class="comment">// Revision 1.53.4.4  2001/07/28 01:10:42  jimg</span>
01415 <span class="comment">// Some of the numeric type classes did not have copy ctors or operator=.</span>
01416 <span class="comment">// I added those where they were needed.</span>
01417 <span class="comment">// In every place where delete (or delete []) was called, I set the pointer</span>
01418 <span class="comment">// just deleted to zero. Thus if for some reason delete is called again</span>
01419 <span class="comment">// before new memory is allocated there won't be a mysterious crash. This is</span>
01420 <span class="comment">// just good form when using delete.</span>
01421 <span class="comment">// I added calls to www2id and id2www where appropriate. The DAP now handles</span>
01422 <span class="comment">// making sure that names are escaped and unescaped as needed. Connect is</span>
01423 <span class="comment">// set to handle CEs that contain names as they are in the dataset (see the</span>
01424 <span class="comment">// comments/Log there). Servers should not handle escaping or unescaping</span>
01425 <span class="comment">// characters on their own.</span>
01426 <span class="comment">//</span>
01427 <span class="comment">// Revision 1.54  2001/06/15 23:49:01  jimg</span>
01428 <span class="comment">// Merged with release-3-2-4.</span>
01429 <span class="comment">//</span>
01430 <span class="comment">// Revision 1.53.4.3  2001/05/12 00:03:13  jimg</span>
01431 <span class="comment">// Changed add_var() so that it adds copies of the BaseType*s to mimic the</span>
01432 <span class="comment">// behavior of Structure, ..., Grid.</span>
01433 <span class="comment">// Factored two (static) functions out of send().</span>
01434 <span class="comment">//</span>
01435 <span class="comment">// Revision 1.53.4.2  2001/05/03 18:53:07  jimg</span>
01436 <span class="comment">// Changed a comment; it was about five years out of date.</span>
01437 <span class="comment">//</span>
01438 <span class="comment">// Revision 1.53.4.1  2001/04/23 22:34:46  jimg</span>
01439 <span class="comment">// Added support for the Last-Modified MIME header in server responses.`</span>
01440 <span class="comment">//</span>
01441 <span class="comment">// Revision 1.53  2000/10/03 22:16:22  jimg</span>
01442 <span class="comment">// Put debgging output in parse() method inside DBG().</span>
01443 <span class="comment">//</span>
01444 <span class="comment">// Revision 1.52  2000/09/22 02:17:19  jimg</span>
01445 <span class="comment">// Rearranged source files so that the CVS logs appear at the end rather than</span>
01446 <span class="comment">// the start. Also made the ifdef guard symbols use the same naming scheme and</span>
01447 <span class="comment">// wrapped headers included in other headers in those guard symbols (to cut</span>
01448 <span class="comment">// down on extraneous file processing - See Lakos).</span>
01449 <span class="comment">//</span>
01450 <span class="comment">// Revision 1.51  2000/09/21 16:22:07  jimg</span>
01451 <span class="comment">// Merged changes from Jose Garcia that add exceptions to the software.</span>
01452 <span class="comment">// Many methods that returned error codes now throw exectptions. There are</span>
01453 <span class="comment">// two classes which are thrown by the software, Error and InternalErr.</span>
01454 <span class="comment">// InternalErr is used to report errors within the library or errors using</span>
01455 <span class="comment">// the library. Error is used to reprot all other errors. Since InternalErr</span>
01456 <span class="comment">// is a subclass of Error, programs need only to catch Error.</span>
01457 <span class="comment">//</span>
01458 <span class="comment">// Revision 1.50  2000/07/09 22:05:35  rmorris</span>
01459 <span class="comment">// Changes to increase portability, minimize ifdef's for win32 and account</span>
01460 <span class="comment">// for differences in the iostreams implementations.</span>
01461 <span class="comment">//</span>
01462 <span class="comment">// Revision 1.48  2000/06/16 18:50:18  jimg</span>
01463 <span class="comment">// Fixes leftover from the last merge plus needed for the merge with version</span>
01464 <span class="comment">// 3.1.7.</span>
01465 <span class="comment">//</span>
01466 <span class="comment">// Revision 1.47  2000/06/16 18:14:59  jimg</span>
01467 <span class="comment">// Merged with 3.1.7</span>
01468 <span class="comment">//</span>
01469 <span class="comment">// Revision 1.44.2.2  2000/06/14 17:01:40  jimg</span>
01470 <span class="comment">// Fixed a bug in del_var; the BaseType pointer vars(p) must be deleted</span>
01471 <span class="comment">// before calling DLList.del(p).</span>
01472 <span class="comment">//</span>
01473 <span class="comment">// Revision 1.46  2000/06/07 18:06:58  jimg</span>
01474 <span class="comment">// Merged the pc port branch</span>
01475 <span class="comment">//</span>
01476 <span class="comment">// Revision 1.45.6.1  2000/06/02 18:16:48  rmorris</span>
01477 <span class="comment">// Mod's for port to Win32.</span>
01478 <span class="comment">//</span>
01479 <span class="comment">// Revision 1.44.8.2  2000/02/17 05:03:12  jimg</span>
01480 <span class="comment">// Added file and line number information to calls to InternalErr.</span>
01481 <span class="comment">// Resolved compile-time problems with read due to a change in its</span>
01482 <span class="comment">// parameter list given that errors are now reported using exceptions.</span>
01483 <span class="comment">//</span>
01484 <span class="comment">// Revision 1.44.8.1  2000/02/07 21:11:35  jgarcia</span>
01485 <span class="comment">// modified prototypes and implementations to use exceeption handling</span>
01486 <span class="comment">//</span>
01487 <span class="comment">// Revision 1.45  2000/01/27 06:29:56  jimg</span>
01488 <span class="comment">// Resolved conflicts from merge with release-3-1-4</span>
01489 <span class="comment">//</span>
01490 <span class="comment">// Revision 1.44.2.1  2000/01/26 23:56:52  jimg</span>
01491 <span class="comment">// Fixed the return type of string::find.</span>
01492 <span class="comment">//</span>
01493 <span class="comment">// Revision 1.44  1999/07/22 17:11:50  jimg</span>
01494 <span class="comment">// Merged changes from the release-3-0-2 branch</span>
01495 <span class="comment">//</span>
01496 <span class="comment">// Revision 1.43.4.1  1999/06/08 17:37:24  dan</span>
01497 <span class="comment">// Replace template definition of add_function with 3 explicit</span>
01498 <span class="comment">// instances of this method.  Required due to inability of gcc on certain</span>
01499 <span class="comment">// architectures to link properly using template definitions.</span>
01500 <span class="comment">//</span>
01501 <span class="comment">// Revision 1.43  1999/05/26 17:27:48  jimg</span>
01502 <span class="comment">// Replaced a serialization of an Error object with a throw to the outer layer.</span>
01503 <span class="comment">// This should help smooth getting errors to the outer layer of the servers so</span>
01504 <span class="comment">// they can be sent back to the clients reliably.</span>
01505 <span class="comment">//</span>
01506 <span class="comment">// Revision 1.42  1999/05/05 01:29:42  jimg</span>
01507 <span class="comment">// The member function parse_constraint() now throws an Error object so that</span>
01508 <span class="comment">// enclosing code will handle serializing the Error object.</span>
01509 <span class="comment">// The member function send() takes the CGI version as an extra argument. All</span>
01510 <span class="comment">// calls to the set_mime_*() functions include this version number.</span>
01511 <span class="comment">//</span>
01512 <span class="comment">// Revision 1.41  1999/04/29 02:29:28  jimg</span>
01513 <span class="comment">// Merge of no-gnu branch</span>
01514 <span class="comment">//</span>
01515 <span class="comment">// Revision 1.40  1999/03/24 23:37:14  jimg</span>
01516 <span class="comment">// Added support for the Int16, UInt16 and Float32 types</span>
01517 <span class="comment">//</span>
01518 <span class="comment">// Revision 1.39  1999/01/21 02:57:02  jimg</span>
01519 <span class="comment">// Added ce_function.h and call to add the projection function</span>
01520 <span class="comment">// `grid_selection_func' to the set of CE functions all servers know about.</span>
01521 <span class="comment">//</span>
01522 <span class="comment">// Revision 1.38  1999/01/13 16:59:05  jimg</span>
01523 <span class="comment">// Removed call to text_to_temp() (which copied a string to a temp file so that</span>
01524 <span class="comment">// the file could be parsed) with code that feeds the string directly into the</span>
01525 <span class="comment">// parser/scanner.</span>
01526 <span class="comment">//</span>
01527 <span class="comment">// Revision 1.37  1998/11/10 01:08:06  jimg</span>
01528 <span class="comment">// Changed code; now uses a list of Clause pointers instead of using a list of</span>
01529 <span class="comment">// Clause objects. This makes it simpler for the projection functions to add</span>
01530 <span class="comment">// `invisible' selection clauses.</span>
01531 <span class="comment">//</span>
01532 <span class="comment">// Revision 1.36 1998/10/21 16:38:12 jimg </span>
01533 <span class="comment">// The find_function() member function now checks for the name AND the</span>
01534 <span class="comment">// function type before returning a value. This means that a bool and</span>
01535 <span class="comment">// BaseType * function may have the same name but, because of their different</span>
01536 <span class="comment">// types, still work properly in context.</span>
01537 <span class="comment">//</span>
01538 <span class="comment">// Revision 1.35  1998/09/17 17:21:27  jimg</span>
01539 <span class="comment">// Changes for the new variable lookup scheme. Fields of ctor types no longer</span>
01540 <span class="comment">// need to be fully qualified. my.thing.f1 can now be named `f1' in a CE. Note</span>
01541 <span class="comment">// that if there are two `f1's in a dataset, the first will be silently used;</span>
01542 <span class="comment">// There's no warning about the situation. The new code in the var member</span>
01543 <span class="comment">// function passes a stack of BaseType pointers so that the projection</span>
01544 <span class="comment">// information (send_p field) can be set properly.</span>
01545 <span class="comment">// Added exact_match and leaf_match.</span>
01546 <span class="comment">//</span>
01547 <span class="comment">// Revision 1.34.6.2  1999/02/05 09:32:34  jimg</span>
01548 <span class="comment">// Fixed __unused__ so that it not longer clashes with Red Hat 5.2 inlined</span>
01549 <span class="comment">// math code. </span>
01550 <span class="comment">//</span>
01551 <span class="comment">// Revision 1.34.6.1  1999/02/02 21:56:57  jimg</span>
01552 <span class="comment">// String to string version</span>
01553 <span class="comment">//</span>
01554 <span class="comment">// Revision 1.34  1998/03/19 23:36:58  jimg</span>
01555 <span class="comment">// Fixed calls to set_mime_*().</span>
01556 <span class="comment">// Removed old code (that was surrounded by #if 0 ... #endif).</span>
01557 <span class="comment">// Added a version of parse_constraint(...) that works with FILE *</span>
01558 <span class="comment">// Completely hacked send(...). It now takes care of setting up the compression</span>
01559 <span class="comment">// sub process.</span>
01560 <span class="comment">// Removed `compressed' flag from parse_constraint(...).</span>
01561 <span class="comment">//</span>
01562 <span class="comment">// Revision 1.33  1998/02/11 21:57:12  jimg</span>
01563 <span class="comment">// Changed x_gzip to deflate. See Connect.cc/.h</span>
01564 <span class="comment">//</span>
01565 <span class="comment">// Revision 1.32  1997/04/15 18:02:45  jimg</span>
01566 <span class="comment">// Added optional argument to print_variable functions so that the variable can</span>
01567 <span class="comment">// be printed using the current constraint. Changed the call to</span>
01568 <span class="comment">// print_variable() in DDS::send() so that the constrained variable is printed.</span>
01569 <span class="comment">//</span>
01570 <span class="comment">// Revision 1.31  1997/03/08 19:03:38  jimg</span>
01571 <span class="comment">// Changed call to `unique()' to `unique_names()' (see util.cc).</span>
01572 <span class="comment">//</span>
01573 <span class="comment">// Revision 1.30  1997/03/05 08:12:18  jimg</span>
01574 <span class="comment">// Added calls to set_mime_binary() in DDS::send().</span>
01575 <span class="comment">//</span>
01576 <span class="comment">// Revision 1.29  1997/02/28 01:30:17  jimg</span>
01577 <span class="comment">// Corrected call to unique() in check_semantics() (added new String &amp;msg</span>
01578 <span class="comment">// parameter).</span>
01579 <span class="comment">//</span>
01580 <span class="comment">// Revision 1.28  1996/12/03 00:20:18  jimg</span>
01581 <span class="comment">// Added ostream and bool parameters to parse_constraint(). If the bool param</span>
01582 <span class="comment">// is true the the code assumes it is being run in the server. In that case</span>
01583 <span class="comment">// error objects are not evaluated but instead are serialized and set to the</span>
01584 <span class="comment">// client via the ostream.</span>
01585 <span class="comment">//</span>
01586 <span class="comment">// Revision 1.27  1996/12/02 23:15:43  jimg</span>
01587 <span class="comment">// Added `filename' field and access functions.</span>
01588 <span class="comment">//</span>
01589 <span class="comment">// Revision 1.26  1996/11/27 22:40:19  jimg</span>
01590 <span class="comment">// Added DDS as third parameter to function in the CE evaluator</span>
01591 <span class="comment">//</span>
01592 <span class="comment">// Revision 1.25  1996/11/13 19:23:07  jimg</span>
01593 <span class="comment">// Fixed debugging.</span>
01594 <span class="comment">//</span>
01595 <span class="comment">// Revision 1.24  1996/08/13 18:07:48  jimg</span>
01596 <span class="comment">// The parser (dds.y) is now called using the parser_arg object.</span>
01597 <span class="comment">// the member function eval_function() now returns a NULL BaseType * when the</span>
01598 <span class="comment">// function in the CE does not exist.</span>
01599 <span class="comment">//</span>
01600 <span class="comment">// Revision 1.23  1996/06/04 21:33:19  jimg</span>
01601 <span class="comment">// Multiple connections are now possible. It is now possible to open several</span>
01602 <span class="comment">// URLs at the same time and read from them in a round-robin fashion. To do</span>
01603 <span class="comment">// this I added data source and sink parameters to the serialize and</span>
01604 <span class="comment">// deserialize mfuncs. Connect was also modified so that it manages the data</span>
01605 <span class="comment">// source `object' (which is just an XDR pointer).</span>
01606 <span class="comment">//</span>
01607 <span class="comment">// Revision 1.22  1996/05/31 23:29:37  jimg</span>
01608 <span class="comment">// Updated copyright notice.</span>
01609 <span class="comment">//</span>
01610 <span class="comment">// Revision 1.21  1996/05/29 22:08:35  jimg</span>
01611 <span class="comment">// Made changes necessary to support CEs that return the value of a function</span>
01612 <span class="comment">// instead of the value of a variable. This was done so that it would be</span>
01613 <span class="comment">// possible to translate Sequences into Arrays without first reading the</span>
01614 <span class="comment">// entire sequence over the network.</span>
01615 <span class="comment">//</span>
01616 <span class="comment">// Revision 1.20  1996/05/22 18:05:08  jimg</span>
01617 <span class="comment">// Merged files from the old netio directory into the dap directory.</span>
01618 <span class="comment">// Removed the errmsg library from the software.</span>
01619 <span class="comment">//</span>
01620 <span class="comment">// Revision 1.19  1996/05/14 15:38:20  jimg</span>
01621 <span class="comment">// These changes have already been checked in once before. However, I</span>
01622 <span class="comment">// corrupted the source repository and restored it from a 5/9/96 backup</span>
01623 <span class="comment">// tape. The previous version's log entry should cover the changes.</span>
01624 <span class="comment">//</span>
01625 <span class="comment">// Revision 1.18  1996/04/04 19:15:14  jimg</span>
01626 <span class="comment">// Merged changes from version 1.1.1.</span>
01627 <span class="comment">// Fixed bug in send() - wrong number of arguments to serialize.</span>
01628 <span class="comment">//</span>
01629 <span class="comment">// Revision 1.17  1996/03/05 18:38:45  jimg</span>
01630 <span class="comment">// Moved many of the DDS member functions into the subclasses clause and</span>
01631 <span class="comment">// function. Also, because the rvalue and func_rvalue classes (defined in</span>
01632 <span class="comment">// expr.h ane expr.cc) were expanded, most of the evaluation software has been</span>
01633 <span class="comment">// removed.</span>
01634 <span class="comment">// Unnecessary accessor member functions have been removed since clause and</span>
01635 <span class="comment">// function now have their own ctors.</span>
01636 <span class="comment">//</span>
01637 <span class="comment">// Revision 1.16  1996/02/01 17:43:08  jimg</span>
01638 <span class="comment">// Added support for lists as operands in constraint expressions.</span>
01639 <span class="comment">//</span>
01640 <span class="comment">// Revision 1.15  1995/12/09  01:06:38  jimg</span>
01641 <span class="comment">// Added changes so that relational operators will work properly for all the</span>
01642 <span class="comment">// datatypes (including Sequences). The relational ops are evaluated in</span>
01643 <span class="comment">// DDS::eval_constraint() after being parsed by DDS::parse_constraint().</span>
01644 <span class="comment">//</span>
01645 <span class="comment">// Revision 1.14  1995/12/06  21:11:24  jimg</span>
01646 <span class="comment">// Added print_constrained(): Prints a constrained DDS.</span>
01647 <span class="comment">// Added eval_constraint(): Evaluates a constraint expression in the</span>
01648 <span class="comment">// environment of the current DDS.</span>
01649 <span class="comment">// Added send(): combines reading, serailizing and constraint evaluation.</span>
01650 <span class="comment">// Added mark(): used to mark variables as part of the current projection.</span>
01651 <span class="comment">// Fixed some of the parse() and print() mfuncs to take uniform parameter types</span>
01652 <span class="comment">// (ostream and FILE *).</span>
01653 <span class="comment">// Fixed the constructors to work with const objects.</span>
01654 <span class="comment">//</span>
01655 <span class="comment">// Revision 1.13  1995/10/23  23:20:50  jimg</span>
01656 <span class="comment">// Added _send_p and _read_p fields (and their accessors) along with the</span>
01657 <span class="comment">// virtual mfuncs set_send_p() and set_read_p().</span>
01658 <span class="comment">//</span>
01659 <span class="comment">// Revision 1.12  1995/08/23  00:06:30  jimg</span>
01660 <span class="comment">// Changed from old mfuncs to new(er) ones.</span>
01661 <span class="comment">//</span>
01662 <span class="comment">// Revision 1.11.2.2  1996/03/01 00:06:09  jimg</span>
01663 <span class="comment">// Removed bad attempt at multiple connect implementation.</span>
01664 <span class="comment">//</span>
01665 <span class="comment">// Revision 1.11.2.1  1996/02/23 21:37:24  jimg</span>
01666 <span class="comment">// Updated for new configure.in.</span>
01667 <span class="comment">// Fixed problems on Solaris 2.4.</span>
01668 <span class="comment">//</span>
01669 <span class="comment">// Revision 1.11  1995/07/09  21:28:55  jimg</span>
01670 <span class="comment">// Added copyright notice.</span>
01671 <span class="comment">//</span>
01672 <span class="comment">// Revision 1.10  1995/05/10  13:45:13  jimg</span>
01673 <span class="comment">// Changed the name of the configuration header file from `config.h' to</span>
01674 <span class="comment">// `config_dap.h' so that other libraries could have header files which were</span>
01675 <span class="comment">// installed in the DODS include directory without overwriting this one. Each</span>
01676 <span class="comment">// config header should follow the convention config_&lt;name&gt;.h.</span>
01677 <span class="comment">//</span>
01678 <span class="comment">// Revision 1.9  1994/12/09  21:37:24  jimg</span>
01679 <span class="comment">// Added &lt;unistd.h&gt; to the include files.</span>
01680 <span class="comment">//</span>
01681 <span class="comment">// Revision 1.8  1994/12/07  21:23:16  jimg</span>
01682 <span class="comment">// Removed config</span>
01683 <span class="comment">//</span>
01684 <span class="comment">// Revision 1.7  1994/11/22  14:05:40  jimg</span>
01685 <span class="comment">// Added code for data transmission to parts of the type hierarchy. Not</span>
01686 <span class="comment">// complete yet.</span>
01687 <span class="comment">// Fixed erros in type hierarchy headers (typos, incorrect comments, ...).</span>
01688 <span class="comment">//</span>
01689 <span class="comment">// Revision 1.6  1994/11/03  04:58:02  reza</span>
01690 <span class="comment">// Added two overloading for function parse to make it consistent with DAS</span>
01691 <span class="comment">// class. </span>
01692 <span class="comment">//</span>
01693 <span class="comment">// Revision 1.5  1994/10/18  00:20:46  jimg</span>
01694 <span class="comment">// Added copy ctor, dtor, duplicate, operator=.</span>
01695 <span class="comment">// Added var() for const char * (to avoid confusion between char * and</span>
01696 <span class="comment">// Pix (which is void *)).</span>
01697 <span class="comment">// Switched to errmsg library.</span>
01698 <span class="comment">// Added formatting to print().</span>
01699 <span class="comment">//</span>
01700 <span class="comment">// Revision 1.4  1994/10/05  16:34:14  jimg</span>
01701 <span class="comment">// Fixed bug in the parse function(s): the bison generated parser returns</span>
01702 <span class="comment">// 1 on error, 0 on success, but parse() was not checking for this.</span>
01703 <span class="comment">// Instead it returned the value of bison's parser function.</span>
01704 <span class="comment">// Changed types of `status' in print and parser functions from int to bool.</span>
01705 <span class="comment">//</span>
01706 <span class="comment">// Revision 1.3  1994/09/23  14:42:22  jimg</span>
01707 <span class="comment">// Added mfunc check_semantics().</span>
01708 <span class="comment">// Replaced print mfunc stub with real code.</span>
01709 <span class="comment">// Fixed some errors in comments.</span>
01710 <span class="comment">//</span>
01711 <span class="comment">// Revision 1.2  1994/09/15  21:08:39  jimg</span>
01712 <span class="comment">// Added many classes to the BaseType hierarchy - the complete set of types</span>
01713 <span class="comment">// described in the DODS API design documet is now represented.</span>
01714 <span class="comment">// The parser can parse DDS files.</span>
01715 <span class="comment">// Fixed many small problems with BaseType.</span>
01716 <span class="comment">// Added CtorType.</span>
01717 <span class="comment">//</span>
01718 <span class="comment">// Revision 1.1  1994/09/08  21:09:40  jimg</span>
01719 <span class="comment">// First version of the Dataset descriptor class.</span>
01720 <span class="comment">// </span>
01721 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Feb 4 23:42:59 2004 for libdap++ by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
