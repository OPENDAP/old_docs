<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libdap++: Structure.cc Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Structure.cc</h1><a href="Structure_8cc.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00002 <span class="comment">// -*- mode: c++; c-basic-offset:4 -*-</span>
00003 
00004 <span class="comment">// This file is part of libdap, A C++ implementation of the OPeNDAP Data</span>
00005 <span class="comment">// Access Protocol.</span>
00006 
00007 <span class="comment">// Copyright (c) 2002,2003 OPeNDAP, Inc.</span>
00008 <span class="comment">// Author: James Gallagher &lt;jgallagher@opendap.org&gt;</span>
00009 <span class="comment">//</span>
00010 <span class="comment">// This library is free software; you can redistribute it and/or</span>
00011 <span class="comment">// modify it under the terms of the GNU Lesser General Public</span>
00012 <span class="comment">// License as published by the Free Software Foundation; either</span>
00013 <span class="comment">// version 2.1 of the License, or (at your option) any later version.</span>
00014 <span class="comment">// </span>
00015 <span class="comment">// This library is distributed in the hope that it will be useful,</span>
00016 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00017 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00018 <span class="comment">// Lesser General Public License for more details.</span>
00019 <span class="comment">// </span>
00020 <span class="comment">// You should have received a copy of the GNU Lesser General Public</span>
00021 <span class="comment">// License along with this library; if not, write to the Free Software</span>
00022 <span class="comment">// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00023 <span class="comment">//</span>
00024 <span class="comment">// You can contact OPeNDAP, Inc. at PO Box 112, Saunderstown, RI. 02874-0112.</span>
00025  
00026 <span class="comment">// (c) COPYRIGHT URI/MIT 1994-1999</span>
00027 <span class="comment">// Please read the full copyright statement in the file COPYRIGHT_URI.</span>
00028 <span class="comment">//</span>
00029 <span class="comment">// Authors:</span>
00030 <span class="comment">//      jhrg,jimg       James Gallagher &lt;jgallagher@gso.uri.edu&gt;</span>
00031 
00032 <span class="comment">// Implementation for the class Structure</span>
00033 <span class="comment">//</span>
00034 <span class="comment">// jhrg 9/14/94</span>
00035 
00036 <span class="preprocessor">#ifdef _GNUG_</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#pragma implementation</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00039 <span class="preprocessor"></span>
00040 <span class="preprocessor">#include "<a class="code" href="config__dap_8h.html">config_dap.h</a>"</span>
00041 
00042 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00043 
00044 <span class="preprocessor">#include "<a class="code" href="Structure_8h.html">Structure.h</a>"</span>
00045 <span class="preprocessor">#include "<a class="code" href="util_8h.html">util.h</a>"</span>
00046 <span class="preprocessor">#include "<a class="code" href="debug_8h.html">debug.h</a>"</span>
00047 <span class="preprocessor">#include "<a class="code" href="InternalErr_8h.html">InternalErr.h</a>"</span>
00048 <span class="preprocessor">#include "<a class="code" href="escaping_8h.html">escaping.h</a>"</span>
00049 <span class="preprocessor">#include "<a class="code" href="BTIterAdapter_8h.html">BTIterAdapter.h</a>"</span>
00050 
00051 <span class="preprocessor">#ifdef TRACE_NEW</span>
00052 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="trace__new_8h.html">trace_new.h</a>"</span>
00053 <span class="preprocessor">#endif</span>
00054 <span class="preprocessor"></span>
00055 <span class="keyword">using</span> std::cerr;
00056 <span class="keyword">using</span> std::endl;
00057 
00058 <span class="comment">// Jose Garcia 1/26/2000</span>
00059 <span class="comment">// Note: all asserts of nature</span>
00060 <span class="comment">// for (Pix p = _vars.first(); p; _vars.next(p)) {</span>
00061 <span class="comment">//  assert(_vars(p));</span>
00062 <span class="comment">// had been commented out, later when we get sure</span>
00063 <span class="comment">// we do not need then we can remove them all.</span>
00064 
00065 <span class="keywordtype">void</span>
00066 <a class="code" href="classConstructor.html#Structureb0">Structure::_duplicate</a>(<span class="keyword">const</span> <a class="code" href="classStructure.html">Structure</a> &amp;s)
00067 {
00068     <a class="code" href="classStructure.html">Structure</a> &amp;cs = const_cast&lt;Structure &amp;&gt;(s);
00069 
00070     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Copying strucutre: "</span> &lt;&lt; <a class="code" href="classBaseType.html#Vectora27">name</a>() &lt;&lt; endl);
00071 
00072     <span class="keywordflow">for</span> (<a class="code" href="classStructure.html#Structurew1">Vars_iter</a> i = cs.<a class="code" href="classStructure.html#Structurer0">_vars</a>.begin(); i != cs.<a class="code" href="classStructure.html#Structurer0">_vars</a>.end(); i++)
00073     {
00074     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Copying field: "</span> &lt;&lt; cs.<a class="code" href="classBaseType.html#Vectora27">name</a>() &lt;&lt; endl);
00075     <span class="comment">// Jose Garcia</span>
00076     <span class="comment">// I think this assert here is part of a debugging </span>
00077     <span class="comment">// process since it is going along with a DBG call</span>
00078     <span class="comment">// I leave it here since it can be remove by defining NDEBUG.</span>
00079     <span class="comment">// assert(*i);</span>
00080     <a class="code" href="classBaseType.html">BaseType</a> *btp = (*i)-&gt;ptr_duplicate();
00081     btp-&gt;<a class="code" href="classBaseType.html#Vectora42">set_parent</a>(<span class="keyword">this</span>);
00082     _vars.push_back(btp);
00083     }
00084 }
00085 
<a name="l00093"></a><a class="code" href="classStructure.html#Structurea0">00093</a> <a class="code" href="classStructure.html#Structurea0">Structure::Structure</a>(<span class="keyword">const</span> string &amp;n) :<a class="code" href="classConstructor.html">Constructor</a>(n, <a class="code" href="BaseType_8h.html#a21a17">dods_structure_c</a>)
00094 {
00095 }
00096 
<a name="l00098"></a><a class="code" href="classStructure.html#Structurea1">00098</a> <a class="code" href="classStructure.html#Structurea0">Structure::Structure</a>(<span class="keyword">const</span> <a class="code" href="classStructure.html">Structure</a> &amp;rhs) :<a class="code" href="classConstructor.html">Constructor</a>(rhs)
00099 {
00100     <a class="code" href="classConstructor.html#Structureb0">_duplicate</a>(rhs);
00101 }
00102 
<a name="l00103"></a><a class="code" href="classStructure.html#Structurea2">00103</a> <a class="code" href="classStructure.html#Structurea2">Structure::~Structure</a>()
00104 {
00105     <span class="keywordflow">for</span> (<a class="code" href="classStructure.html#Structurew1">Vars_iter</a> i = _vars.begin(); i != _vars.end(); i++)
00106     {
00107     <a class="code" href="classBaseType.html">BaseType</a> *btp = *i ;
00108     <span class="keyword">delete</span> btp ;
00109     }
00110 }
00111 
00112 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00113"></a><a class="code" href="classStructure.html#Structurea4">00113</a> <a class="code" href="classStructure.html#Structurea4">Structure::ptr_duplicate</a>()
00114 {
00115     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classStructure.html#Structurea0">Structure</a>(*<span class="keyword">this</span>);
00116 }
00117 
00118 <a class="code" href="classStructure.html">Structure</a> &amp;
<a name="l00119"></a><a class="code" href="classStructure.html#Structurea3">00119</a> <a class="code" href="classStructure.html#Structurea3">Structure::operator=</a>(<span class="keyword">const</span> <a class="code" href="classStructure.html">Structure</a> &amp;rhs)
00120 {
00121     <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;rhs)
00122     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00123 
00124     dynamic_cast&lt;Constructor &amp;&gt;(*this) = rhs; <span class="comment">// run Constructor=</span>
00125 
00126     <a class="code" href="classConstructor.html#Structureb0">_duplicate</a>(rhs);
00127 
00128     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00129 }
00130 
00131 <span class="keywordtype">int</span>
<a name="l00132"></a><a class="code" href="classStructure.html#Structurea5">00132</a> <a class="code" href="classStructure.html#Structurea5">Structure::element_count</a>(<span class="keywordtype">bool</span> leaves)
00133 {
00134     <span class="keywordflow">if</span> (!leaves)
00135     <span class="keywordflow">return</span> _vars.size();
00136     <span class="keywordflow">else</span> {
00137     <span class="keywordtype">int</span> i = 0;
00138     <span class="keywordflow">for</span> (<a class="code" href="classStructure.html#Structurew1">Vars_iter</a> j = _vars.begin(); j != _vars.end(); j++)
00139     {
00140         j += (*j)-&gt;element_count(leaves);
00141     }
00142     <span class="keywordflow">return</span> i;
00143     }
00144 }
00145 
00146 <span class="keywordtype">bool</span> 
<a name="l00147"></a><a class="code" href="classStructure.html#Structurea6">00147</a> <a class="code" href="classStructure.html#Structurea6">Structure::is_linear</a>()
00148 {
00149     <span class="keywordtype">bool</span> linear = <span class="keyword">true</span>;
00150     <span class="keywordflow">for</span> (<a class="code" href="classStructure.html#Structurew1">Vars_iter</a> i = _vars.begin(); linear &amp;&amp; i != _vars.end(); i++)
00151     {
00152     <span class="keywordflow">if</span> ((*i)-&gt;type() == <a class="code" href="BaseType_8h.html#a21a17">dods_structure_c</a>)
00153         linear = linear &amp;&amp; dynamic_cast&lt;Structure*&gt;((*i))-&gt;is_linear();
00154     <span class="keywordflow">else</span> 
00155         linear = linear &amp;&amp; (*i)-&gt;is_simple_type();
00156     }
00157 
00158     <span class="keywordflow">return</span> linear;
00159 }
00160 
00161 <span class="keywordtype">void</span>
<a name="l00162"></a><a class="code" href="classStructure.html#Structurea7">00162</a> <a class="code" href="classStructure.html#Structurea7">Structure::set_send_p</a>(<span class="keywordtype">bool</span> state)
00163 {
00164     <span class="keywordflow">for</span> (<a class="code" href="classStructure.html#Structurew1">Vars_iter</a> i = _vars.begin(); i != _vars.end(); i++)
00165     {
00166     <span class="comment">//assert(*i);</span>
00167     (*i)-&gt;set_send_p(state);
00168     }
00169 
00170     <a class="code" href="classBaseType.html#Urla27">BaseType::set_send_p</a>(state);
00171 }
00172 
00173 <span class="keywordtype">void</span>
<a name="l00174"></a><a class="code" href="classStructure.html#Structurea8">00174</a> <a class="code" href="classStructure.html#Structurea8">Structure::set_read_p</a>(<span class="keywordtype">bool</span> state)
00175 {
00176     <span class="keywordflow">for</span> (<a class="code" href="classStructure.html#Structurew1">Vars_iter</a> i = _vars.begin(); i != _vars.end(); i++)
00177     {
00178     <span class="comment">//assert(*i);</span>
00179     (*i)-&gt;set_read_p(state);
00180     }
00181 
00182     <a class="code" href="classBaseType.html#Urla25">BaseType::set_read_p</a>(state);
00183 }
00184 
00190 <span class="keywordtype">void</span>
<a name="l00191"></a><a class="code" href="classStructure.html#Structurea9">00191</a> <a class="code" href="classStructure.html#Structurea9">Structure::set_in_selection</a>(<span class="keywordtype">bool</span> state)
00192 {
00193     <span class="keywordflow">for</span> (<a class="code" href="classStructure.html#Structurew1">Vars_iter</a> i = _vars.begin(); i != _vars.end(); i++) {
00194     (*i)-&gt;set_in_selection(state);
00195     }
00196 
00197     <a class="code" href="classBaseType.html#Vectora40">BaseType::set_in_selection</a>(state);
00198 }
00199 
00200 <span class="comment">// NB: Part defaults to nil for this class</span>
00201 
00206 <span class="keywordtype">void</span> 
<a name="l00207"></a><a class="code" href="classStructure.html#Structurea17">00207</a> <a class="code" href="classStructure.html#Structurea17">Structure::add_var</a>(<a class="code" href="classBaseType.html">BaseType</a> *bt, Part)
00208 {
00209     <span class="comment">// Jose Garcia</span>
00210     <span class="comment">// Passing and invalid pointer to an object is a developer's error.</span>
00211     <span class="keywordflow">if</span> (!bt)
00212     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, 
00213               <span class="stringliteral">"The BaseType parameter cannot be null."</span>);
00214 
00215     <span class="comment">// Jose Garcia</span>
00216     <span class="comment">// Now we add a copy of bt so the external user is able to destroy bt as</span>
00217     <span class="comment">// he/she whishes. The policy is: "If it is allocated outside, it is</span>
00218     <span class="comment">// deallocated outside, if it is allocated inside, it is deallocated</span>
00219     <span class="comment">// inside"</span>
00220     <a class="code" href="classBaseType.html">BaseType</a> *btp = bt-&gt;<a class="code" href="classBaseType.html#Constructora6">ptr_duplicate</a>();
00221     btp-&gt;<a class="code" href="classBaseType.html#Vectora42">set_parent</a>(<span class="keyword">this</span>);
00222     _vars.push_back(btp);
00223 }
00224 
00225 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00226"></a><a class="code" href="classStructure.html#Structurea10">00226</a> <a class="code" href="classStructure.html#Structurea10">Structure::width</a>()
00227 {
00228     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz = 0;
00229 
00230     <span class="keywordflow">for</span>( <a class="code" href="classStructure.html#Structurew1">Vars_iter</a> i = _vars.begin(); i != _vars.end(); i++)
00231     {
00232     sz += (*i)-&gt;width();
00233     }
00234 
00235     <span class="keywordflow">return</span> sz;
00236 }
00237 
00238 <span class="comment">// Returns: false if an error was detected, true otherwise. </span>
00239 <span class="comment">// NB: this means that serialize() returns true when the CE evaluates to</span>
00240 <span class="comment">// false. This bug might be fixed using exceptions.</span>
00241 
00242 <span class="keywordtype">bool</span>
<a name="l00243"></a><a class="code" href="classStructure.html#Structurea11">00243</a> <a class="code" href="classStructure.html#Structurea11">Structure::serialize</a>(<span class="keyword">const</span> string &amp;dataset, <a class="code" href="classDDS.html">DDS</a> &amp;dds, XDR *sink, 
00244              <span class="keywordtype">bool</span> ce_eval)
00245 {
00246     dds.<a class="code" href="classDDS.html#DDSa18">timeout_on</a>();
00247 
00248     <span class="keywordflow">if</span> (!<a class="code" href="classBaseType.html#Vectora37">read_p</a>())
00249     <a class="code" href="classBaseType.html#Vectora45">read</a>(dataset);      <span class="comment">// read() throws Error and InternalErr</span>
00250 
00251     <span class="keywordflow">if</span> (ce_eval &amp;&amp; !dds.<a class="code" href="classDDS.html#DDSa31">eval_selection</a>(dataset))
00252     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00253 
00254     dds.<a class="code" href="classDDS.html#DDSa19">timeout_off</a>();
00255 
00256     <span class="keywordflow">for</span> (<a class="code" href="classStructure.html#Structurew1">Vars_iter</a> i = _vars.begin(); i != _vars.end(); i++) {
00257     <span class="keywordflow">if</span> ((*i)-&gt;send_p()) {
00258         (*i)-&gt;serialize(dataset, dds, sink, <span class="keyword">false</span>);
00259     }
00260     }
00261 
00262     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00263 }
00264 
00265 <span class="keywordtype">bool</span>
<a name="l00266"></a><a class="code" href="classStructure.html#Structurea12">00266</a> <a class="code" href="classStructure.html#Structurea12">Structure::deserialize</a>(XDR *source, <a class="code" href="classDDS.html">DDS</a> *dds, <span class="keywordtype">bool</span> reuse)
00267 {
00268     <span class="keywordflow">for</span> (<a class="code" href="classStructure.html#Structurew1">Vars_iter</a> i = _vars.begin(); i != _vars.end(); i++)
00269     {
00270     (*i)-&gt;deserialize(source, dds, reuse);
00271     }
00272 
00273     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00274 }
00275 
00279 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00280"></a><a class="code" href="classStructure.html#Structurea13">00280</a> <a class="code" href="classStructure.html#Structurea13">Structure::val2buf</a>(<span class="keywordtype">void</span> *, <span class="keywordtype">bool</span>)
00281 {
00282     <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(<a class="code" href="classStructure.html">Structure</a>);
00283 }
00284 
00286 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00287"></a><a class="code" href="classStructure.html#Structurea14">00287</a> <a class="code" href="classStructure.html#Structurea14">Structure::buf2val</a>(<span class="keywordtype">void</span> **)
00288 {
00289     <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(<a class="code" href="classStructure.html">Structure</a>);
00290 }
00291 
00292 <span class="comment">// If EXACT is true, then use breadth-first search and assume that NAME is</span>
00293 <span class="comment">// the path to a variable where a dot (.) separates the ctor variable(s) from</span>
00294 <span class="comment">// the variable to be found. If S is not null, push the path to NAME on the</span>
00295 <span class="comment">// statck.</span>
00296 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00297"></a><a class="code" href="classStructure.html#Structurea15">00297</a> <a class="code" href="classStructure.html#Structurea15">Structure::var</a>(<span class="keyword">const</span> string &amp;n, <span class="keywordtype">bool</span> exact, <a class="code" href="BaseType_8h.html#a1">btp_stack</a> *s)
00298 {
00299     string <a class="code" href="classBaseType.html#Vectora27">name</a> = <a class="code" href="escaping_8cc.html#a7">www2id</a>(n);
00300 
00301     <span class="keywordflow">if</span> (exact)
00302     <span class="keywordflow">return</span> exact_match(name, s);
00303     <span class="keywordflow">else</span>
00304     <span class="keywordflow">return</span> leaf_match(name, s);
00305 }
00306 
00307 <span class="comment">// Get rid of this method ASAP.</span>
00308 <span class="comment">// A depth-first search for leaf nodes matching NAME.</span>
00309 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00310"></a><a class="code" href="classStructure.html#Structurea16">00310</a> <a class="code" href="classStructure.html#Structurea15">Structure::var</a>(<span class="keyword">const</span> string &amp;n, <a class="code" href="BaseType_8h.html#a1">btp_stack</a> &amp;s)
00311 {
00312     string <a class="code" href="classBaseType.html#Vectora27">name</a> = <a class="code" href="escaping_8cc.html#a7">www2id</a>(n);
00313 
00314     <a class="code" href="classBaseType.html">BaseType</a> *btp = exact_match(name, &amp;s);
00315     <span class="keywordflow">if</span> (btp)
00316     <span class="keywordflow">return</span> btp;
00317 
00318     <span class="keywordflow">return</span> leaf_match(name, &amp;s);
00319 }
00320 
00321 <span class="comment">// If S is not null, push the path of the depth-first search for a</span>
00322 <span class="comment">// leaf-node called NAME onto S.</span>
00323 <a class="code" href="classBaseType.html">BaseType</a> *
00324 Structure::leaf_match(<span class="keyword">const</span> string &amp;name, <a class="code" href="BaseType_8h.html#a1">btp_stack</a> *s)
00325 {
00326     <span class="keywordflow">for</span> (<a class="code" href="classStructure.html#Structurew1">Vars_iter</a> i = _vars.begin(); i != _vars.end(); i++)
00327     {
00328     <span class="keywordflow">if</span> ((*i)-&gt;name() == name) {
00329         <span class="keywordflow">if</span> (s) {
00330         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Pushing "</span> &lt;&lt; this-&gt;name() &lt;&lt; endl);
00331         s-&gt;push(static_cast&lt;BaseType *&gt;(<span class="keyword">this</span>));
00332         }
00333         <span class="keywordflow">return</span> *i;
00334     }
00335         <span class="keywordflow">if</span> ((*i)-&gt;is_constructor_type()) {
00336         <a class="code" href="classBaseType.html">BaseType</a> *btp = (*i)-&gt;var(name, <span class="keyword">false</span>, s);
00337         <span class="keywordflow">if</span> (btp) {
00338         <span class="keywordflow">if</span> (s) {
00339             <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Pushing "</span> &lt;&lt; this-&gt;name() &lt;&lt; endl);
00340             s-&gt;push(static_cast&lt;BaseType *&gt;(<span class="keyword">this</span>));
00341         }
00342         <span class="keywordflow">return</span> btp;
00343         }
00344     }
00345     }
00346 
00347     <span class="keywordflow">return</span> 0;
00348 }
00349 
00351 <a class="code" href="classBaseType.html">BaseType</a> *
00352 Structure::exact_match(<span class="keyword">const</span> string &amp;name, <a class="code" href="BaseType_8h.html#a1">btp_stack</a> *s)
00353 {
00354     <span class="keywordflow">for</span> (<a class="code" href="classStructure.html#Structurew1">Vars_iter</a> i = _vars.begin(); i != _vars.end(); i++)
00355     {
00356     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Looking at "</span> &lt;&lt; (*i)-&gt;name() &lt;&lt; <span class="stringliteral">" in: "</span> &lt;&lt; *i
00357         &lt;&lt; endl);
00358     <span class="keywordflow">if</span> ((*i)-&gt;name() == name) {
00359         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Found "</span> &lt;&lt; (*i)-&gt;name() &lt;&lt; <span class="stringliteral">" in: "</span> 
00360         &lt;&lt; *i &lt;&lt; endl);
00361         <span class="keywordflow">if</span> (s) {
00362         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Pushing "</span> &lt;&lt; this-&gt;name() &lt;&lt; endl);
00363         s-&gt;push(static_cast&lt;BaseType *&gt;(<span class="keyword">this</span>));
00364         }
00365         <span class="keywordflow">return</span> *i;
00366     }
00367     }
00368 
00369     string::size_type dot_pos = name.find(<span class="stringliteral">"."</span>); <span class="comment">// zero-based index of `.'</span>
00370     <span class="keywordflow">if</span> (dot_pos != string::npos) {
00371     string aggregate = name.substr(0, dot_pos);
00372     string field = name.substr(dot_pos + 1);
00373 
00374     <a class="code" href="classBaseType.html">BaseType</a> *agg_ptr = <a class="code" href="classStructure.html#Structurea15">var</a>(aggregate);
00375     <span class="keywordflow">if</span> (agg_ptr) {
00376         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Descending into "</span> &lt;&lt; agg_ptr-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>() &lt;&lt; endl);
00377         <span class="keywordflow">if</span> (s) {
00378         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Pushing "</span> &lt;&lt; this-&gt;name() &lt;&lt; endl);
00379         s-&gt;push(static_cast&lt;BaseType *&gt;(<span class="keyword">this</span>));
00380         }
00381         <span class="keywordflow">return</span> agg_ptr-&gt;<a class="code" href="classBaseType.html#Vectora44">var</a>(field, <span class="keyword">true</span>, s); <span class="comment">// recurse</span>
00382     }
00383     <span class="keywordflow">else</span>
00384         <span class="keywordflow">return</span> 0;       <span class="comment">// qualified names must be *fully* qualified</span>
00385     }
00386 
00387     <span class="keywordflow">return</span> 0;
00388 }
00389 
00393 Pix
<a name="l00394"></a><a class="code" href="classStructure.html#Structurea18">00394</a> <a class="code" href="classStructure.html#Structurea18">Structure::first_var</a>()
00395 {
00396     <span class="keywordflow">if</span> (_vars.empty())
00397     <span class="keywordflow">return</span> 0;
00398 
00399     <a class="code" href="classBTIterAdapter.html">BTIterAdapter</a> *i = <span class="keyword">new</span> <a class="code" href="classBTIterAdapter.html">BTIterAdapter</a>( _vars ) ;
00400     i-&gt;<a class="code" href="classBTIterAdapter.html#BTIterAdapterz62_0">first</a>() ;
00401     <span class="keywordflow">return</span> i ;
00402 }
00403 
00404 <a class="code" href="classStructure.html#Structurew1">Structure::Vars_iter</a>
<a name="l00405"></a><a class="code" href="classStructure.html#Structurea21">00405</a> <a class="code" href="classStructure.html#Structurea21">Structure::var_begin</a>()
00406 {
00407     <span class="keywordflow">return</span> _vars.begin() ;
00408 }
00409 
00410 <a class="code" href="classStructure.html#Structurew1">Structure::Vars_iter</a>
<a name="l00411"></a><a class="code" href="classStructure.html#Structurea22">00411</a> <a class="code" href="classStructure.html#Structurea22">Structure::var_end</a>()
00412 {
00413     <span class="keywordflow">return</span> _vars.end() ;
00414 }
00415 
00419 <a class="code" href="classStructure.html#Structurew1">Structure::Vars_iter</a>
<a name="l00420"></a><a class="code" href="classStructure.html#Structurea23">00420</a> <a class="code" href="classStructure.html#Structurea23">Structure::get_vars_iter</a>(<span class="keywordtype">int</span> i)
00421 {
00422     <span class="keywordflow">return</span> _vars.begin() + i;
00423 }
00424 
00429 <span class="keywordtype">void</span>
<a name="l00430"></a><a class="code" href="classStructure.html#Structurea19">00430</a> <a class="code" href="classStructure.html#Structurea19">Structure::next_var</a>(Pix p)
00431 {
00432     p.next();
00433 }
00434 
00439 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00440"></a><a class="code" href="classStructure.html#Structurea20">00440</a> <a class="code" href="classStructure.html#Structurea15">Structure::var</a>(Pix p)
00441 {
00442     <a class="code" href="classBTIterAdapter.html">BTIterAdapter</a> *i = (<a class="code" href="classBTIterAdapter.html">BTIterAdapter</a> *)p.getIterator() ;
00443     <span class="keywordflow">if</span>( i ) {
00444     <span class="keywordflow">return</span> i-&gt;<a class="code" href="classBTIterAdapter.html#BTIterAdapterz64_0">entry</a>() ;
00445     }
00446     <span class="keywordflow">return</span> 0 ;
00447 }
00448 
00449 <span class="keywordtype">void</span>
<a name="l00450"></a><a class="code" href="classStructure.html#Structurea24">00450</a> <a class="code" href="classStructure.html#Structurea24">Structure::print_decl</a>(ostream &amp;os, string space, <span class="keywordtype">bool</span> print_semi,
00451               <span class="keywordtype">bool</span> constraint_info, <span class="keywordtype">bool</span> constrained)
00452 {
00453     <span class="keywordflow">if</span> (constrained &amp;&amp; !<a class="code" href="classBaseType.html#Vectora38">send_p</a>())
00454     <span class="keywordflow">return</span>;
00455 
00456     os &lt;&lt; space &lt;&lt; <a class="code" href="classBaseType.html#Vectora31">type_name</a>() &lt;&lt; <span class="stringliteral">" {"</span> &lt;&lt; endl;
00457     <span class="keywordflow">for</span> (<a class="code" href="classStructure.html#Structurew1">Vars_iter</a> i = _vars.begin(); i != _vars.end(); i++)
00458     {
00459     (*i)-&gt;print_decl(os, space + <span class="stringliteral">"    "</span>, <span class="keyword">true</span>,
00460              constraint_info, constrained);
00461     }
00462     os &lt;&lt; space &lt;&lt; <span class="stringliteral">"} "</span> &lt;&lt; <a class="code" href="escaping_8cc.html#a5">id2www</a>(<a class="code" href="classBaseType.html#Vectora27">name</a>());
00463 
00464     <span class="keywordflow">if</span> (constraint_info) {
00465     <span class="keywordflow">if</span> (<a class="code" href="classBaseType.html#Vectora38">send_p</a>())
00466         cout &lt;&lt; <span class="stringliteral">": Send True"</span>;
00467     <span class="keywordflow">else</span>
00468         cout &lt;&lt; <span class="stringliteral">": Send False"</span>;
00469     }
00470 
00471     <span class="keywordflow">if</span> (print_semi)
00472     os &lt;&lt; <span class="stringliteral">";"</span> &lt;&lt; endl;
00473 }
00474 
00475 <span class="keywordtype">void</span>
<a name="l00476"></a><a class="code" href="classStructure.html#Structurea25">00476</a> <a class="code" href="classStructure.html#Structurea24">Structure::print_decl</a>(FILE *out, string space, <span class="keywordtype">bool</span> print_semi,
00477               <span class="keywordtype">bool</span> constraint_info, <span class="keywordtype">bool</span> constrained)
00478 {
00479     <span class="keywordflow">if</span> (constrained &amp;&amp; !<a class="code" href="classBaseType.html#Vectora38">send_p</a>())
00480     <span class="keywordflow">return</span>;
00481 
00482     fprintf( out, <span class="stringliteral">"%s%s {\n"</span>, space.c_str(), <a class="code" href="classBaseType.html#Vectora31">type_name</a>().c_str() ) ;
00483     <span class="keywordflow">for</span> (<a class="code" href="classStructure.html#Structurew0">Vars_citer</a> i = _vars.begin(); i != _vars.end(); i++)
00484     {
00485     (*i)-&gt;print_decl(out, space + <span class="stringliteral">"    "</span>, <span class="keyword">true</span>,
00486              constraint_info, constrained);
00487     }
00488     fprintf( out, <span class="stringliteral">"%s} %s"</span>, space.c_str(), <a class="code" href="escaping_8cc.html#a5">id2www</a>( <a class="code" href="classBaseType.html#Vectora27">name</a>() ).c_str() ) ;
00489 
00490     <span class="keywordflow">if</span> (constraint_info) {
00491     <span class="keywordflow">if</span> (<a class="code" href="classBaseType.html#Vectora38">send_p</a>())
00492         cout &lt;&lt; <span class="stringliteral">": Send True"</span>;
00493     <span class="keywordflow">else</span>
00494         cout &lt;&lt; <span class="stringliteral">": Send False"</span>;
00495     }
00496 
00497     <span class="keywordflow">if</span> (print_semi)
00498     fprintf( out, <span class="stringliteral">";\n"</span> ) ;
00499 }
00500 
00501 <span class="comment">// print the values of the contained variables</span>
00502 
00503 <span class="keywordtype">void</span> 
<a name="l00504"></a><a class="code" href="classStructure.html#Structurea26">00504</a> <a class="code" href="classStructure.html#Structurea26">Structure::print_val</a>(ostream &amp;os, string space, <span class="keywordtype">bool</span> print_decl_p)
00505 {
00506     <span class="keywordflow">if</span> (print_decl_p) {
00507     <a class="code" href="classStructure.html#Structurea24">print_decl</a>(os, space, <span class="keyword">false</span>);
00508     os &lt;&lt; <span class="stringliteral">" = "</span>;
00509     }
00510 
00511     os &lt;&lt; <span class="stringliteral">"{ "</span>;
00512     <span class="keywordflow">for</span> (<a class="code" href="classStructure.html#Structurew1">Vars_iter</a> i = _vars.begin(); i != _vars.end();
00513         i++, (<span class="keywordtype">void</span>)(i != _vars.end() &amp;&amp; os &lt;&lt; <span class="stringliteral">", "</span>))
00514     {
00515     (*i)-&gt;print_val(os, <span class="stringliteral">""</span>, <span class="keyword">false</span>);
00516     }
00517 
00518     os &lt;&lt; <span class="stringliteral">" }"</span>;
00519 
00520     <span class="keywordflow">if</span> (print_decl_p)
00521     os &lt;&lt; <span class="stringliteral">";"</span> &lt;&lt; endl;
00522 }
00523 
00524 <span class="keywordtype">void</span> 
<a name="l00525"></a><a class="code" href="classStructure.html#Structurea27">00525</a> <a class="code" href="classStructure.html#Structurea26">Structure::print_val</a>(FILE *out, string space, <span class="keywordtype">bool</span> print_decl_p)
00526 {
00527     <span class="keywordflow">if</span> (print_decl_p) {
00528     <a class="code" href="classStructure.html#Structurea24">print_decl</a>(out, space, <span class="keyword">false</span>);
00529     fprintf( out, <span class="stringliteral">" = "</span> ) ;
00530     }
00531 
00532     fprintf( out, <span class="stringliteral">"{ "</span> ) ;
00533     <span class="keywordflow">for</span> (<a class="code" href="classStructure.html#Structurew0">Vars_citer</a> i = _vars.begin(); i != _vars.end();
00534         i++, (<span class="keywordtype">void</span>)(i != _vars.end() &amp;&amp; fprintf( out, <span class="stringliteral">", "</span> ) ) )
00535     {
00536     (*i)-&gt;print_val(out, <span class="stringliteral">""</span>, <span class="keyword">false</span>);
00537     }
00538 
00539     fprintf( out, <span class="stringliteral">" }"</span> ) ;
00540 
00541     <span class="keywordflow">if</span> (print_decl_p)
00542     fprintf( out, <span class="stringliteral">";\n"</span> ) ;
00543 }
00544 
00545 <span class="comment">// Print the values of the contained variables.</span>
00546 <span class="comment">//</span>
00547 <span class="comment">// Potential bug: This works only for structures that have sequences at their</span>
00548 <span class="comment">// top level. Will it work when sequences are more deeply embedded?</span>
00549 
00554 <span class="keywordtype">void</span>
<a name="l00555"></a><a class="code" href="classStructure.html#Structurea28">00555</a> <a class="code" href="classStructure.html#Structurea28">Structure::print_all_vals</a>(ostream &amp;os, XDR *src, <a class="code" href="classDDS.html">DDS</a> *dds, string space, <span class="keywordtype">bool</span> print_decl_p)
00556 {
00557     <a class="code" href="classStructure.html#Structurea26">print_val</a>(os, space, print_decl_p);
00558 
00559 <span class="preprocessor">#if 0</span>
00560 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (print_decl_p) {
00561     <a class="code" href="classStructure.html#Structurea24">print_decl</a>(os, space, <span class="keyword">false</span>);
00562     os &lt;&lt; <span class="stringliteral">" = "</span>;
00563     }
00564 
00565     os &lt;&lt; <span class="stringliteral">"{ "</span>;
00566 
00567     <span class="keywordtype">bool</span> sequence_found = <span class="keyword">false</span>;
00568     <span class="keywordflow">for</span> (<a class="code" href="classStructure.html#Structurew1">Vars_iter</a> i = _vars.begin();
00569      i != _vars.end();
00570      i++, (<span class="keywordtype">void</span>)(i != _vars.end() &amp;&amp; os &lt;&lt; <span class="stringliteral">", "</span>))
00571     {
00572     <span class="keywordflow">switch</span> ((*i)-&gt;type()) {
00573       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a18">dods_sequence_c</a>:
00574         (dynamic_cast&lt;Sequence*&gt;((*i)))-&gt;print_all_vals(os, src, dds, 
00575                                   <span class="stringliteral">""</span>, <span class="keyword">false</span>);
00576         sequence_found = <span class="keyword">true</span>;
00577         <span class="keywordflow">break</span>;
00578       
00579       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a17">dods_structure_c</a>:
00580         (dynamic_cast&lt;Structure*&gt;((*i)))-&gt;print_all_vals(os, src, dds, 
00581                                    <span class="stringliteral">""</span>, <span class="keyword">false</span>);
00582         <span class="keywordflow">break</span>;
00583       
00584       <span class="keywordflow">default</span>:
00585         <span class="comment">// If a sequence was found, we still need to deserialize()</span>
00586         <span class="comment">// remaining vars.</span>
00587         <span class="keywordflow">if</span>(sequence_found)
00588         (*i)-&gt;deserialize(src, dds);
00589         (*i)-&gt;print_val(os, <span class="stringliteral">""</span>, <span class="keyword">false</span>);
00590         <span class="keywordflow">break</span>;
00591     }
00592     }
00593 
00594     os &lt;&lt; <span class="stringliteral">" }"</span>;
00595 
00596     <span class="keywordflow">if</span> (print_decl_p)
00597     os &lt;&lt; <span class="stringliteral">";"</span> &lt;&lt; endl;
00598 <span class="preprocessor">#endif</span>
00599 <span class="preprocessor"></span>}
00600 
00601 <span class="comment">// Print the values of the contained variables.</span>
00602 <span class="comment">//</span>
00603 <span class="comment">// Potential bug: This works only for structures that have sequences at their</span>
00604 <span class="comment">// top level. Will it work when sequences are more deeply embedded?</span>
00605 
00606 <span class="keywordtype">void</span>
<a name="l00607"></a><a class="code" href="classStructure.html#Structurea29">00607</a> <a class="code" href="classStructure.html#Structurea28">Structure::print_all_vals</a>(FILE *out, XDR *src, <a class="code" href="classDDS.html">DDS</a> *dds, string space, <span class="keywordtype">bool</span> print_decl_p)
00608 {
00609     <a class="code" href="classStructure.html#Structurea26">print_val</a>(out, space, print_decl_p);
00610 
00611 <span class="preprocessor">#if 0</span>
00612 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (print_decl_p) {
00613     <a class="code" href="classStructure.html#Structurea24">print_decl</a>(out, space, <span class="keyword">false</span>);
00614     fprintf( out, <span class="stringliteral">" = "</span> ) ;
00615     }
00616 
00617     fprintf( out, <span class="stringliteral">"{ "</span> ) ;
00618 
00619     <span class="keywordtype">bool</span> sequence_found = <span class="keyword">false</span>;
00620     <span class="keywordflow">for</span> (<a class="code" href="classStructure.html#Structurew0">Vars_citer</a> i = _vars.begin();
00621      i != _vars.end();
00622      i++, (<span class="keywordtype">void</span>)(i != _vars.end() &amp;&amp; fprintf( out, <span class="stringliteral">", "</span> ) ) )
00623     {
00624     <span class="keywordflow">switch</span> ((*i)-&gt;type()) {
00625       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a18">dods_sequence_c</a>:
00626         (dynamic_cast&lt;Sequence*&gt;((*i)))-&gt;print_all_vals(out, src, dds, 
00627                                   <span class="stringliteral">""</span>, <span class="keyword">false</span>);
00628         sequence_found = <span class="keyword">true</span>;
00629         <span class="keywordflow">break</span>;
00630       
00631       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a17">dods_structure_c</a>:
00632         (dynamic_cast&lt;Structure*&gt;((*i)))-&gt;print_all_vals(out, src, dds, 
00633                                    <span class="stringliteral">""</span>, <span class="keyword">false</span>);
00634         <span class="keywordflow">break</span>;
00635       
00636       <span class="keywordflow">default</span>:
00637         <span class="comment">// If a sequence was found, we still need to deserialize()</span>
00638         <span class="comment">// remaining vars.</span>
00639         <span class="keywordflow">if</span>(sequence_found)
00640         (*i)-&gt;deserialize(src, dds);
00641         (*i)-&gt;print_val(out, <span class="stringliteral">""</span>, <span class="keyword">false</span>);
00642         <span class="keywordflow">break</span>;
00643     }
00644     }
00645 
00646     fprintf( out, <span class="stringliteral">" }"</span> ) ;
00647 
00648     <span class="keywordflow">if</span> (print_decl_p)
00649     fprintf( out, <span class="stringliteral">";\n"</span> ) ;
00650 <span class="preprocessor">#endif</span>
00651 <span class="preprocessor"></span>}
00652 
00653 <span class="keywordtype">bool</span>
<a name="l00654"></a><a class="code" href="classStructure.html#Structurea30">00654</a> <a class="code" href="classStructure.html#Structurea30">Structure::check_semantics</a>(string &amp;msg, <span class="keywordtype">bool</span> all)
00655 {
00656     <span class="keywordflow">if</span> (!<a class="code" href="classBaseType.html#Urla40">BaseType::check_semantics</a>(msg))
00657     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00658     
00659     <span class="keywordtype">bool</span> status = <span class="keyword">true</span>;
00660 
00661     <span class="keywordflow">if</span> (!<a class="code" href="util_8cc.html#a3">unique_names</a>(_vars, <a class="code" href="classBaseType.html#Vectora27">name</a>(), <a class="code" href="classBaseType.html#Vectora31">type_name</a>(), msg))
00662     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00663 
00664     <span class="keywordflow">if</span> (all) 
00665     {
00666     <span class="keywordflow">for</span> (<a class="code" href="classStructure.html#Structurew1">Vars_iter</a> i = _vars.begin(); i != _vars.end(); i++)
00667     {
00668         <span class="comment">//assert(*i);</span>
00669         <span class="keywordflow">if</span> (!(*i)-&gt;check_semantics(msg, <span class="keyword">true</span>)) {
00670         status = <span class="keyword">false</span>;
00671         <span class="keywordflow">goto</span> exit;
00672         }
00673     }
00674     }
00675 
00676  exit:
00677     <span class="keywordflow">return</span> status;
00678 }
00679 
00680 <span class="comment">// $Log: Structure_8cc-source.html,v $
00680 <span class="comment">// Revision 1.4  2004/02/05 06:51:16  jimg
00680 <span class="comment">// Added/update.
00680 <span class="comment">//</span>
00681 <span class="comment">// Revision 1.54.2.2  2003/09/06 22:56:26  jimg</span>
00682 <span class="comment">// Added set_in_selection() method. Updated the documentation.</span>
00683 <span class="comment">//</span>
00684 <span class="comment">// Revision 1.54.2.1  2003/07/25 06:04:28  jimg</span>
00685 <span class="comment">// Refactored the code so that DDS:send() is now incorporated into</span>
00686 <span class="comment">// DODSFilter::send_data(). The old DDS::send() is still there but is</span>
00687 <span class="comment">// depracated.</span>
00688 <span class="comment">// Added 'smart timeouts' to all the variable classes. This means that</span>
00689 <span class="comment">// the new server timeouts are active only for the data read and CE</span>
00690 <span class="comment">// evaluation. This went inthe BaseType::serialize() methods because it</span>
00691 <span class="comment">// needed to time both the read() calls and the dds::eval() calls.</span>
00692 <span class="comment">//</span>
00693 <span class="comment">// Revision 1.54  2003/04/22 19:40:28  jimg</span>
00694 <span class="comment">// Merged with 3.3.1.</span>
00695 <span class="comment">//</span>
00696 <span class="comment">// Revision 1.52.2.2  2003/04/15 01:17:12  jimg</span>
00697 <span class="comment">// Added a method to get the iterator for a variable (or map) given its</span>
00698 <span class="comment">// index. To get the iterator for the ith variable/map, call</span>
00699 <span class="comment">// get_vars_iter(i).</span>
00700 <span class="comment">//</span>
00701 <span class="comment">// Revision 1.53  2003/02/21 00:14:25  jimg</span>
00702 <span class="comment">// Repaired copyright.</span>
00703 <span class="comment">//</span>
00704 <span class="comment">// Revision 1.52.2.1  2003/02/21 00:10:07  jimg</span>
00705 <span class="comment">// Repaired copyright.</span>
00706 <span class="comment">//</span>
00707 <span class="comment">// Revision 1.52  2003/01/23 00:22:24  jimg</span>
00708 <span class="comment">// Updated the copyright notice; this implementation of the DAP is</span>
00709 <span class="comment">// copyrighted by OPeNDAP, Inc.</span>
00710 <span class="comment">//</span>
00711 <span class="comment">// Revision 1.51  2003/01/15 19:24:39  pwest</span>
00712 <span class="comment">// Removing IteratorAdapterT and replacing with non-templated versions.</span>
00713 <span class="comment">//</span>
00714 <span class="comment">// Revision 1.50  2003/01/10 19:46:40  jimg</span>
00715 <span class="comment">// Merged with code tagged release-3-2-10 on the release-3-2 branch. In many</span>
00716 <span class="comment">// cases files were added on that branch (so they appear on the trunk for</span>
00717 <span class="comment">// the first time).</span>
00718 <span class="comment">//</span>
00719 <span class="comment">// Revision 1.43.4.18  2002/12/31 16:43:20  rmorris</span>
00720 <span class="comment">// Patches to handle some of the fancier template code under VC++ 6.0.</span>
00721 <span class="comment">//</span>
00722 <span class="comment">// Revision 1.43.4.17  2002/12/27 19:34:42  jimg</span>
00723 <span class="comment">// Modified the var() methods so that www2id() is called before looking</span>
00724 <span class="comment">// up identifier names. See bug 563.</span>
00725 <span class="comment">//</span>
00726 <span class="comment">// Revision 1.43.4.16  2002/12/17 22:35:03  pwest</span>
00727 <span class="comment">// Added and updated methods using stdio. Deprecated methods using iostream.</span>
00728 <span class="comment">//</span>
00729 <span class="comment">// Revision 1.43.4.15  2002/12/01 14:37:52  rmorris</span>
00730 <span class="comment">// Smalling changes for the win32 porting and maintenance work.</span>
00731 <span class="comment">//</span>
00732 <span class="comment">// Revision 1.43.4.14  2002/10/28 21:17:44  pwest</span>
00733 <span class="comment">// Converted all return values and method parameters to use non-const iterator.</span>
00734 <span class="comment">// Added operator== and operator!= methods to IteratorAdapter to handle Pix</span>
00735 <span class="comment">// problems.</span>
00736 <span class="comment">//</span>
00737 <span class="comment">// Revision 1.43.4.13  2002/09/22 14:31:08  rmorris</span>
00738 <span class="comment">// VC++ doesn't consider x in 'for(int x,...)' to be only for the block</span>
00739 <span class="comment">// associated with the loop.  Multiple of these therefore case a error</span>
00740 <span class="comment">// because VC++ sees multiple definitions.  Changed to use different vars names</span>
00741 <span class="comment">// in each such block.</span>
00742 <span class="comment">//</span>
00743 <span class="comment">// Revision 1.43.4.12  2002/09/12 22:49:58  pwest</span>
00744 <span class="comment">// Corrected signature changes made with Pix to IteratorAdapter changes. Rather</span>
00745 <span class="comment">// than taking a reference to a Pix, taking a Pix value.</span>
00746 <span class="comment">//</span>
00747 <span class="comment">// Revision 1.43.4.11  2002/09/05 22:52:54  pwest</span>
00748 <span class="comment">// Replaced the GNU data structures SLList and DLList with the STL container</span>
00749 <span class="comment">// class vector&lt;&gt;. To maintain use of Pix, changed the Pix.h header file to</span>
00750 <span class="comment">// redefine Pix to be an IteratorAdapter. Usage remains the same and all code</span>
00751 <span class="comment">// outside of the DAP should compile and link with no problems. Added methods</span>
00752 <span class="comment">// to the different classes where Pix is used to include methods to use STL</span>
00753 <span class="comment">// iterators. Replaced the use of Pix within the DAP to use iterators instead.</span>
00754 <span class="comment">// Updated comments for documentation, updated the test suites, and added some</span>
00755 <span class="comment">// unit tests. Updated the Makefile to remove GNU/SLList and GNU/DLList.</span>
00756 <span class="comment">//</span>
00757 <span class="comment">// Revision 1.43.4.10  2002/08/08 06:54:57  jimg</span>
00758 <span class="comment">// Changes for thread-safety. In many cases I found ugly places at the</span>
00759 <span class="comment">// tops of files while looking for globals, et c., and I fixed them up</span>
00760 <span class="comment">// (hopefully making them easier to read, ...). Only the files RCReader.cc</span>
00761 <span class="comment">// and usage.cc actually use pthreads synchronization functions. In other</span>
00762 <span class="comment">// cases I removed static objects where they were used for supposed</span>
00763 <span class="comment">// improvements in efficiency which had never actually been verifiied (and</span>
00764 <span class="comment">// which looked dubious).</span>
00765 <span class="comment">//</span>
00766 <span class="comment">// Revision 1.49  2002/06/18 15:36:24  tom</span>
00767 <span class="comment">// Moved comments and edited to accommodate doxygen documentation-generator.</span>
00768 <span class="comment">//</span>
00769 <span class="comment">// Revision 1.48  2002/06/03 22:21:15  jimg</span>
00770 <span class="comment">// Merged with release-3-2-9</span>
00771 <span class="comment">//</span>
00772 <span class="comment">// Revision 1.43.4.9  2002/05/22 16:57:51  jimg</span>
00773 <span class="comment">// I modified the `data type classes' so that they do not need to be</span>
00774 <span class="comment">// subclassed for clients. It might be the case that, for a complex client,</span>
00775 <span class="comment">// subclassing is still the best way to go, but you're not required to do</span>
00776 <span class="comment">// it anymore.</span>
00777 <span class="comment">//</span>
00778 <span class="comment">// Revision 1.43.4.8  2002/03/01 21:03:08  jimg</span>
00779 <span class="comment">// Significant changes to the var(...) methods. These now take a btp_stack</span>
00780 <span class="comment">// pointer and are used by DDS::mark(...). The exact_match methods have also</span>
00781 <span class="comment">// been updated so that leaf variables which contain dots in their names</span>
00782 <span class="comment">// will be found. Note that constructor variables with dots in their names</span>
00783 <span class="comment">// will break the lookup routines unless the ctor is the last field in the</span>
00784 <span class="comment">// constraint expression. These changes were made to fix bug 330.</span>
00785 <span class="comment">//</span>
00786 <span class="comment">// Revision 1.47  2001/10/14 01:28:38  jimg</span>
00787 <span class="comment">// Merged with release-3-2-8.</span>
00788 <span class="comment">//</span>
00789 <span class="comment">// Revision 1.43.4.7  2001/10/02 17:01:52  jimg</span>
00790 <span class="comment">// Made the behavior of serialize and deserialize uniform. Both methods now</span>
00791 <span class="comment">// use Error exceptions to signal problems with network I/O and InternalErr</span>
00792 <span class="comment">// exceptions to signal other problems. The return codes, always true for</span>
00793 <span class="comment">// serialize and always false for deserialize, are now meaningless. However,</span>
00794 <span class="comment">// by always returning a code that means OK, old code should continue to work.</span>
00795 <span class="comment">//</span>
00796 <span class="comment">// Revision 1.46  2001/09/28 17:50:07  jimg</span>
00797 <span class="comment">// Merged with 3.2.7.</span>
00798 <span class="comment">//</span>
00799 <span class="comment">// Revision 1.43.4.6  2001/09/25 20:28:54  jimg</span>
00800 <span class="comment">// Added is_linear().</span>
00801 <span class="comment">//</span>
00802 <span class="comment">// Revision 1.43.4.5  2001/09/07 00:38:35  jimg</span>
00803 <span class="comment">// Sequence::deserialize(...) now reads all the sequence values at once.</span>
00804 <span class="comment">// Its call semantics are the same as the other classes' versions. Values</span>
00805 <span class="comment">// are stored in the Sequence object using a vector&lt;BaseType *&gt; for each</span>
00806 <span class="comment">// row (those are themselves held in a vector). Three new accessor methods</span>
00807 <span class="comment">// have been added to Sequence (row_value() and two versions of var_value()).</span>
00808 <span class="comment">// BaseType::deserialize(...) now always returns true. This matches with the</span>
00809 <span class="comment">// expectations of most client code (the seqeunce version returned false</span>
00810 <span class="comment">// when it was done reading, but all the calls for sequences must be changed</span>
00811 <span class="comment">// anyway). If an XDR error is found, deserialize throws InternalErr.</span>
00812 <span class="comment">//</span>
00813 <span class="comment">// Revision 1.45  2001/08/24 17:46:22  jimg</span>
00814 <span class="comment">// Resolved conflicts from the merge of release 3.2.6</span>
00815 <span class="comment">//</span>
00816 <span class="comment">// Revision 1.43.4.4  2001/08/18 00:15:41  jimg</span>
00817 <span class="comment">// Removed WIN32 compile guards from using statements.</span>
00818 <span class="comment">//</span>
00819 <span class="comment">// Revision 1.43.4.3  2001/07/28 01:10:42  jimg</span>
00820 <span class="comment">// Some of the numeric type classes did not have copy ctors or operator=.</span>
00821 <span class="comment">// I added those where they were needed.</span>
00822 <span class="comment">// In every place where delete (or delete []) was called, I set the pointer</span>
00823 <span class="comment">// just deleted to zero. Thus if for some reason delete is called again</span>
00824 <span class="comment">// before new memory is allocated there won't be a mysterious crash. This is</span>
00825 <span class="comment">// just good form when using delete.</span>
00826 <span class="comment">// I added calls to www2id and id2www where appropriate. The DAP now handles</span>
00827 <span class="comment">// making sure that names are escaped and unescaped as needed. Connect is</span>
00828 <span class="comment">// set to handle CEs that contain names as they are in the dataset (see the</span>
00829 <span class="comment">// comments/Log there). Servers should not handle escaping or unescaping</span>
00830 <span class="comment">// characters on their own.</span>
00831 <span class="comment">//</span>
00832 <span class="comment">// Revision 1.44  2001/06/15 23:49:02  jimg</span>
00833 <span class="comment">// Merged with release-3-2-4.</span>
00834 <span class="comment">//</span>
00835 <span class="comment">// Revision 1.43.4.2  2001/06/07 20:42:02  jimg</span>
00836 <span class="comment">// Removed an extraneous assert.</span>
00837 <span class="comment">//</span>
00838 <span class="comment">// Revision 1.43.4.1  2001/06/05 06:49:19  jimg</span>
00839 <span class="comment">// Added the Constructor class which is to Structures, Sequences and Grids</span>
00840 <span class="comment">// what Vector is to Arrays and Lists. This should be used in future</span>
00841 <span class="comment">// refactorings (I thought it was going to be used for the back pointers).</span>
00842 <span class="comment">// Introduced back pointers so children can refer to their parents in</span>
00843 <span class="comment">// hierarchies of variables.</span>
00844 <span class="comment">// Added to Sequence methods to tell if a child sequence is done</span>
00845 <span class="comment">// deserializing its data.</span>
00846 <span class="comment">// Fixed the operator=() and copy ctors; removed redundency from</span>
00847 <span class="comment">// _duplicate().</span>
00848 <span class="comment">// Changed the way serialize and deserialize work for sequences. Now SOI and</span>
00849 <span class="comment">// EOS markers are written for every `level' of a nested Sequence. This</span>
00850 <span class="comment">// should fixed nested Sequences. There is still considerable work to do</span>
00851 <span class="comment">// for these to work in all cases.</span>
00852 <span class="comment">//</span>
00853 <span class="comment">// Revision 1.43  2000/10/06 01:26:05  jimg</span>
00854 <span class="comment">// Changed the way serialize() calls read(). The status from read() is</span>
00855 <span class="comment">// returned by the Structure and Sequence serialize() methods; ignored by</span>
00856 <span class="comment">// all others. Any exceptions thrown by read() are caught and discarded.</span>
00857 <span class="comment">// serialize() returns false if read() throws an exception. This should</span>
00858 <span class="comment">// be fixed once all the servers build using the new read() definition.</span>
00859 <span class="comment">//</span>
00860 <span class="comment">// Revision 1.42  2000/09/22 02:17:21  jimg</span>
00861 <span class="comment">// Rearranged source files so that the CVS logs appear at the end rather than</span>
00862 <span class="comment">// the start. Also made the ifdef guard symbols use the same naming scheme and</span>
00863 <span class="comment">// wrapped headers included in other headers in those guard symbols (to cut</span>
00864 <span class="comment">// down on extraneous file processing - See Lakos).</span>
00865 <span class="comment">//</span>
00866 <span class="comment">// Revision 1.41  2000/09/21 16:22:08  jimg</span>
00867 <span class="comment">// Merged changes from Jose Garcia that add exceptions to the software.</span>
00868 <span class="comment">// Many methods that returned error codes now throw exectptions. There are</span>
00869 <span class="comment">// two classes which are thrown by the software, Error and InternalErr.</span>
00870 <span class="comment">// InternalErr is used to report errors within the library or errors using</span>
00871 <span class="comment">// the library. Error is used to reprot all other errors. Since InternalErr</span>
00872 <span class="comment">// is a subclass of Error, programs need only to catch Error.</span>
00873 <span class="comment">//</span>
00874 <span class="comment">// Revision 1.40  2000/07/09 22:05:36  rmorris</span>
00875 <span class="comment">// Changes to increase portability, minimize ifdef's for win32 and account</span>
00876 <span class="comment">// for differences in the iostreams implementations.</span>
00877 <span class="comment">//</span>
00878 <span class="comment">// Revision 1.39  2000/06/16 18:15:00  jimg</span>
00879 <span class="comment">// Merged with 3.1.7</span>
00880 <span class="comment">//</span>
00881 <span class="comment">// Revision 1.37.6.2  2000/06/07 23:05:30  jimg</span>
00882 <span class="comment">// The first_*() methods return 0 if there are no variables</span>
00883 <span class="comment">//</span>
00884 <span class="comment">// Revision 1.38  2000/01/27 06:29:58  jimg</span>
00885 <span class="comment">// Resolved conflicts from merge with release-3-1-4</span>
00886 <span class="comment">//</span>
00887 <span class="comment">// Revision 1.37.6.1  2000/01/26 23:57:37  jimg</span>
00888 <span class="comment">// Fixed the return type of string::find.</span>
00889 <span class="comment">//</span>
00890 <span class="comment">// Revision 1.37.14.2  2000/02/17 05:03:14  jimg</span>
00891 <span class="comment">// Added file and line number information to calls to InternalErr.</span>
00892 <span class="comment">// Resolved compile-time problems with read due to a change in its</span>
00893 <span class="comment">// parameter list given that errors are now reported using exceptions.</span>
00894 <span class="comment">//</span>
00895 <span class="comment">// Revision 1.37.14.1  2000/01/28 22:14:06  jgarcia</span>
00896 <span class="comment">// Added exception handling and modify add_var to get a copy of the object</span>
00897 <span class="comment">//</span>
00898 <span class="comment">// Revision 1.37  1999/04/29 02:29:31  jimg</span>
00899 <span class="comment">// Merge of no-gnu branch</span>
00900 <span class="comment">//</span>
00901 <span class="comment">// Revision 1.36  1998/11/10 00:58:49  jimg</span>
00902 <span class="comment">// Fixed up memory leaks in the calls to unique_names().</span>
00903 <span class="comment">//</span>
00904 <span class="comment">// Revision 1.35  1998/09/17 17:08:52  jimg</span>
00905 <span class="comment">// Changes for the new variable lookup scheme. Fields of ctor types no longer</span>
00906 <span class="comment">// need to be fully qualified. my.thing.f1 can now be named `f1' in a CE. Note</span>
00907 <span class="comment">// that if there are two `f1's in a dataset, the first will be silently used;</span>
00908 <span class="comment">// There's no warning about the situation. The new code in the var member</span>
00909 <span class="comment">// function passes a stack of BaseType pointers so that the projection</span>
00910 <span class="comment">// information (send_p field) can be set properly.</span>
00911 <span class="comment">// Changed the implementation of print_all_vals to use type() instead of</span>
00912 <span class="comment">// type_name().</span>
00913 <span class="comment">// Added leaf_match and exact_match.</span>
00914 <span class="comment">//</span>
00915 <span class="comment">// Revision 1.34.2.1  1999/02/02 21:57:01  jimg</span>
00916 <span class="comment">// String to string version</span>
00917 <span class="comment">//</span>
00918 <span class="comment">// Revision 1.34  1998/08/06 16:21:25  jimg</span>
00919 <span class="comment">// Fixed the misuse of the read(...) member function. See Grid.c (from jeh).</span>
00920 <span class="comment">//</span>
00921 <span class="comment">// Revision 1.33  1998/04/03 17:43:32  jimg</span>
00922 <span class="comment">// Patch from Jake Hamby. Added print_all_vals member function. Fixed print_val</span>
00923 <span class="comment">// so that structures with sequences work properly.</span>
00924 <span class="comment">//</span>
00925 <span class="comment">// Revision 1.32  1998/03/17 17:50:37  jimg</span>
00926 <span class="comment">// Added an implementation of element_count().</span>
00927 <span class="comment">//</span>
00928 <span class="comment">// Revision 1.31  1997/09/22 22:45:14  jimg</span>
00929 <span class="comment">// Added DDS * to deserialize parameters.</span>
00930 <span class="comment">//</span>
00931 <span class="comment">// Revision 1.30  1997/03/08 19:02:08  jimg</span>
00932 <span class="comment">// Changed default param to check_semantics() from  to String()</span>
00933 <span class="comment">// and removed the default from the argument list in the mfunc definition</span>
00934 <span class="comment">//</span>
00935 <span class="comment">// Revision 1.29  1997/02/28 01:27:59  jimg</span>
00936 <span class="comment">// Changed check_semantics() so that it now returns error messages in a String</span>
00937 <span class="comment">// object (passed by reference).</span>
00938 <span class="comment">//</span>
00939 <span class="comment">// Revision 1.28  1997/02/10 02:32:43  jimg</span>
00940 <span class="comment">// Added assert statements for pointers</span>
00941 <span class="comment">//</span>
00942 <span class="comment">// Revision 1.27  1996/09/16 18:09:49  jimg</span>
00943 <span class="comment">// Fixed var(const String name) so that it would correctly descend names of the</span>
00944 <span class="comment">// form &lt;base&gt;.&lt;name&gt; where &lt;name&gt; may itself contain `dots'.</span>
00945 <span class="comment">//</span>
00946 <span class="comment">// Revision 1.26  1996/08/13 18:37:49  jimg</span>
00947 <span class="comment">// Added void casts to values computed in print_val() for loops.</span>
00948 <span class="comment">//</span>
00949 <span class="comment">// Revision 1.25  1996/06/04 21:33:45  jimg</span>
00950 <span class="comment">// Multiple connections are now possible. It is now possible to open several</span>
00951 <span class="comment">// URLs at the same time and read from them in a round-robin fashion. To do</span>
00952 <span class="comment">// this I added data source and sink parameters to the serialize and</span>
00953 <span class="comment">// deserialize mfuncs. Connect was also modified so that it manages the data</span>
00954 <span class="comment">// source `object' (which is just an XDR pointer).</span>
00955 <span class="comment">//</span>
00956 <span class="comment">// Revision 1.24  1996/05/31 23:30:05  jimg</span>
00957 <span class="comment">// Updated copyright notice.</span>
00958 <span class="comment">//</span>
00959 <span class="comment">// Revision 1.23  1996/05/16 22:49:52  jimg</span>
00960 <span class="comment">// Dan's changes for version 2.0. Added a parameter to read that returns</span>
00961 <span class="comment">// an error code so that EOF can be distinguished from an actual error when</span>
00962 <span class="comment">// reading sequences. This *may* be replaced by an error member function</span>
00963 <span class="comment">// in the future.</span>
00964 <span class="comment">//</span>
00965 <span class="comment">// Revision 1.22  1996/05/14 15:38:38  jimg</span>
00966 <span class="comment">// These changes have already been checked in once before. However, I</span>
00967 <span class="comment">// corrupted the source repository and restored it from a 5/9/96 backup</span>
00968 <span class="comment">// tape. The previous version's log entry should cover the changes.</span>
00969 <span class="comment">//</span>
00970 <span class="comment">// Revision 1.21  1996/04/05 00:21:40  jimg</span>
00971 <span class="comment">// Compiled with g++ -Wall and fixed various warnings.</span>
00972 <span class="comment">//</span>
00973 <span class="comment">// Revision 1.20  1996/03/05 17:36:12  jimg</span>
00974 <span class="comment">// Added ce_eval to serailize member function.</span>
00975 <span class="comment">// Added debugging information to _duplicate member function.</span>
00976 <span class="comment">//</span>
00977 <span class="comment">// Revision 1.19  1996/02/02 00:31:13  jimg</span>
00978 <span class="comment">// Merge changes for DODS-1.1.0 into DODS-2.x</span>
00979 <span class="comment">//</span>
00980 <span class="comment">// Revision 1.18  1995/12/09  01:07:00  jimg</span>
00981 <span class="comment">// Added changes so that relational operators will work properly for all the</span>
00982 <span class="comment">// datatypes (including Sequences). The relational ops are evaluated in</span>
00983 <span class="comment">// DDS::eval_constraint() after being parsed by DDS::parse_constraint().</span>
00984 <span class="comment">//</span>
00985 <span class="comment">// Revision 1.17  1995/12/06  21:56:32  jimg</span>
00986 <span class="comment">// Added `constrained' flag to print_decl.</span>
00987 <span class="comment">// Removed third parameter of read.</span>
00988 <span class="comment">// Modified print_decl() to print only those parts of a dataset that are</span>
00989 <span class="comment">// selected when `constrained' is true.</span>
00990 <span class="comment">//</span>
00991 <span class="comment">// Revision 1.16  1995/10/23  23:21:04  jimg</span>
00992 <span class="comment">// Added _send_p and _read_p fields (and their accessors) along with the</span>
00993 <span class="comment">// virtual mfuncs set_send_p() and set_read_p().</span>
00994 <span class="comment">//</span>
00995 <span class="comment">// Revision 1.15  1995/08/26  00:31:49  jimg</span>
00996 <span class="comment">// Removed code enclosed in #ifdef NEVER #endif.</span>
00997 <span class="comment">//</span>
00998 <span class="comment">// Revision 1.14  1995/08/23  00:11:08  jimg</span>
00999 <span class="comment">// Changed old, deprecated member functions to new ones.</span>
01000 <span class="comment">// Switched from String representation of type to enum.</span>
01001 <span class="comment">//</span>
01002 <span class="comment">// Revision 1.13.2.1  1995/09/14 20:58:13  jimg</span>
01003 <span class="comment">// Moved some loop index variables out of the loop statement.</span>
01004 <span class="comment">//</span>
01005 <span class="comment">// Revision 1.13  1995/07/09  21:29:06  jimg</span>
01006 <span class="comment">// Added copyright notice.</span>
01007 <span class="comment">//</span>
01008 <span class="comment">// Revision 1.12  1995/05/10  15:34:06  jimg</span>
01009 <span class="comment">// Failed to change `config.h' to `config_dap.h' in these files.</span>
01010 <span class="comment">//</span>
01011 <span class="comment">// Revision 1.11  1995/05/10  13:45:31  jimg</span>
01012 <span class="comment">// Changed the name of the configuration header file from `config.h' to</span>
01013 <span class="comment">// `config_dap.h' so that other libraries could have header files which were</span>
01014 <span class="comment">// installed in the DODS include directory without overwriting this one. Each</span>
01015 <span class="comment">// config header should follow the convention config_&lt;name&gt;.h.</span>
01016 <span class="comment">//</span>
01017 <span class="comment">// Revision 1.10  1995/03/16  17:29:12  jimg</span>
01018 <span class="comment">// Added include config_dap.h to top of include list.</span>
01019 <span class="comment">// Added TRACE_NEW switched dbnew includes.</span>
01020 <span class="comment">// Fixed bug in read_val() where **val was passed incorrectly to</span>
01021 <span class="comment">// subordinate read_val() calls.</span>
01022 <span class="comment">//</span>
01023 <span class="comment">// Revision 1.9  1995/03/04  14:34:51  jimg</span>
01024 <span class="comment">// Major modifications to the transmission and representation of values:</span>
01025 <span class="comment">// Added card() virtual function which is true for classes that</span>
01026 <span class="comment">// contain cardinal types (byte, int float, string).</span>
01027 <span class="comment">// Changed the representation of Str from the C rep to a C++</span>
01028 <span class="comment">// class represenation.</span>
01029 <span class="comment">// Chnaged read_val and store_val so that they take and return</span>
01030 <span class="comment">// types that are stored by the object (e.g., inthe case of Str</span>
01031 <span class="comment">// an URL, read_val returns a C++ String object).</span>
01032 <span class="comment">// Modified Array representations so that arrays of card()</span>
01033 <span class="comment">// objects are just that - no more storing strings, ... as</span>
01034 <span class="comment">// C would store them.</span>
01035 <span class="comment">// Arrays of non cardinal types are arrays of the DODS objects (e.g.,</span>
01036 <span class="comment">// an array of a structure is represented as an array of Structure</span>
01037 <span class="comment">// objects).</span>
01038 <span class="comment">//</span>
01039 <span class="comment">// Revision 1.8  1995/02/10  02:22:59  jimg</span>
01040 <span class="comment">// Added DBMALLOC includes and switch to code which uses malloc/free.</span>
01041 <span class="comment">// Private and protected symbols now start with `_'.</span>
01042 <span class="comment">// Added new accessors for name and type fields of BaseType; the old ones</span>
01043 <span class="comment">// will be removed in a future release.</span>
01044 <span class="comment">// Added the store_val() mfunc. It stores the given value in the object's</span>
01045 <span class="comment">// internal buffer.</span>
01046 <span class="comment">// Made both List and Str handle their values via pointers to memory.</span>
01047 <span class="comment">// Fixed read_val().</span>
01048 <span class="comment">// Made serialize/deserialize handle all malloc/free calls (even in those</span>
01049 <span class="comment">// cases where xdr initiates the allocation).</span>
01050 <span class="comment">// Fixed print_val().</span>
01051 <span class="comment">//</span>
01052 <span class="comment">// Revision 1.7  1995/01/19  20:05:24  jimg</span>
01053 <span class="comment">// ptr_duplicate() mfunc is now abstract virtual.</span>
01054 <span class="comment">// Array, ... Grid duplicate mfuncs were modified to take pointers, not</span>
01055 <span class="comment">// referenves.</span>
01056 <span class="comment">//</span>
01057 <span class="comment">// Revision 1.6  1995/01/11  15:54:49  jimg</span>
01058 <span class="comment">// Added modifications necessary for BaseType's static XDR pointers. This</span>
01059 <span class="comment">// was mostly a name change from xdrin/out to _xdrin/out.</span>
01060 <span class="comment">// Removed the two FILE pointers from ctors, since those are now set with</span>
01061 <span class="comment">// functions which are friends of BaseType.</span>
01062 <span class="comment">//</span>
01063 <span class="comment">// Revision 1.5  1994/12/16  15:16:39  dan</span>
01064 <span class="comment">// Modified Structure class removing inheritance from class CtorType</span>
01065 <span class="comment">// and directly inheriting from class BaseType to alloc calling</span>
01066 <span class="comment">// BaseType's constructor directly.</span>
01067 <span class="comment">//</span>
01068 <span class="comment">// Revision 1.4  1994/11/22  14:06:10  jimg</span>
01069 <span class="comment">// Added code for data transmission to parts of the type hierarchy. Not</span>
01070 <span class="comment">// complete yet.</span>
01071 <span class="comment">// Fixed erros in type hierarchy headers (typos, incorrect comments, ...).</span>
01072 <span class="comment">//</span>
01073 <span class="comment">// Revision 1.3  1994/10/17  23:34:47  jimg</span>
01074 <span class="comment">// Added code to print_decl so that variable declarations are pretty</span>
01075 <span class="comment">// printed.</span>
01076 <span class="comment">// Added private mfunc duplicate().</span>
01077 <span class="comment">// Added ptr_duplicate().</span>
01078 <span class="comment">// Added Copy ctor, dtor and operator=.</span>
01079 <span class="comment">//</span>
01080 <span class="comment">// Revision 1.2  1994/09/23  14:45:26  jimg</span>
01081 <span class="comment">// Added mfunc check_semantics().</span>
01082 <span class="comment">// Added sanity checking on the variable list (is it empty?).</span>
01083 <span class="comment">//</span>
01084 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Feb 4 23:43:04 2004 for libdap++ by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
