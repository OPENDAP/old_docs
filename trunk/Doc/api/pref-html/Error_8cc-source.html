<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libdap++: Error.cc Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Error.cc</h1><a href="Error_8cc.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00002 <span class="comment">// -*- mode: c++; c-basic-offset:4 -*-</span>
00003 
00004 <span class="comment">// This file is part of libdap, A C++ implementation of the OPeNDAP Data</span>
00005 <span class="comment">// Access Protocol.</span>
00006 
00007 <span class="comment">// Copyright (c) 2002,2003 OPeNDAP, Inc.</span>
00008 <span class="comment">// Author: James Gallagher &lt;jgallagher@opendap.org&gt;</span>
00009 <span class="comment">//</span>
00010 <span class="comment">// This library is free software; you can redistribute it and/or</span>
00011 <span class="comment">// modify it under the terms of the GNU Lesser General Public</span>
00012 <span class="comment">// License as published by the Free Software Foundation; either</span>
00013 <span class="comment">// version 2.1 of the License, or (at your option) any later version.</span>
00014 <span class="comment">// </span>
00015 <span class="comment">// This library is distributed in the hope that it will be useful,</span>
00016 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00017 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00018 <span class="comment">// Lesser General Public License for more details.</span>
00019 <span class="comment">// </span>
00020 <span class="comment">// You should have received a copy of the GNU Lesser General Public</span>
00021 <span class="comment">// License along with this library; if not, write to the Free Software</span>
00022 <span class="comment">// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00023 <span class="comment">//</span>
00024 <span class="comment">// You can contact OPeNDAP, Inc. at PO Box 112, Saunderstown, RI. 02874-0112.</span>
00025  
00026 <span class="comment">// (c) COPYRIGHT URI/MIT 1994-1999</span>
00027 <span class="comment">// Please read the full copyright statement in the file COPYRIGHT_URI.</span>
00028 <span class="comment">//</span>
00029 <span class="comment">// Authors:</span>
00030 <span class="comment">//      jhrg,jimg       James Gallagher &lt;jgallagher@gso.uri.edu&gt;</span>
00031 
00032 <span class="comment">// Implementation for the Error class.</span>
00033 
00034 <span class="preprocessor">#ifdef __GNUG__</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#pragma implementation</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00037 <span class="preprocessor"></span>
00038 <span class="preprocessor">#include "<a class="code" href="config__dap_8h.html">config_dap.h</a>"</span>
00039 
00040 <span class="keyword">static</span> <span class="keywordtype">char</span> rcsid[] <a class="code" href="config__dap_8h.html#a49">not_used</a> = {<span class="stringliteral">"$Id$"</span>};
00041 
00042 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00043 <span class="preprocessor">#include &lt;assert.h&gt;</span>
00044 
00045 <span class="preprocessor">#include "<a class="code" href="Error_8h.html">Error.h</a>"</span>
00046 <span class="preprocessor">#include "<a class="code" href="parser_8h.html">parser.h</a>"</span>
00047 <span class="preprocessor">#include "<a class="code" href="InternalErr_8h.html">InternalErr.h</a>"</span>
00048 
00049 <span class="keyword">using</span> std::cerr;
00050 <span class="keyword">using</span> std::endl;
00051 
00052 <span class="comment">// Glue routines declared in Error.lex</span>
00053 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="Error_8cc.html#a2">Error_switch_to_buffer</a>(<span class="keywordtype">void</span> *new_buffer);
00054 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="Error_8cc.html#a3">Error_delete_buffer</a>(<span class="keywordtype">void</span> * buffer);
00055 <span class="keyword">extern</span> <span class="keywordtype">void</span> *<a class="code" href="Error_8cc.html#a4">Error_buffer</a>(FILE *fp);
00056 
00057 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="Error_8cc.html#a5">Errorrestart</a>(FILE *yyin);   <span class="comment">// defined in Error.tab.c</span>
00058 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="Error_8cc.html#a6">Errorparse</a>(<span class="keywordtype">void</span> *arg);   
00059 
00060 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *messages[]={<span class="stringliteral">"Unknown error"</span>, <span class="stringliteral">"No such file"</span>, 
00061                    <span class="stringliteral">"No such variable"</span>, <span class="stringliteral">"Malformed expression"</span>,
00062                    <span class="stringliteral">"No authorization"</span>, <span class="stringliteral">"Cannot read file"</span>};
00063 
<a name="l00066"></a><a class="code" href="classError.html#Errora3">00066</a> <a class="code" href="classError.html#Errora3">Error::Error</a>()
00067     : _error_code(<a class="code" href="Error_8h.html#a0">undefined_error</a>), _error_message(""), 
00068       _program_type(<a class="code" href="Error_8h.html#a14a10">undefined_prog_type</a>), _program(0)
00069 {
00070 }
00071 
<a name="l00081"></a><a class="code" href="classError.html#Errora0">00081</a> <a class="code" href="classError.html#Errora3">Error::Error</a>(<a class="code" href="Error_8h.html#a9">ErrorCode</a> ec, string msg)
00082     : _error_code(ec), _error_message(msg), 
00083       _program_type(<a class="code" href="Error_8h.html#a14a10">undefined_prog_type</a>), _program(0)
00084 {
00085 }
00086 
<a name="l00092"></a><a class="code" href="classError.html#Errora1">00092</a> <a class="code" href="classError.html#Errora3">Error::Error</a>(string msg)
00093     : _error_code(<a class="code" href="Error_8h.html#a1">unknown_error</a>), _error_message(msg), 
00094       _program_type(<a class="code" href="Error_8h.html#a14a10">undefined_prog_type</a>), _program(0)
00095 {
00096 }
00097 
<a name="l00099"></a><a class="code" href="classError.html#Errora2">00099</a> <a class="code" href="classError.html#Errora3">Error::Error</a>(<a class="code" href="Error_8h.html#a9">ErrorCode</a> ec, string msg, ProgramType pt, <span class="keywordtype">char</span> *pgm)
00100     : _error_code(ec), _error_message(msg), 
00101       _program_type(pt), _program(0)
00102 {
00103     <a class="code" href="classError.html#ResponseTooBigErrp3">_program</a> = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(pgm) + 1];
00104     strcpy(<a class="code" href="classError.html#ResponseTooBigErrp3">_program</a>, pgm);
00105 }
00106 
<a name="l00107"></a><a class="code" href="classError.html#Errora4">00107</a> <a class="code" href="classError.html#Errora3">Error::Error</a>(<span class="keyword">const</span> <a class="code" href="classError.html">Error</a> &amp;copy_from)
00108     : _error_code(copy_from._error_code),
00109       _error_message(copy_from._error_message),
00110       _program_type(copy_from._program_type), _program(0)
00111 {
00112     <span class="keywordflow">if</span> (copy_from._program) {
00113     <a class="code" href="classError.html#ResponseTooBigErrp3">_program</a> = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(copy_from._program) + 1];
00114     strcpy(<a class="code" href="classError.html#ResponseTooBigErrp3">_program</a>, copy_from._program);
00115     }
00116 }    
00117 
<a name="l00118"></a><a class="code" href="classError.html#Errora5">00118</a> <a class="code" href="classError.html#Errora5">Error::~Error</a>()
00119 {
00120     <span class="keyword">delete</span> <a class="code" href="classError.html#ResponseTooBigErrp3">_program</a>; <a class="code" href="classError.html#ResponseTooBigErrp3">_program</a> = 0;
00121 }
00122 
00123 <a class="code" href="classError.html">Error</a> &amp;
<a name="l00124"></a><a class="code" href="classError.html#Errora6">00124</a> <a class="code" href="classError.html#Errora6">Error::operator=</a>(<span class="keyword">const</span> <a class="code" href="classError.html">Error</a> &amp;rhs)
00125 {
00126     assert(<a class="code" href="classError.html#ResponseTooBigErra2">OK</a>());
00127 
00128     <span class="keywordflow">if</span> (&amp;rhs == <span class="keyword">this</span>)       <span class="comment">// are they identical?</span>
00129     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00130     <span class="keywordflow">else</span> {
00131     <a class="code" href="classError.html#ResponseTooBigErrp0">_error_code</a> = rhs.<a class="code" href="classError.html#ResponseTooBigErrp0">_error_code</a>;
00132     <a class="code" href="classError.html#ResponseTooBigErrp1">_error_message</a> = rhs.<a class="code" href="classError.html#ResponseTooBigErrp1">_error_message</a>;
00133     <a class="code" href="classError.html#ResponseTooBigErrp2">_program_type</a> = rhs.<a class="code" href="classError.html#ResponseTooBigErrp2">_program_type</a>;
00134 
00135     <span class="keyword">delete</span>[] <a class="code" href="classError.html#ResponseTooBigErrp3">_program</a>; <a class="code" href="classError.html#ResponseTooBigErrp3">_program</a> = 0;
00136     <span class="keywordflow">if</span> (rhs.<a class="code" href="classError.html#ResponseTooBigErrp3">_program</a>) {
00137         <a class="code" href="classError.html#ResponseTooBigErrp3">_program</a> = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(rhs.<a class="code" href="classError.html#ResponseTooBigErrp3">_program</a>) + 1];
00138         strcpy(<a class="code" href="classError.html#ResponseTooBigErrp3">_program</a>, rhs.<a class="code" href="classError.html#ResponseTooBigErrp3">_program</a>);
00139     }
00140 
00141     assert(this-&gt;OK());
00142 
00143     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00144     }
00145 }
00146 
00153 <span class="keywordtype">bool</span>
<a name="l00154"></a><a class="code" href="classError.html#ResponseTooBigErra2">00154</a> <a class="code" href="classError.html#ResponseTooBigErra2">Error::OK</a>()<span class="keyword"> const</span>
00155 <span class="keyword"></span>{
00156     <span class="comment">// The object is empty - users cannot make these, but this class can!</span>
00157     <span class="keywordtype">bool</span> empty = ((<a class="code" href="classError.html#ResponseTooBigErrp0">_error_code</a> == <a class="code" href="Error_8h.html#a0">undefined_error</a>) 
00158           &amp;&amp; (<a class="code" href="classError.html#ResponseTooBigErrp1">_error_message</a> == <span class="stringliteral">""</span>)
00159           &amp;&amp; (<a class="code" href="classError.html#ResponseTooBigErrp2">_program_type</a> == <a class="code" href="Error_8h.html#a14a10">undefined_prog_type</a>) 
00160           &amp;&amp; (<a class="code" href="classError.html#ResponseTooBigErrp3">_program</a> == 0));
00161 
00162     <span class="comment">// Just a message - the program part is null.</span>
00163     <span class="keywordtype">bool</span> message = ((_error_code != <a class="code" href="Error_8h.html#a0">undefined_error</a>) 
00164             &amp;&amp; (<a class="code" href="classError.html#ResponseTooBigErrp1">_error_message</a> != <span class="stringliteral">""</span>)
00165             &amp;&amp; (<a class="code" href="classError.html#ResponseTooBigErrp2">_program_type</a> == <a class="code" href="Error_8h.html#a14a10">undefined_prog_type</a>) 
00166             &amp;&amp; (<a class="code" href="classError.html#ResponseTooBigErrp3">_program</a> == 0));
00167 
00168     <span class="comment">// Message and program parts are in working order.</span>
00169     <span class="keywordtype">bool</span> <a class="code" href="classError.html#ResponseTooBigErra18">program</a> = ((_error_code != <a class="code" href="Error_8h.html#a0">undefined_error</a>) 
00170             &amp;&amp; (<a class="code" href="classError.html#ResponseTooBigErrp1">_error_message</a> != <span class="stringliteral">""</span>)
00171             &amp;&amp; (<a class="code" href="classError.html#ResponseTooBigErrp2">_program_type</a> != <a class="code" href="Error_8h.html#a14a10">undefined_prog_type</a>) 
00172             &amp;&amp; (<a class="code" href="classError.html#ResponseTooBigErrp3">_program</a> != 0));
00173 
00174     <span class="keywordflow">return</span> empty || message || program;
00175 }
00176 
00185 <span class="keywordtype">bool</span>
<a name="l00186"></a><a class="code" href="classError.html#ResponseTooBigErra3">00186</a> <a class="code" href="classError.html#ResponseTooBigErra3">Error::parse</a>(FILE *fp)
00187 {
00188     <span class="keywordflow">if</span> (!fp)
00189     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, <span class="stringliteral">"Null input stream"</span>); 
00190 
00191     <span class="keywordtype">void</span> *buffer = <a class="code" href="Error_8cc.html#a4">Error_buffer</a>(fp);
00192     <a class="code" href="Error_8cc.html#a2">Error_switch_to_buffer</a>(buffer);
00193 
00194     <a class="code" href="structparser__arg.html">parser_arg</a> arg(<span class="keyword">this</span>);
00195 
00196     <span class="keywordtype">bool</span> status;
00197     <span class="keywordflow">try</span> {
00198     status = <a class="code" href="Error_8cc.html#a6">Errorparse</a>((<span class="keywordtype">void</span> *)&amp;arg) == 0;
00199     <a class="code" href="Error_8cc.html#a3">Error_delete_buffer</a>(buffer);
00200     }
00201     <span class="keywordflow">catch</span> (<a class="code" href="classError.html">Error</a> &amp;e) {
00202     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, e.error_message());
00203     <a class="code" href="Error_8cc.html#a3">Error_delete_buffer</a>(buffer);
00204     }
00205 
00206     <span class="comment">// STATUS is the result of the parser function; if a recoverable error</span>
00207     <span class="comment">// was found it will be true but arg.status() will be false.</span>
00208     <span class="comment">// I'm throwing an InternalErr here since Error objects are generated by</span>
00209     <span class="comment">// the core; they should always parse! 9/21/2000 jhrg</span>
00210     <span class="keywordflow">if</span> (!status || !arg.<a class="code" href="structparser__arg.html#parser__arga7">status</a>())
00211     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, <span class="stringliteral">"Error parsing error object!"</span>);
00212     <span class="keywordflow">else</span>
00213     <span class="keywordflow">return</span> <a class="code" href="classError.html#ResponseTooBigErra2">OK</a>();        <span class="comment">// Check object consistency</span>
00214 }
00215     
00217 <span class="keywordtype">void</span>
<a name="l00218"></a><a class="code" href="classError.html#ResponseTooBigErra4">00218</a> <a class="code" href="classError.html#ResponseTooBigErra4">Error::print</a>(ostream &amp;os)<span class="keyword"> const</span>
00219 <span class="keyword"></span>{
00220     assert(<a class="code" href="classError.html#ResponseTooBigErra2">OK</a>());
00221 
00222     os &lt;&lt; <span class="stringliteral">"Error {"</span> &lt;&lt; endl;
00223 
00224     os &lt;&lt; <span class="stringliteral">"    "</span> &lt;&lt; <span class="stringliteral">"code = "</span> &lt;&lt; static_cast&lt;int&gt;(<a class="code" href="classError.html#ResponseTooBigErrp0">_error_code</a>) &lt;&lt; <span class="stringliteral">";"</span> &lt;&lt; endl;
00225     
00226     <span class="comment">// If the error message is wrapped in double quotes, print it, else, add</span>
00227     <span class="comment">// wrapping double quotes.</span>
00228     <span class="keywordflow">if</span> (*<a class="code" href="classError.html#ResponseTooBigErrp1">_error_message</a>.begin() == <span class="charliteral">'"'</span> &amp;&amp; *(<a class="code" href="classError.html#ResponseTooBigErrp1">_error_message</a>.end()-1) == <span class="charliteral">'"'</span>)
00229     os &lt;&lt; <span class="stringliteral">"    "</span> &lt;&lt; <span class="stringliteral">"message = "</span> &lt;&lt; <a class="code" href="classError.html#ResponseTooBigErrp1">_error_message</a> &lt;&lt; <span class="stringliteral">";"</span> &lt;&lt; endl;
00230     <span class="keywordflow">else</span>
00231     os &lt;&lt; <span class="stringliteral">"    "</span> &lt;&lt; <span class="stringliteral">"message = "</span> &lt;&lt; <span class="stringliteral">"\""</span> &lt;&lt; <a class="code" href="classError.html#ResponseTooBigErrp1">_error_message</a> &lt;&lt; <span class="stringliteral">"\""</span> &lt;&lt; <span class="stringliteral">";"</span> 
00232        &lt;&lt; endl;
00233 
00234     <span class="keywordflow">if</span> (<a class="code" href="classError.html#ResponseTooBigErrp2">_program_type</a> != <a class="code" href="Error_8h.html#a14a10">undefined_prog_type</a>) {
00235     os &lt;&lt; <span class="stringliteral">"    "</span> &lt;&lt; <span class="stringliteral">"program_type = "</span> &lt;&lt; static_cast&lt;int&gt;(<a class="code" href="classError.html#ResponseTooBigErrp2">_program_type</a>)
00236        &lt;&lt; <span class="stringliteral">";"</span> &lt;&lt; endl;
00237     os &lt;&lt; <span class="stringliteral">"    "</span> &lt;&lt; <span class="stringliteral">"program = "</span> &lt;&lt; <a class="code" href="classError.html#ResponseTooBigErrp3">_program</a> &lt;&lt; <span class="stringliteral">";"</span> &lt;&lt; endl;
00238     }
00239 
00240     os &lt;&lt; <span class="stringliteral">"};"</span> &lt;&lt; endl;
00241 }
00242 
00253 <span class="keywordtype">void</span>
<a name="l00254"></a><a class="code" href="classError.html#ResponseTooBigErra5">00254</a> <a class="code" href="classError.html#ResponseTooBigErra4">Error::print</a>(FILE *out)<span class="keyword"> const</span>
00255 <span class="keyword"></span>{
00256     assert(<a class="code" href="classError.html#ResponseTooBigErra2">OK</a>());
00257 
00258     fprintf( out, <span class="stringliteral">"Error {\n"</span> ) ;
00259 
00260     fprintf( out, <span class="stringliteral">"    code = %d;\n"</span>, static_cast&lt;int&gt;(<a class="code" href="classError.html#ResponseTooBigErrp0">_error_code</a>) ) ;
00261     
00262     <span class="comment">// If the error message is wrapped in double quotes, print it, else, add</span>
00263     <span class="comment">// wrapping double quotes.</span>
00264     <span class="keywordflow">if</span> (*<a class="code" href="classError.html#ResponseTooBigErrp1">_error_message</a>.begin() == <span class="charliteral">'"'</span> &amp;&amp; *(<a class="code" href="classError.html#ResponseTooBigErrp1">_error_message</a>.end()-1) == <span class="charliteral">'"'</span>)
00265     fprintf( out, <span class="stringliteral">"    message = %s;\n"</span>, <a class="code" href="classError.html#ResponseTooBigErrp1">_error_message</a>.c_str() ) ;
00266     <span class="keywordflow">else</span>
00267     fprintf( out, <span class="stringliteral">"    message = \"%s\";\n"</span>, <a class="code" href="classError.html#ResponseTooBigErrp1">_error_message</a>.c_str() ) ;
00268 
00269     <span class="keywordflow">if</span> (<a class="code" href="classError.html#ResponseTooBigErrp2">_program_type</a> != <a class="code" href="Error_8h.html#a14a10">undefined_prog_type</a>) {
00270     fprintf( out, <span class="stringliteral">"    program_type = %d;\n"</span>,
00271          static_cast&lt;int&gt;(<a class="code" href="classError.html#ResponseTooBigErrp2">_program_type</a>) ) ;
00272     fprintf( out, <span class="stringliteral">"    program = %s;\n"</span>, <a class="code" href="classError.html#ResponseTooBigErrp3">_program</a> ) ;
00273     }
00274 
00275     fprintf( out, <span class="stringliteral">"};\n"</span> ) ;
00276 }
00277 
00279 <a class="code" href="Error_8h.html#a9">ErrorCode</a>
<a name="l00280"></a><a class="code" href="classError.html#ResponseTooBigErra19">00280</a> <a class="code" href="classError.html#ResponseTooBigErra19">Error::error_code</a>(<a class="code" href="Error_8h.html#a9">ErrorCode</a> ec)
00281 {
00282     assert(<a class="code" href="classError.html#ResponseTooBigErra2">OK</a>());
00283     <span class="keywordflow">if</span> (ec == <a class="code" href="Error_8h.html#a0">undefined_error</a>)
00284     <span class="keywordflow">return</span> <a class="code" href="classError.html#ResponseTooBigErrp0">_error_code</a>;
00285     <span class="keywordflow">else</span> {
00286     <a class="code" href="classError.html#ResponseTooBigErrp0">_error_code</a> = ec;
00287     <span class="comment">// Added check to make sure that messages is not accessed beyond its</span>
00288     <span class="comment">// bounds. 02/02/04 jhrg</span>
00289     <span class="keywordflow">if</span> (<a class="code" href="classError.html#ResponseTooBigErrp1">_error_message</a> == <span class="stringliteral">""</span> 
00290         &amp;&amp; ec &gt; <a class="code" href="Error_8h.html#a0">undefined_error</a> &amp;&amp; ec &lt;= <a class="code" href="Error_8h.html#a8">cannot_read_file</a>)
00291         <a class="code" href="classError.html#ResponseTooBigErrp1">_error_message</a> = messages[ec - <a class="code" href="Error_8h.html#a0">undefined_error</a> - 1];
00292     assert(<a class="code" href="classError.html#ResponseTooBigErra2">OK</a>());
00293     <span class="keywordflow">return</span> <a class="code" href="classError.html#ResponseTooBigErrp0">_error_code</a>;
00294     }
00295 }
00296 
00298 <a class="code" href="Error_8h.html#a9">ErrorCode</a>
<a name="l00299"></a><a class="code" href="classError.html#ResponseTooBigErra6">00299</a> <a class="code" href="classError.html#ResponseTooBigErra6">Error::get_error_code</a>()<span class="keyword"> const</span>
00300 <span class="keyword"></span>{
00301     assert(<a class="code" href="classError.html#ResponseTooBigErra2">OK</a>());
00302     <span class="keywordflow">return</span> <a class="code" href="classError.html#ResponseTooBigErrp0">_error_code</a>;
00303 }
00304 
00311 <span class="keywordtype">void</span>
<a name="l00312"></a><a class="code" href="classError.html#ResponseTooBigErra10">00312</a> <a class="code" href="classError.html#ResponseTooBigErra10">Error::set_error_code</a>(<a class="code" href="Error_8h.html#a9">ErrorCode</a> ec)
00313 {
00314     <a class="code" href="classError.html#ResponseTooBigErrp0">_error_code</a> = ec;
00315     <span class="comment">// Added check to make sure that messages is not accessed beyond its</span>
00316     <span class="comment">// bounds. 02/02/04 jhrg</span>
00317     <span class="keywordflow">if</span> (<a class="code" href="classError.html#ResponseTooBigErrp1">_error_message</a> == <span class="stringliteral">""</span>
00318     &amp;&amp; ec &gt; <a class="code" href="Error_8h.html#a0">undefined_error</a> &amp;&amp; ec &lt;= <a class="code" href="Error_8h.html#a8">cannot_read_file</a>)
00319     <a class="code" href="classError.html#ResponseTooBigErrp1">_error_message</a> = messages[ec - <a class="code" href="Error_8h.html#a0">undefined_error</a> - 1];
00320     assert(<a class="code" href="classError.html#ResponseTooBigErra2">OK</a>());
00321 }
00322 
00324 string
<a name="l00325"></a><a class="code" href="classError.html#ResponseTooBigErra16">00325</a> <a class="code" href="classError.html#ResponseTooBigErra16">Error::error_message</a>(string msg)
00326 {
00327     assert(<a class="code" href="classError.html#ResponseTooBigErra2">OK</a>());
00328     <span class="keywordflow">if</span> (msg == <span class="stringliteral">""</span>)
00329     <span class="keywordflow">return</span> string(<a class="code" href="classError.html#ResponseTooBigErrp1">_error_message</a>);
00330     <span class="keywordflow">else</span> {
00331     <a class="code" href="classError.html#ResponseTooBigErrp1">_error_message</a> = msg;
00332     assert(<a class="code" href="classError.html#ResponseTooBigErra2">OK</a>());
00333     <span class="keywordflow">return</span> string (<a class="code" href="classError.html#ResponseTooBigErrp1">_error_message</a>);
00334     }
00335 }
00336 
00338 string
<a name="l00339"></a><a class="code" href="classError.html#ResponseTooBigErra7">00339</a> <a class="code" href="classError.html#ResponseTooBigErra7">Error::get_error_message</a>()<span class="keyword"> const</span>
00340 <span class="keyword"></span>{
00341     assert(<a class="code" href="classError.html#ResponseTooBigErra2">OK</a>());
00342 
00343     <span class="keywordflow">return</span> string(<a class="code" href="classError.html#ResponseTooBigErrp1">_error_message</a>);
00344 }
00345 
00347 <span class="keywordtype">void</span>
<a name="l00348"></a><a class="code" href="classError.html#ResponseTooBigErra11">00348</a> <a class="code" href="classError.html#ResponseTooBigErra11">Error::set_error_message</a>(string msg)
00349 {
00350     <a class="code" href="classError.html#ResponseTooBigErrp1">_error_message</a> = msg;
00351     assert(<a class="code" href="classError.html#ResponseTooBigErra2">OK</a>());
00352 }
00353 
00355 <span class="keywordtype">void</span>
<a name="l00356"></a><a class="code" href="classError.html#ResponseTooBigErra14">00356</a> <a class="code" href="classError.html#ResponseTooBigErra14">Error::display_message</a>(<span class="keywordtype">void</span> *)<span class="keyword"> const</span>
00357 <span class="keyword"></span>{
00358     assert(<a class="code" href="classError.html#ResponseTooBigErra2">OK</a>());
00359     cerr &lt;&lt; <a class="code" href="classError.html#ResponseTooBigErrp1">_error_message</a> &lt;&lt; endl;
00360 }
00361 
00363 <a class="code" href="Error_8h.html#a14">ProgramType</a>
<a name="l00364"></a><a class="code" href="classError.html#ResponseTooBigErra17">00364</a> <a class="code" href="classError.html#ResponseTooBigErra17">Error::program_type</a>(ProgramType pt)
00365 {
00366     assert(<a class="code" href="classError.html#ResponseTooBigErra2">OK</a>());
00367     <span class="keywordflow">if</span> (pt == <a class="code" href="Error_8h.html#a14a10">undefined_prog_type</a>)
00368     <span class="keywordflow">return</span> <a class="code" href="classError.html#ResponseTooBigErrp2">_program_type</a>;
00369     <span class="keywordflow">else</span> {
00370     <a class="code" href="classError.html#ResponseTooBigErrp2">_program_type</a> = pt;
00371     <span class="keywordflow">return</span> <a class="code" href="classError.html#ResponseTooBigErrp2">_program_type</a>;
00372     }
00373 }
00374 
00376 <a class="code" href="Error_8h.html#a14">ProgramType</a>
<a name="l00377"></a><a class="code" href="classError.html#ResponseTooBigErra8">00377</a> <a class="code" href="classError.html#ResponseTooBigErra8">Error::get_program_type</a>()<span class="keyword"> const</span>
00378 <span class="keyword"></span>{
00379     assert(<a class="code" href="classError.html#ResponseTooBigErra2">OK</a>());
00380 
00381     <span class="keywordflow">return</span> <a class="code" href="classError.html#ResponseTooBigErrp2">_program_type</a>;
00382 }
00383 
00385 <span class="keywordtype">void</span>
<a name="l00386"></a><a class="code" href="classError.html#ResponseTooBigErra12">00386</a> <a class="code" href="classError.html#ResponseTooBigErra12">Error::set_program_type</a>(ProgramType pt)
00387 {
00388     <a class="code" href="classError.html#ResponseTooBigErrp2">_program_type</a> = pt;
00389 }
00390 
00392 <span class="keywordtype">char</span> *
<a name="l00393"></a><a class="code" href="classError.html#ResponseTooBigErra18">00393</a> <a class="code" href="classError.html#ResponseTooBigErra18">Error::program</a>(<span class="keywordtype">char</span> *pgm)
00394 {
00395     <span class="keywordflow">if</span> (pgm == 0)
00396     <span class="keywordflow">return</span> <a class="code" href="classError.html#ResponseTooBigErrp3">_program</a>;
00397     <span class="keywordflow">else</span> {
00398     <a class="code" href="classError.html#ResponseTooBigErrp3">_program</a> = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(pgm) + 1];
00399     strcpy(<a class="code" href="classError.html#ResponseTooBigErrp3">_program</a>, pgm);
00400     <span class="keywordflow">return</span> <a class="code" href="classError.html#ResponseTooBigErrp3">_program</a>;
00401     }
00402 }
00403 
00405 <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l00406"></a><a class="code" href="classError.html#ResponseTooBigErra9">00406</a> <a class="code" href="classError.html#ResponseTooBigErra9">Error::get_program</a>()<span class="keyword"> const</span>
00407 <span class="keyword"></span>{
00408     <span class="keywordflow">return</span> <a class="code" href="classError.html#ResponseTooBigErrp3">_program</a>;
00409 }
00410 
00412 <span class="keywordtype">void</span>
<a name="l00413"></a><a class="code" href="classError.html#ResponseTooBigErra13">00413</a> <a class="code" href="classError.html#ResponseTooBigErra13">Error::set_program</a>(<span class="keywordtype">char</span> *pgm)
00414 {
00415     <a class="code" href="classError.html#ResponseTooBigErrp3">_program</a> = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(pgm) + 1];
00416     strcpy(<a class="code" href="classError.html#ResponseTooBigErrp3">_program</a>, pgm);
00417 }
00418 
00420 string
<a name="l00421"></a><a class="code" href="classError.html#ResponseTooBigErra15">00421</a> <a class="code" href="classError.html#ResponseTooBigErra15">Error::correct_error</a>(<span class="keywordtype">void</span> *)<span class="keyword"> const</span>
00422 <span class="keyword"></span>{
00423     assert(<a class="code" href="classError.html#ResponseTooBigErra2">OK</a>());
00424     <span class="keywordflow">if</span> (!<a class="code" href="classError.html#ResponseTooBigErra2">OK</a>())
00425     <span class="keywordflow">return</span> string(<span class="stringliteral">""</span>);
00426 
00427     <a class="code" href="classError.html#ResponseTooBigErra14">display_message</a>(NULL);
00428     <span class="keywordflow">return</span> string(<span class="stringliteral">""</span>);
00429 }
00430 
00431 <span class="comment">// $Log: Error_8cc-source.html,v $
00431 <span class="comment">// Revision 1.4  2004/02/05 06:51:16  jimg
00431 <span class="comment">// Added/update.
00431 <span class="comment">//</span>
00432 <span class="comment">// Revision 1.32.2.3  2004/02/04 00:05:11  jimg</span>
00433 <span class="comment">// Memory errors: I've fixed a number of memory errors (leaks, references)</span>
00434 <span class="comment">// found using valgrind. Many remain. I need to come up with a systematic</span>
00435 <span class="comment">// way of running the tests under valgrind.</span>
00436 <span class="comment">//</span>
00437 <span class="comment">// Revision 1.32.2.2  2004/02/03 00:18:08  jimg</span>
00438 <span class="comment">// Fixed bug 691. The array messages was improperly accessed. I also revamped</span>
00439 <span class="comment">// the doxygen comments and re-indented the code.</span>
00440 <span class="comment">//</span>
00441 <span class="comment">// Revision 1.32.2.1  2003/09/06 22:37:50  jimg</span>
00442 <span class="comment">// Updated the documentation.</span>
00443 <span class="comment">//</span>
00444 <span class="comment">// Revision 1.32  2003/04/22 19:40:27  jimg</span>
00445 <span class="comment">// Merged with 3.3.1.</span>
00446 <span class="comment">//</span>
00447 <span class="comment">// Revision 1.31  2003/02/21 00:14:24  jimg</span>
00448 <span class="comment">// Repaired copyright.</span>
00449 <span class="comment">//</span>
00450 <span class="comment">// Revision 1.30.2.1  2003/02/21 00:10:07  jimg</span>
00451 <span class="comment">// Repaired copyright.</span>
00452 <span class="comment">//</span>
00453 <span class="comment">// Revision 1.30  2003/01/23 00:22:24  jimg</span>
00454 <span class="comment">// Updated the copyright notice; this implementation of the DAP is</span>
00455 <span class="comment">// copyrighted by OPeNDAP, Inc.</span>
00456 <span class="comment">//</span>
00457 <span class="comment">// Revision 1.29  2003/01/10 19:46:40  jimg</span>
00458 <span class="comment">// Merged with code tagged release-3-2-10 on the release-3-2 branch. In many</span>
00459 <span class="comment">// cases files were added on that branch (so they appear on the trunk for</span>
00460 <span class="comment">// the first time).</span>
00461 <span class="comment">//</span>
00462 <span class="comment">// Revision 1.24.2.8  2002/12/17 22:35:03  pwest</span>
00463 <span class="comment">// Added and updated methods using stdio. Deprecated methods using iostream.</span>
00464 <span class="comment">//</span>
00465 <span class="comment">// Revision 1.24.2.7  2002/08/08 06:54:57  jimg</span>
00466 <span class="comment">// Changes for thread-safety. In many cases I found ugly places at the</span>
00467 <span class="comment">// tops of files while looking for globals, et c., and I fixed them up</span>
00468 <span class="comment">// (hopefully making them easier to read, ...). Only the files RCReader.cc</span>
00469 <span class="comment">// and usage.cc actually use pthreads synchronization functions. In other</span>
00470 <span class="comment">// cases I removed static objects where they were used for supposed</span>
00471 <span class="comment">// improvements in efficiency which had never actually been verified (and</span>
00472 <span class="comment">// which looked dubious).</span>
00473 <span class="comment">//</span>
00474 <span class="comment">// Revision 1.28  2002/06/18 15:36:24  tom</span>
00475 <span class="comment">// Moved comments and edited to accommodate doxygen documentation-generator.</span>
00476 <span class="comment">//</span>
00477 <span class="comment">// Revision 1.24.2.6  2002/05/26 23:36:09  jimg</span>
00478 <span class="comment">// Removed code specific to the GUI-based progress indicator.</span>
00479 <span class="comment">//</span>
00480 <span class="comment">// Revision 1.27  2001/10/14 01:28:38  jimg</span>
00481 <span class="comment">// Merged with release-3-2-8.</span>
00482 <span class="comment">//</span>
00483 <span class="comment">// Revision 1.24.2.5  2001/10/08 17:14:22  jimg</span>
00484 <span class="comment">// Fixed a bug where an empty _program field was copied in operator=. This</span>
00485 <span class="comment">// caused seg faults because the copy used strlen on _program; when it was null</span>
00486 <span class="comment">// that meant dereferencing the null pointer.</span>
00487 <span class="comment">//</span>
00488 <span class="comment">// Revision 1.26  2001/08/24 17:46:22  jimg</span>
00489 <span class="comment">// Resolved conflicts from the merge of release 3.2.6</span>
00490 <span class="comment">//</span>
00491 <span class="comment">// Revision 1.24.2.4  2001/08/18 00:18:07  jimg</span>
00492 <span class="comment">// Removed WIN32 compile guards from using statements.</span>
00493 <span class="comment">//</span>
00494 <span class="comment">// Revision 1.24.2.3  2001/07/28 01:10:42  jimg</span>
00495 <span class="comment">// Some of the numeric type classes did not have copy ctors or operator=.</span>
00496 <span class="comment">// I added those where they were needed.</span>
00497 <span class="comment">// In every place where delete (or delete []) was called, I set the pointer</span>
00498 <span class="comment">// just deleted to zero. Thus if for some reason delete is called again</span>
00499 <span class="comment">// before new memory is allocated there won't be a mysterious crash. This is</span>
00500 <span class="comment">// just good form when using delete.</span>
00501 <span class="comment">// I added calls to www2id and id2www where appropriate. The DAP now handles</span>
00502 <span class="comment">// making sure that names are escaped and unescaped as needed. Connect is</span>
00503 <span class="comment">// set to handle CEs that contain names as they are in the dataset (see the</span>
00504 <span class="comment">// comments/Log there). Servers should not handle escaping or unescaping</span>
00505 <span class="comment">// characters on their own.</span>
00506 <span class="comment">//</span>
00507 <span class="comment">// Revision 1.25  2001/06/15 23:49:02  jimg</span>
00508 <span class="comment">// Merged with release-3-2-4.</span>
00509 <span class="comment">//</span>
00510 <span class="comment">// Revision 1.24.2.2  2001/05/03 21:42:59  jimg</span>
00511 <span class="comment">// Fixed a bug in parse(...) where the FILE * passed to the method was closed.</span>
00512 <span class="comment">// This FILE * should be closed by the caller. When used with a Connect object,</span>
00513 <span class="comment">// Connect's dtor tries to close the FILE *. If parse(...) has already closed</span>
00514 <span class="comment">// it...boom.</span>
00515 <span class="comment">//</span>
00516 <span class="comment">// Revision 1.24.2.1  2001/04/23 22:18:15  jimg</span>
00517 <span class="comment">// Added two static casts to Error::print(). This fixes a warning from g++.</span>
00518 <span class="comment">//</span>
00519 <span class="comment">// Revision 1.24  2000/10/30 17:21:27  jimg</span>
00520 <span class="comment">// Added support for proxy servers (from cjm).</span>
00521 <span class="comment">//</span>
00522 <span class="comment">// Revision 1.23  2000/10/02 18:49:26  jimg</span>
00523 <span class="comment">// The Error class now has const accessors</span>
00524 <span class="comment">//</span>
00525 <span class="comment">// Revision 1.22  2000/09/22 02:17:19  jimg</span>
00526 <span class="comment">// Rearranged source files so that the CVS logs appear at the end rather than</span>
00527 <span class="comment">// the start. Also made the ifdef guard symbols use the same naming scheme and</span>
00528 <span class="comment">// wrapped headers included in other headers in those guard symbols (to cut</span>
00529 <span class="comment">// down on extraneous file processing - See Lakos).</span>
00530 <span class="comment">//</span>
00531 <span class="comment">// Revision 1.21  2000/07/09 22:05:35  rmorris</span>
00532 <span class="comment">// Changes to increase portability, minimize ifdef's for win32 and account</span>
00533 <span class="comment">// for differences in the iostreams implementations.</span>
00534 <span class="comment">//</span>
00535 <span class="comment">// Revision 1.20  2000/03/28 16:32:02  jimg</span>
00536 <span class="comment">// Modified these files so that they can be built either with and without GUI</span>
00537 <span class="comment">// defined. The type signatures are now the same either way. Thus we can build</span>
00538 <span class="comment">// libdap++-gui and libdap++ (without GUI support). When using the later</span>
00539 <span class="comment">// there's no need to link with tcl, tk or X11. This makes the executables</span>
00540 <span class="comment">// smaller. It also keeps the servers from potentially needing sharable</span>
00541 <span class="comment">// libraries (since X11 is often sharable) which can be hard to find unless</span>
00542 <span class="comment">// they are in the standard places. I made the same changes in Connect and Gui.</span>
00543 <span class="comment">//</span>
00544 <span class="comment">// Revision 1.19  1999/08/23 18:57:44  jimg</span>
00545 <span class="comment">// Merged changes from release 3.1.0</span>
00546 <span class="comment">//</span>
00547 <span class="comment">// Revision 1.18.2.1  1999/08/09 22:57:50  jimg</span>
00548 <span class="comment">// Removed GUI code; reactivate by defining GUI</span>
00549 <span class="comment">//</span>
00550 <span class="comment">// Revision 1.18  1999/08/09 18:27:34  jimg</span>
00551 <span class="comment">// Merged changes from Brent for the Gui code (progress indicator)</span>
00552 <span class="comment">//</span>
00553 <span class="comment">// Revision 1.17.4.1  1999/07/29 05:46:17  brent</span>
00554 <span class="comment">// call Tcl / GUI directly from Gui.cc, abandon expect, and consolidate Tcl files</span>
00555 <span class="comment">//</span>
00556 <span class="comment">// Revision 1.17  1999/05/26 17:32:01  jimg</span>
00557 <span class="comment">// Added a message for the `unknown_error' constant.</span>
00558 <span class="comment">// Added a test in correct_error for a NULL Gui object. If the Gui object is</span>
00559 <span class="comment">// null, display the message text on stderr and ignore the Gui object.</span>
00560 <span class="comment">//</span>
00561 <span class="comment">// Revision 1.16  1999/05/04 19:47:21  jimg</span>
00562 <span class="comment">// Fixed copyright statements. Removed more of the GNU classes.</span>
00563 <span class="comment">//</span>
00564 <span class="comment">// Revision 1.15  1999/04/29 02:29:29  jimg</span>
00565 <span class="comment">// Merge of no-gnu branch</span>
00566 <span class="comment">//</span>
00567 <span class="comment">// Revision 1.14.6.2  1999/02/05 09:32:34  jimg</span>
00568 <span class="comment">// Fixed __unused__ so that it not longer clashes with Red Hat 5.2 inlined</span>
00569 <span class="comment">// math code. </span>
00570 <span class="comment">//</span>
00571 <span class="comment">// Revision 1.14.6.1  1999/02/02 21:56:58  jimg</span>
00572 <span class="comment">// String to string version</span>
00573 <span class="comment">//</span>
00574 <span class="comment">// Revision 1.14  1998/03/20 00:18:55  jimg</span>
00575 <span class="comment">// Fixed a bug where _program was feed into strlen even when it is NULL.</span>
00576 <span class="comment">//</span>
00577 <span class="comment">// Revision 1.13  1998/02/05 20:13:53  jimg</span>
00578 <span class="comment">// DODS now compiles with gcc 2.8.x</span>
00579 <span class="comment">//</span>
00580 <span class="comment">// Revision 1.12  1997/08/23 00:22:23  jimg</span>
00581 <span class="comment">// Changed the way that the _error_message member is processed. Now if the</span>
00582 <span class="comment">// message does not have explicit double quotes, print() will add them. The</span>
00583 <span class="comment">// mfunc is smart enough to add the quotes only if needed so old code (which</span>
00584 <span class="comment">// provides the quotes) will still work and new code without the quotes works</span>
00585 <span class="comment">// too. This makes for a more convenient use of the Error object.</span>
00586 <span class="comment">//</span>
00587 <span class="comment">// Revision 1.11  1997/03/05 08:15:51  jimg</span>
00588 <span class="comment">// Added Cannot read file message to list of builtin messages.</span>
00589 <span class="comment">//</span>
00590 <span class="comment">// Revision 1.10  1997/03/05 06:53:46  jimg</span>
00591 <span class="comment">// Changed display_message member function so that it uses Gui::response()</span>
00592 <span class="comment">// instead of Gui::command(). The later only works for things like the progress</span>
00593 <span class="comment">// popup for which expect does not need to wait. However, for things like</span>
00594 <span class="comment">// dialogs, expect must wait for the user to `hit OK', hence the use of the</span>
00595 <span class="comment">// response() member function.</span>
00596 <span class="comment">//</span>
00597 <span class="comment">// Revision 1.9  1997/02/27 01:06:47  jimg</span>
00598 <span class="comment">// Fixed problem with consistency check in Error::error_code().</span>
00599 <span class="comment">//</span>
00600 <span class="comment">// Revision 1.8  1997/02/18 21:22:18  jimg</span>
00601 <span class="comment">// Allow empty Error objects.</span>
00602 <span class="comment">//</span>
00603 <span class="comment">// Revision 1.7  1997/02/15 07:10:57  jimg</span>
00604 <span class="comment">// Changed OK() so that empty errors return false.</span>
00605 <span class="comment">// Added assert calls.</span>
00606 <span class="comment">//</span>
00607 <span class="comment">// Revision 1.6  1996/08/13 18:14:28  jimg</span>
00608 <span class="comment">// Switched to the parser_arg object for passing parameters to/from the Error.y</span>
00609 <span class="comment">// parser. NB: if an error object is bad a message is sent to stderr to avoid</span>
00610 <span class="comment">// going round and round with bad error objects!</span>
00611 <span class="comment">// Changed the interface to display_message; Gui is by default NULL so that</span>
00612 <span class="comment">// calling it with an empty parameter list causes the message string to be sent</span>
00613 <span class="comment">// to stderr.</span>
00614 <span class="comment">// Changed the interface to correct_error(); it now returns a string which is</span>
00615 <span class="comment">// the corrected error or "".</span>
00616 <span class="comment">//</span>
00617 <span class="comment">// Revision 1.5  1996/06/22 00:02:46  jimg</span>
00618 <span class="comment">// Added Gui pointer to the Error oject's correct_error() and</span>
00619 <span class="comment">// display_message() mfuncs. These mfuncs now used the GUI to display</span>
00620 <span class="comment">// messages.</span>
00621 <span class="comment">//</span>
00622 <span class="comment">// Revision 1.4  1996/06/04 21:33:22  jimg</span>
00623 <span class="comment">// Multiple connections are now possible. It is now possible to open several</span>
00624 <span class="comment">// URLs at the same time and read from them in a round-robin fashion. To do</span>
00625 <span class="comment">// this I added data source and sink parameters to the serialize and</span>
00626 <span class="comment">// deserialize mfuncs. Connect was also modified so that it manages the data</span>
00627 <span class="comment">// source `object' (which is just an XDR pointer).</span>
00628 <span class="comment">//</span>
00629 <span class="comment">// Revision 1.3  1996/06/03 06:26:51  jimg</span>
00630 <span class="comment">// Added declarations for Errorparse() and Errorrestart().</span>
00631 <span class="comment">//</span>
00632 <span class="comment">// Revision 1.2  1996/06/01 00:03:38  jimg</span>
00633 <span class="comment">// Added.</span>
00634 <span class="comment">//</span>
00635 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Feb 4 23:42:59 2004 for libdap++ by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
