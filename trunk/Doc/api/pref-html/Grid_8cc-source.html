<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libdap++: Grid.cc Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Grid.cc</h1><a href="Grid_8cc.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00002 <span class="comment">// -*- mode: c++; c-basic-offset:4 -*-</span>
00003 
00004 <span class="comment">// This file is part of libdap, A C++ implementation of the OPeNDAP Data</span>
00005 <span class="comment">// Access Protocol.</span>
00006 
00007 <span class="comment">// Copyright (c) 2002,2003 OPeNDAP, Inc.</span>
00008 <span class="comment">// Author: James Gallagher &lt;jgallagher@opendap.org&gt;</span>
00009 <span class="comment">//</span>
00010 <span class="comment">// This library is free software; you can redistribute it and/or</span>
00011 <span class="comment">// modify it under the terms of the GNU Lesser General Public</span>
00012 <span class="comment">// License as published by the Free Software Foundation; either</span>
00013 <span class="comment">// version 2.1 of the License, or (at your option) any later version.</span>
00014 <span class="comment">// </span>
00015 <span class="comment">// This library is distributed in the hope that it will be useful,</span>
00016 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00017 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00018 <span class="comment">// Lesser General Public License for more details.</span>
00019 <span class="comment">// </span>
00020 <span class="comment">// You should have received a copy of the GNU Lesser General Public</span>
00021 <span class="comment">// License along with this library; if not, write to the Free Software</span>
00022 <span class="comment">// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00023 <span class="comment">//</span>
00024 <span class="comment">// You can contact OPeNDAP, Inc. at PO Box 112, Saunderstown, RI. 02874-0112.</span>
00025  
00026 <span class="comment">// (c) COPYRIGHT URI/MIT 1994-1999</span>
00027 <span class="comment">// Please read the full copyright statement in the file COPYRIGHT_URI.</span>
00028 <span class="comment">//</span>
00029 <span class="comment">// Authors:</span>
00030 <span class="comment">//      jhrg,jimg       James Gallagher &lt;jgallagher@gso.uri.edu&gt;</span>
00031 
00032 <span class="comment">// implementation for Grid.</span>
00033 <span class="comment">//</span>
00034 <span class="comment">// jhrg 9/15/94</span>
00035 
00036 <span class="preprocessor">#include "<a class="code" href="config__dap_8h.html">config_dap.h</a>"</span>
00037 
00038 <span class="preprocessor">#include "<a class="code" href="Grid_8h.html">Grid.h</a>"</span>
00039 <span class="preprocessor">#include "<a class="code" href="DDS_8h.html">DDS.h</a>"</span>
00040 <span class="preprocessor">#include "<a class="code" href="Array_8h.html">Array.h</a>"</span>      <span class="comment">// for downcasts</span>
00041 <span class="preprocessor">#include "<a class="code" href="util_8h.html">util.h</a>"</span>
00042 <span class="preprocessor">#include "<a class="code" href="InternalErr_8h.html">InternalErr.h</a>"</span>
00043 <span class="preprocessor">#include "<a class="code" href="escaping_8h.html">escaping.h</a>"</span>
00044 <span class="preprocessor">#include "<a class="code" href="BTIterAdapter_8h.html">BTIterAdapter.h</a>"</span>
00045 
00046 <span class="preprocessor">#ifdef TRACE_NEW</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="trace__new_8h.html">trace_new.h</a>"</span>
00048 <span class="preprocessor">#endif</span>
00049 <span class="preprocessor"></span>
00050 <span class="keyword">using</span> std::cerr;
00051 <span class="keyword">using</span> std::endl;
00052 
00053 <span class="keywordtype">void</span>
00054 <a class="code" href="classConstructor.html#Structureb0">Grid::_duplicate</a>(<span class="keyword">const</span> <a class="code" href="classGrid.html">Grid</a> &amp;s)
00055 {
00056     _array_var = s.<a class="code" href="classGrid.html#Gridr0">_array_var</a>-&gt;<a class="code" href="classBaseType.html#Constructora6">ptr_duplicate</a>();
00057     _array_var-&gt;<a class="code" href="classBaseType.html#Vectora42">set_parent</a>(<span class="keyword">this</span>);
00058 
00059     <a class="code" href="classGrid.html">Grid</a> &amp;cs = const_cast&lt;Grid &amp;&gt;(s);
00060 
00061     <span class="keywordflow">for</span> (<a class="code" href="classGrid.html#Gridw1">Map_iter</a> i = cs.<a class="code" href="classGrid.html#Gridr1">_map_vars</a>.begin(); i != cs.<a class="code" href="classGrid.html#Gridr1">_map_vars</a>.end(); i++)
00062     {
00063     <a class="code" href="classBaseType.html">BaseType</a> *btp = (*i)-&gt;ptr_duplicate();
00064     btp-&gt;<a class="code" href="classBaseType.html#Vectora42">set_parent</a>(<span class="keyword">this</span>);
00065     _map_vars.push_back(btp);
00066     }
00067 }
00068 
<a name="l00078"></a><a class="code" href="classGrid.html#Grida0">00078</a> <a class="code" href="classGrid.html#Grida0">Grid::Grid</a>(<span class="keyword">const</span> string &amp;n) : <a class="code" href="classConstructor.html">Constructor</a>(n, <a class="code" href="BaseType_8h.html#a21a19">dods_grid_c</a>)
00079 {
00080 }
00081 
<a name="l00083"></a><a class="code" href="classGrid.html#Grida1">00083</a> <a class="code" href="classGrid.html#Grida0">Grid::Grid</a>(<span class="keyword">const</span> <a class="code" href="classGrid.html">Grid</a> &amp;rhs) : <a class="code" href="classConstructor.html">Constructor</a>(rhs)
00084 {
00085     <a class="code" href="classConstructor.html#Structureb0">_duplicate</a>(rhs);
00086 }
00087 
<a name="l00088"></a><a class="code" href="classGrid.html#Grida2">00088</a> <a class="code" href="classGrid.html#Grida2">Grid::~Grid</a>()
00089 {
00090     <span class="keyword">delete</span> _array_var; _array_var = 0;
00091 
00092     <span class="keywordflow">for</span> (<a class="code" href="classGrid.html#Gridw1">Map_iter</a> i = _map_vars.begin(); i != _map_vars.end(); i++)
00093     {
00094     <a class="code" href="classBaseType.html">BaseType</a> *btp = *i ;
00095     <span class="keyword">delete</span> btp ;
00096     }
00097 }
00098 
00099 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00100"></a><a class="code" href="classGrid.html#Grida4">00100</a> <a class="code" href="classGrid.html#Grida4">Grid::ptr_duplicate</a>()
00101 {
00102     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classGrid.html#Grida0">Grid</a>(*<span class="keyword">this</span>);
00103 }
00104 
00105 <a class="code" href="classGrid.html">Grid</a> &amp;
<a name="l00106"></a><a class="code" href="classGrid.html#Grida3">00106</a> <a class="code" href="classGrid.html#Grida3">Grid::operator=</a>(<span class="keyword">const</span> <a class="code" href="classGrid.html">Grid</a> &amp;rhs)
00107 {
00108     <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;rhs)
00109     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00110 
00111     <span class="keyword">delete</span> _array_var; _array_var = 0;
00112 
00113     <span class="keywordflow">for</span> (<a class="code" href="classGrid.html#Gridw1">Map_iter</a> i = _map_vars.begin(); i != _map_vars.end(); i++)
00114     {
00115     <a class="code" href="classBaseType.html">BaseType</a> *btp = *i ;
00116     <span class="keyword">delete</span> btp ;
00117     }
00118 
00119     dynamic_cast&lt;Constructor &amp;&gt;(*this) = rhs;
00120 
00121     <a class="code" href="classConstructor.html#Structureb0">_duplicate</a>(rhs);
00122 
00123     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00124 }
00125 
00126 <span class="keywordtype">int</span>
<a name="l00127"></a><a class="code" href="classGrid.html#Grida5">00127</a> <a class="code" href="classGrid.html#Grida5">Grid::element_count</a>(<span class="keywordtype">bool</span> leaves)
00128 {
00129     <span class="keywordflow">if</span> (!leaves)
00130     <span class="keywordflow">return</span> _map_vars.size() + 1;
00131     <span class="keywordflow">else</span> {
00132     <span class="keywordtype">int</span> i = 0;
00133     <span class="keywordflow">for</span> (<a class="code" href="classGrid.html#Gridw1">Map_iter</a> j = _map_vars.begin(); j != _map_vars.end(); j++)
00134     {
00135         j += (*j)-&gt;element_count(leaves);
00136     }
00137 
00138     i += <a class="code" href="classGrid.html#Grida12">array_var</a>()-&gt;<a class="code" href="classBaseType.html#Urla21">element_count</a>(leaves);
00139     <span class="keywordflow">return</span> i;
00140     }
00141 }
00142 
00143 <span class="keywordtype">void</span>
<a name="l00144"></a><a class="code" href="classGrid.html#Grida6">00144</a> <a class="code" href="classGrid.html#Grida6">Grid::set_send_p</a>(<span class="keywordtype">bool</span> state)
00145 {
00146     _array_var-&gt;<a class="code" href="classBaseType.html#Urla27">set_send_p</a>(state);
00147 
00148     <span class="keywordflow">for</span> (<a class="code" href="classGrid.html#Gridw1">Map_iter</a> i = _map_vars.begin(); i != _map_vars.end(); i++)
00149     {
00150     (*i)-&gt;set_send_p(state);
00151     }
00152 
00153     <a class="code" href="classBaseType.html#Urla27">BaseType::set_send_p</a>(state);
00154 }
00155 
00156 <span class="keywordtype">void</span>
<a name="l00157"></a><a class="code" href="classGrid.html#Grida7">00157</a> <a class="code" href="classGrid.html#Grida7">Grid::set_read_p</a>(<span class="keywordtype">bool</span> state)
00158 {
00159     _array_var-&gt;<a class="code" href="classBaseType.html#Urla25">set_read_p</a>(state);
00160 
00161     <span class="keywordflow">for</span> (<a class="code" href="classGrid.html#Gridw1">Map_iter</a> i = _map_vars.begin(); i != _map_vars.end(); i++)
00162     {
00163     (*i)-&gt;set_read_p(state);
00164     }
00165 
00166     <a class="code" href="classBaseType.html#Urla25">BaseType::set_read_p</a>(state);
00167 }
00168 
00169 <span class="keywordtype">void</span>
<a name="l00170"></a><a class="code" href="classGrid.html#Grida8">00170</a> <a class="code" href="classGrid.html#Grida8">Grid::set_in_selection</a>(<span class="keywordtype">bool</span> state)
00171 {
00172     _array_var-&gt;<a class="code" href="classBaseType.html#Vectora40">set_in_selection</a>(state);
00173 
00174     <span class="keywordflow">for</span> (<a class="code" href="classGrid.html#Gridw1">Map_iter</a> i = _map_vars.begin(); i != _map_vars.end(); i++) {
00175     (*i)-&gt;set_in_selection(state);
00176     }
00177 
00178     <a class="code" href="classBaseType.html#Vectora40">BaseType::set_in_selection</a>(state);
00179 }
00180 
00181 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00182"></a><a class="code" href="classGrid.html#Grida16">00182</a> <a class="code" href="classGrid.html#Grida16">Grid::width</a>()
00183 {
00184     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz = _array_var-&gt;<a class="code" href="classBaseType.html#Constructora30">width</a>();
00185   
00186     <span class="keywordflow">for</span> (<a class="code" href="classGrid.html#Gridw1">Map_iter</a> i = _map_vars.begin(); i != _map_vars.end(); i++)
00187     {
00188     sz += (*i)-&gt;width();
00189     }
00190   
00191     <span class="keywordflow">return</span> sz;
00192 }
00193 
00194 <span class="keywordtype">bool</span>
<a name="l00195"></a><a class="code" href="classGrid.html#Grida19">00195</a> <a class="code" href="classGrid.html#Grida19">Grid::serialize</a>(<span class="keyword">const</span> string &amp;dataset, <a class="code" href="classDDS.html">DDS</a> &amp;dds, XDR *sink, 
00196         <span class="keywordtype">bool</span> ce_eval)
00197 {
00198     dds.<a class="code" href="classDDS.html#DDSa18">timeout_on</a>();
00199 
00200     <span class="keywordflow">if</span> (!<a class="code" href="classBaseType.html#Vectora37">read_p</a>())
00201     <a class="code" href="classBaseType.html#Vectora45">read</a>(dataset);      <span class="comment">// read() throws Error and InternalErr</span>
00202 
00203     <span class="keywordflow">if</span> (ce_eval &amp;&amp; !dds.<a class="code" href="classDDS.html#DDSa31">eval_selection</a>(dataset))
00204     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00205 
00206     dds.<a class="code" href="classDDS.html#DDSa19">timeout_off</a>();
00207 
00208     <span class="keywordflow">if</span> (_array_var-&gt;<a class="code" href="classBaseType.html#Vectora38">send_p</a>())
00209     _array_var-&gt;<a class="code" href="classBaseType.html#Constructora34">serialize</a>(dataset, dds, sink, <span class="keyword">false</span>);
00210 
00211     <span class="keywordflow">for</span> (<a class="code" href="classGrid.html#Gridw1">Map_iter</a> i = _map_vars.begin(); i != _map_vars.end(); i++) {
00212     <span class="keywordflow">if</span> ((*i)-&gt;send_p()) {
00213         (*i)-&gt;serialize(dataset, dds, sink, <span class="keyword">false</span>);
00214     }
00215     }
00216 
00217     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00218 }
00219 
00220 <span class="keywordtype">bool</span>
<a name="l00221"></a><a class="code" href="classGrid.html#Grida20">00221</a> <a class="code" href="classGrid.html#Grida20">Grid::deserialize</a>(XDR *source, <a class="code" href="classDDS.html">DDS</a> *dds, <span class="keywordtype">bool</span> reuse)
00222 {
00223     _array_var-&gt;<a class="code" href="classBaseType.html#Constructora35">deserialize</a>(source, dds, reuse);
00224 
00225     <span class="keywordflow">for</span>(<a class="code" href="classGrid.html#Gridw1">Map_iter</a> i = _map_vars.begin(); i != _map_vars.end(); i++)
00226     {
00227     (*i)-&gt;deserialize(source, dds, reuse);
00228     }
00229 
00230     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00231 }
00232 
00240 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00241"></a><a class="code" href="classGrid.html#Grida21">00241</a> <a class="code" href="classGrid.html#Grida21">Grid::val2buf</a>(<span class="keywordtype">void</span> *, <span class="keywordtype">bool</span>)
00242 {
00243     <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(<a class="code" href="classGrid.html">Grid</a>);
00244 }
00245 
00249 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00250"></a><a class="code" href="classGrid.html#Grida22">00250</a> <a class="code" href="classGrid.html#Grida22">Grid::buf2val</a>(<span class="keywordtype">void</span> **)
00251 {
00252     <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(<a class="code" href="classGrid.html">Grid</a>);
00253 }
00254 
00255 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00256"></a><a class="code" href="classGrid.html#Grida10">00256</a> <a class="code" href="classGrid.html#Grida9">Grid::var</a>(<span class="keyword">const</span> string &amp;n, <a class="code" href="BaseType_8h.html#a1">btp_stack</a> &amp;s)
00257 {
00258     <span class="keywordflow">return</span> <a class="code" href="classGrid.html#Grida9">var</a>(n, <span class="keyword">true</span>, &amp;s);
00259 }
00260 
00265 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00266"></a><a class="code" href="classGrid.html#Grida9">00266</a> <a class="code" href="classGrid.html#Grida9">Grid::var</a>(<span class="keyword">const</span> string &amp;n, <span class="keywordtype">bool</span>, <a class="code" href="BaseType_8h.html#a1">btp_stack</a> *s)
00267 {
00268     string <a class="code" href="classBaseType.html#Vectora27">name</a> = <a class="code" href="escaping_8cc.html#a7">www2id</a>(n);
00269 
00270     <span class="keywordflow">if</span> (_array_var-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>() == name) {
00271     <span class="keywordflow">if</span> (s)
00272         s-&gt;push(static_cast&lt;BaseType *&gt;(<span class="keyword">this</span>));
00273     <span class="keywordflow">return</span> _array_var;
00274     }
00275 
00276     <span class="keywordflow">for</span> (<a class="code" href="classGrid.html#Gridw1">Map_iter</a> i = _map_vars.begin(); i != _map_vars.end(); i++)
00277     {
00278     <span class="keywordflow">if</span> ((*i)-&gt;name() == name)
00279     {
00280         <span class="keywordflow">if</span> (s)
00281         s-&gt;push(static_cast&lt;BaseType *&gt;(<span class="keyword">this</span>));
00282         <span class="keywordflow">return</span> *i;
00283     }
00284     }
00285 
00286     <span class="keywordflow">return</span> 0;
00287 }
00288 
00289 <span class="preprocessor">#if 0</span>
00290 <span class="preprocessor"></span>
00293 <a class="code" href="classBaseType.html">BaseType</a> *
00294 <a class="code" href="classGrid.html#Grida9">Grid::var</a>(<span class="keyword">const</span> string &amp;name, <span class="keywordtype">bool</span>)
00295 {
00296     <span class="keywordflow">if</span> (_array_var-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>() == name)
00297     <span class="keywordflow">return</span> _array_var;
00298 
00299     <span class="keywordflow">for</span> (Pix p = _map_vars.first(); p; _map_vars.next(p))
00300     <span class="keywordflow">if</span> (_map_vars(p)-&gt;name() == name)
00301         <span class="keywordflow">return</span> _map_vars(p);
00302 
00303     <span class="keywordflow">return</span> 0;
00304 }    
00305 <span class="preprocessor">#endif</span>
00306 <span class="preprocessor"></span>
00307 <span class="keywordtype">void</span> 
<a name="l00308"></a><a class="code" href="classGrid.html#Grida11">00308</a> <a class="code" href="classGrid.html#Grida11">Grid::add_var</a>(<a class="code" href="classBaseType.html">BaseType</a> *bt, Part part)
00309 {
00310     <span class="keywordflow">if</span>(!bt)
00311     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, 
00312               <span class="stringliteral">"Passing NULL pointer as variable to be added."</span>);
00313     
00314     <span class="comment">// Jose Garcia</span>
00315     <span class="comment">// Now we get a copy of the maps or of the array</span>
00316     <span class="comment">// so the owner of bt which is external to libdap++</span>
00317     <span class="comment">// is free to deallocate its object.</span>
00318     <span class="keywordflow">switch</span> (part) {
00319       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a20a3">array</a>:
00320     _array_var = bt-&gt;<a class="code" href="classBaseType.html#Constructora6">ptr_duplicate</a>();
00321     _array_var-&gt;<a class="code" href="classBaseType.html#Vectora42">set_parent</a>(<span class="keyword">this</span>);
00322     <span class="keywordflow">return</span>;
00323       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a20a4">maps</a>: {
00324     <a class="code" href="classBaseType.html">BaseType</a> *btp = bt-&gt;<a class="code" href="classBaseType.html#Constructora6">ptr_duplicate</a>();
00325     btp-&gt;<a class="code" href="classBaseType.html#Vectora42">set_parent</a>(<span class="keyword">this</span>);
00326     _map_vars.push_back(btp);
00327     <span class="keywordflow">return</span>;
00328       }
00329       <span class="keywordflow">default</span>:
00330     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, 
00331               <span class="stringliteral">"Unknown grid part (must be Array or Maps)."</span>);
00332     <span class="keywordflow">return</span>;
00333     }
00334 }    
00335 
00337 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00338"></a><a class="code" href="classGrid.html#Grida12">00338</a> <a class="code" href="classGrid.html#Grida12">Grid::array_var</a>()
00339 {
00340     <span class="keywordflow">return</span> _array_var;
00341 }
00342 
00344 Pix 
<a name="l00345"></a><a class="code" href="classGrid.html#Grida13">00345</a> <a class="code" href="classGrid.html#Grida13">Grid::first_map_var</a>()
00346 {
00347     <span class="keywordflow">if</span> (_map_vars.empty())
00348     <span class="keywordflow">return</span> 0;
00349 
00350     <a class="code" href="classBTIterAdapter.html">BTIterAdapter</a> *i = <span class="keyword">new</span> <a class="code" href="classBTIterAdapter.html">BTIterAdapter</a>( _map_vars ) ;
00351     i-&gt;<a class="code" href="classBTIterAdapter.html#BTIterAdapterz62_0">first</a>() ;
00352     <span class="keywordflow">return</span> i ;
00353 }
00354 
00355 <a class="code" href="classGrid.html#Gridw1">Grid::Map_iter</a>
<a name="l00356"></a><a class="code" href="classGrid.html#Grida28">00356</a> <a class="code" href="classGrid.html#Grida28">Grid::map_begin</a>()
00357 {
00358     <span class="keywordflow">return</span> _map_vars.begin() ;
00359 }
00360 
00361 <a class="code" href="classGrid.html#Gridw1">Grid::Map_iter</a>
<a name="l00362"></a><a class="code" href="classGrid.html#Grida29">00362</a> <a class="code" href="classGrid.html#Grida29">Grid::map_end</a>()
00363 {
00364     <span class="keywordflow">return</span> _map_vars.end() ;
00365 }
00366 
00370 <a class="code" href="classGrid.html#Gridw1">Grid::Map_iter</a>
<a name="l00371"></a><a class="code" href="classGrid.html#Grida30">00371</a> <a class="code" href="classGrid.html#Grida30">Grid::get_map_iter</a>(<span class="keywordtype">int</span> i)
00372 {
00373     <span class="keywordflow">return</span> _map_vars.begin() + i;
00374 }
00375 
00377 <span class="keywordtype">void</span> 
<a name="l00378"></a><a class="code" href="classGrid.html#Grida14">00378</a> <a class="code" href="classGrid.html#Grida14">Grid::next_map_var</a>(Pix p)
00379 {
00380     p.next() ;
00381 }
00382 
00384 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00385"></a><a class="code" href="classGrid.html#Grida15">00385</a> <a class="code" href="classGrid.html#Grida15">Grid::map_var</a>(Pix p)
00386 {
00387     <a class="code" href="classBTIterAdapter.html">BTIterAdapter</a> *i = (<a class="code" href="classBTIterAdapter.html">BTIterAdapter</a> *)p.getIterator() ;
00388     <span class="keywordflow">if</span>( !i )
00389     <span class="keywordflow">return</span> 0 ;
00390 
00391     <span class="keywordflow">return</span> i-&gt;<a class="code" href="classBTIterAdapter.html#BTIterAdapterz64_0">entry</a>() ;
00392 }
00393 
00409 <span class="keywordtype">int</span>
<a name="l00410"></a><a class="code" href="classGrid.html#Grida17">00410</a> <a class="code" href="classGrid.html#Grida17">Grid::components</a>(<span class="keywordtype">bool</span> constrained)
00411 {
00412     <span class="keywordtype">int</span> comp;
00413 
00414     <span class="keywordflow">if</span> (constrained)
00415     {
00416     comp = _array_var-&gt;<a class="code" href="classBaseType.html#Vectora38">send_p</a>() ? 1: 0;
00417 
00418     <span class="keywordflow">for</span> (<a class="code" href="classGrid.html#Gridw1">Map_iter</a> i = _map_vars.begin(); i != _map_vars.end(); i++)
00419     {
00420         <span class="keywordflow">if</span> ((*i)-&gt;send_p())
00421         {
00422         comp++;
00423         }
00424     }
00425     }
00426     <span class="keywordflow">else</span>
00427     {
00428     comp = 1 + _map_vars.size();
00429     }
00430 
00431     <span class="keywordflow">return</span> comp;
00432 }
00433 
00434 <span class="comment">// When projected (using whatever the current constraint provides in the way</span>
00435 <span class="comment">// of a projection), is the object still a Grid?</span>
00436 
00453 <span class="keywordtype">bool</span>
<a name="l00454"></a><a class="code" href="classGrid.html#Grida18">00454</a> <a class="code" href="classGrid.html#Grida18">Grid::projection_yields_grid</a>()
00455 {
00456     <span class="comment">// For each dimension in the Array part, check the corresponding Map</span>
00457     <span class="comment">// vector to make sure it is present in the projected Grid. If for each</span>
00458     <span class="comment">// projected dimension in the Array component, there is a matching Map</span>
00459     <span class="comment">// vector, then the Grid is valid.</span>
00460     <span class="keywordtype">bool</span> valid = <span class="keyword">true</span>;
00461     <a class="code" href="classArray.html">Array</a> *a = (<a class="code" href="classArray.html">Array</a> *)_array_var;
00462 
00463     <span class="comment">// Don't bother checking if the Array component is not included.</span>
00464     <span class="keywordflow">if</span> (!a-&gt;<a class="code" href="classBaseType.html#Vectora38">send_p</a>())
00465     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00466 
00467     <a class="code" href="classArray.html#Arrayw1">Array::Dim_iter</a> i = a-&gt;<a class="code" href="classArray.html#Arraya13">dim_begin</a>() ;
00468     <a class="code" href="classGrid.html#Gridw1">Map_iter</a> m = <a class="code" href="classGrid.html#Grida28">map_begin</a>() ;
00469     <span class="keywordflow">for</span>( ; valid &amp;&amp; i != a-&gt;<a class="code" href="classArray.html#Arraya14">dim_end</a>() &amp;&amp; m != <a class="code" href="classGrid.html#Grida29">map_end</a>(); i++, m++)
00470     {
00471     <span class="keywordflow">if</span> (a-&gt;<a class="code" href="classArray.html#Arraya15">dimension_size</a>(i, <span class="keyword">true</span>)) {
00472         <span class="comment">// Check the matching Map vector; the Map projection must equal</span>
00473         <span class="comment">// the Array dimension projection</span>
00474         <a class="code" href="classArray.html">Array</a> *map = (<a class="code" href="classArray.html">Array</a> *)(*m);
00475         <a class="code" href="classArray.html#Arrayw1">Array::Dim_iter</a> fd = map-&gt;<a class="code" href="classArray.html#Arraya13">dim_begin</a>(); <span class="comment">// Maps have only one dim!</span>
00476         valid = map-&gt;<a class="code" href="classArray.html#Arraya17">dimension_start</a>(fd, <span class="keyword">true</span>) 
00477             == a-&gt;<a class="code" href="classArray.html#Arraya17">dimension_start</a>(i, <span class="keyword">true</span>)
00478         &amp;&amp; map-&gt;<a class="code" href="classArray.html#Arraya19">dimension_stop</a>(fd, <span class="keyword">true</span>) 
00479                    == a-&gt;<a class="code" href="classArray.html#Arraya19">dimension_stop</a>(i, <span class="keyword">true</span>)
00480         &amp;&amp; map-&gt;<a class="code" href="classArray.html#Arraya21">dimension_stride</a>(fd, <span class="keyword">true</span>) 
00481                    == a-&gt;<a class="code" href="classArray.html#Arraya21">dimension_stride</a>(i, <span class="keyword">true</span>);
00482     }
00483     <span class="keywordflow">else</span> {
00484         <span class="comment">// Corresponding Map vector must be excluded from the projection.</span>
00485         <a class="code" href="classArray.html">Array</a> *map = (<a class="code" href="classArray.html">Array</a> *)(*m);
00486         valid = !map-&gt;<a class="code" href="classBaseType.html#Vectora38">send_p</a>();
00487     }
00488     }
00489 
00490     <span class="keywordflow">return</span> valid;
00491 }
00492 
00505 <span class="keywordtype">void</span> 
<a name="l00506"></a><a class="code" href="classGrid.html#Grida23">00506</a> <a class="code" href="classGrid.html#Grida23">Grid::print_decl</a>(ostream &amp;os, string space, <span class="keywordtype">bool</span> print_semi,
00507          <span class="keywordtype">bool</span> constraint_info, <span class="keywordtype">bool</span> constrained)
00508 {
00509     <span class="keywordflow">if</span> (constrained &amp;&amp; !<a class="code" href="classBaseType.html#Vectora38">send_p</a>())
00510     <span class="keywordflow">return</span>;
00511 
00512     <span class="comment">// If we are printing the declaration of a constrained Grid then check for</span>
00513     <span class="comment">// the case where the projection removes all but one component; the</span>
00514     <span class="comment">// resulting object is a simple array.</span>
00515     <span class="keywordtype">int</span> projection = <a class="code" href="classGrid.html#Grida17">components</a>(<span class="keyword">true</span>);
00516     <span class="keywordflow">if</span> (constrained &amp;&amp; projection == 1) {
00517     _array_var-&gt;<a class="code" href="classBaseType.html#Urla38">print_decl</a>(os, space, <span class="keyword">true</span>, constraint_info,
00518                    constrained);
00519     <span class="keywordflow">for</span> (<a class="code" href="classGrid.html#Gridw1">Map_iter</a> i = _map_vars.begin(); i != _map_vars.end(); i++)
00520     {
00521         (*i)-&gt;print_decl(os, space, <span class="keyword">true</span>, constraint_info, constrained);
00522     }
00523     <span class="keywordflow">goto</span> exit;      <span class="comment">// Skip end material.</span>
00524     }
00525     <span class="comment">// If there are M (&lt; N) componets (Array and Maps combined) in a N</span>
00526     <span class="comment">// component Grid, send the M components as elements of a Struture.</span>
00527     <span class="comment">// This will preserve the grouping without violating the rules for a</span>
00528     <span class="comment">// Grid. </span>
00529     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (constrained &amp;&amp; !<a class="code" href="classGrid.html#Grida18">projection_yields_grid</a>()) {
00530     os &lt;&lt; space &lt;&lt; <span class="stringliteral">"Structure {"</span> &lt;&lt; endl;
00531 
00532     _array_var-&gt;<a class="code" href="classBaseType.html#Urla38">print_decl</a>(os, space + <span class="stringliteral">"    "</span>, <span class="keyword">true</span>, constraint_info,
00533                    constrained);
00534 
00535     <span class="keywordflow">for</span> (<a class="code" href="classGrid.html#Gridw1">Map_iter</a> i = _map_vars.begin(); i != _map_vars.end(); i++)
00536     {
00537         (*i)-&gt;print_decl(os, space + <span class="stringliteral">"    "</span>, <span class="keyword">true</span>,
00538                  constraint_info, constrained);
00539     }
00540 
00541     os &lt;&lt; space &lt;&lt; <span class="stringliteral">"} "</span> &lt;&lt; <a class="code" href="escaping_8cc.html#a5">id2www</a>(<a class="code" href="classBaseType.html#Vectora27">name</a>());
00542     }
00543     <span class="keywordflow">else</span> {
00544     <span class="comment">// The number of elements in the (projected) Grid must be such that</span>
00545     <span class="comment">// we have a valid Grid object; send it as such.</span>
00546     os &lt;&lt; space &lt;&lt; <a class="code" href="classBaseType.html#Vectora31">type_name</a>() &lt;&lt; <span class="stringliteral">" {"</span> &lt;&lt; endl;
00547 
00548     os &lt;&lt; space &lt;&lt; <span class="stringliteral">" ARRAY:"</span> &lt;&lt; endl;
00549     _array_var-&gt;<a class="code" href="classBaseType.html#Urla38">print_decl</a>(os, space + <span class="stringliteral">"    "</span>, <span class="keyword">true</span>, constraint_info,
00550                    constrained);
00551 
00552     os &lt;&lt; space &lt;&lt; <span class="stringliteral">" MAPS:"</span> &lt;&lt; endl;
00553     <span class="keywordflow">for</span> (<a class="code" href="classGrid.html#Gridw1">Map_iter</a> i = _map_vars.begin(); i != _map_vars.end(); i++)
00554     {
00555         (*i)-&gt;print_decl(os, space + <span class="stringliteral">"    "</span>, <span class="keyword">true</span>,
00556                  constraint_info, constrained);
00557     }
00558 
00559     os &lt;&lt; space &lt;&lt; <span class="stringliteral">"} "</span> &lt;&lt; <a class="code" href="escaping_8cc.html#a5">id2www</a>(<a class="code" href="classBaseType.html#Vectora27">name</a>());
00560     }
00561 
00562     <span class="keywordflow">if</span> (constraint_info) {
00563     <span class="keywordflow">if</span> (<a class="code" href="classBaseType.html#Vectora38">send_p</a>())
00564         cout &lt;&lt; <span class="stringliteral">": Send True"</span>;
00565     <span class="keywordflow">else</span>
00566         cout &lt;&lt; <span class="stringliteral">": Send False"</span>;
00567     }
00568 
00569     <span class="keywordflow">if</span> (print_semi)
00570     os &lt;&lt; <span class="stringliteral">";"</span> &lt;&lt; endl;
00571 
00572     <span class="comment">// If sending just one comp, skip sending the terminal semicolon, etc.</span>
00573 exit:
00574     <span class="keywordflow">return</span>;
00575 }
00576 
00577 <span class="keywordtype">void</span> 
<a name="l00578"></a><a class="code" href="classGrid.html#Grida24">00578</a> <a class="code" href="classGrid.html#Grida23">Grid::print_decl</a>(FILE *out, string space, <span class="keywordtype">bool</span> print_semi,
00579          <span class="keywordtype">bool</span> constraint_info, <span class="keywordtype">bool</span> constrained)
00580 {
00581     <span class="keywordflow">if</span> (constrained &amp;&amp; !<a class="code" href="classBaseType.html#Vectora38">send_p</a>())
00582     <span class="keywordflow">return</span>;
00583 
00584     <span class="comment">// If we are printing the declaration of a constrained Grid then check for</span>
00585     <span class="comment">// the case where the projection removes all but one component; the</span>
00586     <span class="comment">// resulting object is a simple array.</span>
00587     <span class="keywordtype">int</span> projection = <a class="code" href="classGrid.html#Grida17">components</a>(<span class="keyword">true</span>);
00588     <span class="keywordflow">if</span> (constrained &amp;&amp; projection == 1) {
00589     _array_var-&gt;<a class="code" href="classBaseType.html#Urla38">print_decl</a>(out, space, <span class="keyword">true</span>, constraint_info,
00590                    constrained);
00591     <span class="keywordflow">for</span> (<a class="code" href="classGrid.html#Gridw0">Map_citer</a> i = _map_vars.begin(); i != _map_vars.end(); i++)
00592     {
00593         (*i)-&gt;print_decl(out, space, <span class="keyword">true</span>, constraint_info, constrained);
00594     }
00595     <span class="keywordflow">goto</span> exit;      <span class="comment">// Skip end material.</span>
00596     }
00597     <span class="comment">// If there are M (&lt; N) componets (Array and Maps combined) in a N</span>
00598     <span class="comment">// component Grid, send the M components as elements of a Struture.</span>
00599     <span class="comment">// This will preserve the grouping without violating the rules for a</span>
00600     <span class="comment">// Grid. </span>
00601     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (constrained &amp;&amp; !<a class="code" href="classGrid.html#Grida18">projection_yields_grid</a>()) {
00602     fprintf( out, <span class="stringliteral">"%sStructure {\n"</span>, space.c_str() ) ;
00603 
00604     _array_var-&gt;<a class="code" href="classBaseType.html#Urla38">print_decl</a>(out, space + <span class="stringliteral">"    "</span>, <span class="keyword">true</span>, constraint_info,
00605                    constrained);
00606 
00607     <span class="keywordflow">for</span> (<a class="code" href="classGrid.html#Gridw0">Map_citer</a> i = _map_vars.begin(); i != _map_vars.end(); i++)
00608     {
00609         (*i)-&gt;print_decl(out, space + <span class="stringliteral">"    "</span>, <span class="keyword">true</span>,
00610                  constraint_info, constrained);
00611     }
00612 
00613     fprintf( out, <span class="stringliteral">"%s} %s"</span>, space.c_str(), <a class="code" href="escaping_8cc.html#a5">id2www</a>( <a class="code" href="classBaseType.html#Vectora27">name</a>() ).c_str() ) ;
00614     }
00615     <span class="keywordflow">else</span> {
00616     <span class="comment">// The number of elements in the (projected) Grid must be such that</span>
00617     <span class="comment">// we have a valid Grid object; send it as such.</span>
00618     fprintf( out, <span class="stringliteral">"%s%s {\n"</span>, space.c_str(), <a class="code" href="classBaseType.html#Vectora31">type_name</a>().c_str() ) ;
00619 
00620     fprintf( out, <span class="stringliteral">"%s ARRAY:\n"</span>, space.c_str() ) ;
00621     _array_var-&gt;<a class="code" href="classBaseType.html#Urla38">print_decl</a>(out, space + <span class="stringliteral">"    "</span>, <span class="keyword">true</span>, constraint_info,
00622                    constrained);
00623 
00624     fprintf( out, <span class="stringliteral">"%s MAPS:\n"</span>, space.c_str() ) ;
00625     <span class="keywordflow">for</span> (<a class="code" href="classGrid.html#Gridw0">Map_citer</a> i = _map_vars.begin(); i != _map_vars.end(); i++)
00626     {
00627         (*i)-&gt;print_decl(out, space + <span class="stringliteral">"    "</span>, <span class="keyword">true</span>,
00628                  constraint_info, constrained);
00629     }
00630 
00631     fprintf( out, <span class="stringliteral">"%s} %s"</span>, space.c_str(), <a class="code" href="escaping_8cc.html#a5">id2www</a>( <a class="code" href="classBaseType.html#Vectora27">name</a>() ).c_str() ) ;
00632     }
00633 
00634     <span class="keywordflow">if</span> (constraint_info) {
00635     <span class="keywordflow">if</span> (<a class="code" href="classBaseType.html#Vectora38">send_p</a>())
00636         cout &lt;&lt; <span class="stringliteral">": Send True"</span>;
00637     <span class="keywordflow">else</span>
00638         cout &lt;&lt; <span class="stringliteral">": Send False"</span>;
00639     }
00640 
00641     <span class="keywordflow">if</span> (print_semi)
00642     fprintf( out, <span class="stringliteral">";\n"</span> ) ;
00643 
00644     <span class="comment">// If sending just one comp, skip sending the terminal semicolon, etc.</span>
00645 exit:
00646     <span class="keywordflow">return</span>;
00647 }
00648 
00649 <span class="keywordtype">void</span> 
<a name="l00650"></a><a class="code" href="classGrid.html#Grida25">00650</a> <a class="code" href="classGrid.html#Grida25">Grid::print_val</a>(ostream &amp;os, string space, <span class="keywordtype">bool</span> print_decl_p)
00651 {
00652     <span class="keywordflow">if</span> (print_decl_p) {
00653     <a class="code" href="classGrid.html#Grida23">print_decl</a>(os, space, <span class="keyword">false</span>);
00654     os &lt;&lt; <span class="stringliteral">" = "</span>;
00655     }
00656 
00657     <span class="comment">// If we are printing a value on the client-side, projection_yields_grid</span>
00658     <span class="comment">// should not be called since we don't *have* a projection without a</span>
00659     <span class="comment">// contraint. I think that if we are here and send_p() is not true, then</span>
00660     <span class="comment">// the value of this function should be ignored. 4/6/2000 jhrg</span>
00661     <span class="keywordtype">bool</span> pyg = <a class="code" href="classGrid.html#Grida18">projection_yields_grid</a>(); <span class="comment">// hack 12/1/99 jhrg</span>
00662     <span class="keywordflow">if</span> (pyg || !<a class="code" href="classBaseType.html#Vectora38">send_p</a>())
00663     os &lt;&lt; <span class="stringliteral">"{ ARRAY: "</span>;
00664     <span class="keywordflow">else</span>
00665     os &lt;&lt; <span class="stringliteral">"{"</span>;
00666     _array_var-&gt;<a class="code" href="classBaseType.html#Constructora39">print_val</a>(os, <span class="stringliteral">""</span>, <span class="keyword">false</span>);
00667     <span class="keywordflow">if</span> (pyg || !<a class="code" href="classBaseType.html#Vectora38">send_p</a>())
00668     os &lt;&lt; <span class="stringliteral">" MAPS: "</span>;
00669     <span class="keywordflow">for</span> (<a class="code" href="classGrid.html#Gridw1">Map_iter</a> i = _map_vars.begin(); i != _map_vars.end(); 
00670      i++, (<span class="keywordtype">void</span>)(i != _map_vars.end() &amp;&amp; os &lt;&lt; <span class="stringliteral">", "</span>))
00671     {
00672     (*i)-&gt;print_val(os, <span class="stringliteral">""</span>, <span class="keyword">false</span>);
00673     }
00674     os &lt;&lt; <span class="stringliteral">" }"</span>;
00675 
00676     <span class="keywordflow">if</span> (print_decl_p)
00677     os &lt;&lt; <span class="stringliteral">";"</span> &lt;&lt; endl;
00678 }
00679 
00680 <span class="keywordtype">void</span> 
<a name="l00681"></a><a class="code" href="classGrid.html#Grida26">00681</a> <a class="code" href="classGrid.html#Grida25">Grid::print_val</a>(FILE *out, string space, <span class="keywordtype">bool</span> print_decl_p)
00682 {
00683     <span class="keywordflow">if</span> (print_decl_p) {
00684     <a class="code" href="classGrid.html#Grida23">print_decl</a>(out, space, <span class="keyword">false</span>);
00685     fprintf( out, <span class="stringliteral">" = "</span> ) ;
00686     }
00687 
00688     <span class="comment">// If we are printing a value on the client-side, projection_yields_grid</span>
00689     <span class="comment">// should not be called since we don't *have* a projection without a</span>
00690     <span class="comment">// contraint. I think that if we are here and send_p() is not true, then</span>
00691     <span class="comment">// the value of this function should be ignored. 4/6/2000 jhrg</span>
00692     <span class="keywordtype">bool</span> pyg = <a class="code" href="classGrid.html#Grida18">projection_yields_grid</a>(); <span class="comment">// hack 12/1/99 jhrg</span>
00693     <span class="keywordflow">if</span> (pyg || !<a class="code" href="classBaseType.html#Vectora38">send_p</a>())
00694     fprintf( out, <span class="stringliteral">"{ ARRAY: "</span> ) ;
00695     <span class="keywordflow">else</span>
00696     fprintf( out, <span class="stringliteral">"{"</span> ) ;
00697     _array_var-&gt;<a class="code" href="classBaseType.html#Constructora39">print_val</a>(out, <span class="stringliteral">""</span>, <span class="keyword">false</span>);
00698     <span class="keywordflow">if</span> (pyg || !<a class="code" href="classBaseType.html#Vectora38">send_p</a>())
00699     fprintf( out, <span class="stringliteral">" MAPS: "</span> ) ;
00700     <span class="keywordflow">for</span>( <a class="code" href="classGrid.html#Gridw0">Map_citer</a> i = _map_vars.begin(); i != _map_vars.end(); 
00701      i++, (<span class="keywordtype">void</span>)(i != _map_vars.end() &amp;&amp; fprintf( out, <span class="stringliteral">", "</span> ) ) )
00702     {
00703     (*i)-&gt;print_val(out, <span class="stringliteral">""</span>, <span class="keyword">false</span>);
00704     }
00705     fprintf( out, <span class="stringliteral">" }"</span> ) ;
00706 
00707     <span class="keywordflow">if</span> (print_decl_p)
00708     fprintf( out, <span class="stringliteral">";\n"</span> ) ;
00709 }
00710 
00711 <span class="comment">// Grids have ugly semantics.</span>
00712 
00717 <span class="keywordtype">bool</span>
<a name="l00718"></a><a class="code" href="classGrid.html#Grida27">00718</a> <a class="code" href="classGrid.html#Grida27">Grid::check_semantics</a>(string &amp;msg, <span class="keywordtype">bool</span> all)
00719 {
00720     <span class="keywordflow">if</span> (!<a class="code" href="classBaseType.html#Urla40">BaseType::check_semantics</a>(msg))
00721     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00722 
00723     <span class="keywordflow">if</span> (!<a class="code" href="util_8cc.html#a3">unique_names</a>(_map_vars, <a class="code" href="classBaseType.html#Vectora27">name</a>(), <a class="code" href="classBaseType.html#Vectora31">type_name</a>(), msg))
00724     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00725     msg=<span class="stringliteral">""</span>;
00726 
00727     <span class="keywordflow">if</span> (!_array_var) {
00728         msg+=<span class="stringliteral">"Null grid base array in `"</span>+<a class="code" href="classBaseType.html#Vectora27">name</a>()+<span class="stringliteral">"'\n"</span>;
00729     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00730     }
00731     
00732     <span class="comment">// Is it an array?</span>
00733     <span class="keywordflow">if</span> (_array_var-&gt;<a class="code" href="classBaseType.html#Vectora29">type</a>() != <a class="code" href="BaseType_8h.html#a21a15">dods_array_c</a>) {
00734     msg+= <span class="stringliteral">"Grid `"</span>+ <a class="code" href="classBaseType.html#Vectora27">name</a>()+<span class="stringliteral">"'s' member `"</span>+ _array_var-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>()+<span class="stringliteral">"' must be an array\n"</span>;
00735     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00736     }
00737         
00738     <a class="code" href="classArray.html">Array</a> *av = (<a class="code" href="classArray.html">Array</a> *)_array_var; <span class="comment">// past test above, must be an array</span>
00739 
00740     <span class="comment">// Array must be of a simple_type.</span>
00741     <span class="keywordflow">if</span> (!av-&gt;<a class="code" href="classVector.html#Vectora17">var</a>()-&gt;<a class="code" href="classBaseType.html#Vectora32">is_simple_type</a>()) {
00742         msg+=<span class="stringliteral">"The field variable `"</span>+this-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>()+<span class="stringliteral">"' must be an array of simple type elements (e.g., int32, String)\n"</span>;
00743     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00744     }
00745 
00746     <span class="comment">// enough maps?</span>
00747     <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span>)_map_vars.size() != av-&gt;<a class="code" href="classArray.html#Arraya25">dimensions</a>()) {
00748         msg+=<span class="stringliteral">"The number of map variables for grid `"</span>+this-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>()+ <span class="stringliteral">"' does not match the number of dimensions of `"</span>;
00749     msg+=av-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>()+ <span class="stringliteral">"'\n"</span>;
00750     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00751     }
00752 
00753     <span class="keyword">const</span> string array_var_name = av-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>();
00754     <a class="code" href="classArray.html#Arrayw1">Array::Dim_iter</a> asi = av-&gt;<a class="code" href="classArray.html#Arraya13">dim_begin</a>() ;
00755     <span class="keywordflow">for</span> (<a class="code" href="classGrid.html#Gridw1">Map_iter</a> mvi = _map_vars.begin();
00756      mvi != _map_vars.end(); mvi++, asi++)
00757     {
00758 
00759     <a class="code" href="classBaseType.html">BaseType</a> *mv = *mvi;
00760 
00761     <span class="comment">// check names</span>
00762     <span class="keywordflow">if</span> (array_var_name == mv-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>()) {
00763         msg+= <span class="stringliteral">"Grid map variable `"</span> + mv-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>()+<span class="stringliteral">"' conflicts with the grid array name in grid `"</span>+ <a class="code" href="classBaseType.html#Vectora27">name</a>()+<span class="stringliteral">"'\n"</span>;
00764         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00765     }
00766     <span class="comment">// check types</span>
00767     <span class="keywordflow">if</span> (mv-&gt;<a class="code" href="classBaseType.html#Vectora29">type</a>() != <a class="code" href="BaseType_8h.html#a21a15">dods_array_c</a>) {
00768         msg+= <span class="stringliteral">"Grid map variable  `"</span>+ mv-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>()+ <span class="stringliteral">"' is not an array\n"</span>;
00769         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00770     }
00771 
00772     <a class="code" href="classArray.html">Array</a> *mv_a = (<a class="code" href="classArray.html">Array</a> *)mv; <span class="comment">// downcast to (Array *)</span>
00773 
00774     <span class="comment">// Array must be of a simple_type.</span>
00775     <span class="keywordflow">if</span> (!mv_a-&gt;<a class="code" href="classVector.html#Vectora17">var</a>()-&gt;<a class="code" href="classBaseType.html#Vectora32">is_simple_type</a>()) {
00776         msg+= <span class="stringliteral">"The field variable `"</span>+ this-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>()+ <span class="stringliteral">"' must be an array of simple type elements (e.g., int32, String)\n"</span>;
00777         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00778     }
00779 
00780     <span class="comment">// check shape</span>
00781     <span class="keywordflow">if</span> (mv_a-&gt;<a class="code" href="classArray.html#Arraya25">dimensions</a>() != 1) {<span class="comment">// maps must have one dimension</span>
00782         msg+=<span class="stringliteral">"Grid map variable  `"</span>+mv_a-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>()+<span class="stringliteral">"' must be only one dimension\n"</span>;
00783         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00784     }
00785     <span class="comment">// size of map must match corresponding array dimension</span>
00786     <a class="code" href="classArray.html#Arrayw1">Array::Dim_iter</a> mv_asi = mv_a-&gt;<a class="code" href="classArray.html#Arraya13">dim_begin</a>() ;
00787     <span class="keywordtype">int</span> mv_a_size = mv_a-&gt;<a class="code" href="classArray.html#Arraya15">dimension_size</a>(mv_asi) ;
00788     <span class="keywordtype">int</span> av_size = av-&gt;<a class="code" href="classArray.html#Arraya15">dimension_size</a>(asi) ;
00789     <span class="keywordflow">if</span> (mv_a_size != av_size)
00790     {
00791         msg+=<span class="stringliteral">"Grid map variable  `"</span> +mv_a-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>()+<span class="stringliteral">"'s' size does not match the size of array variable '"</span>;
00792         msg+=_array_var-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>()+<span class="stringliteral">"'s' cooresponding dimension\n"</span>;
00793         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00794     }
00795     }
00796 
00797     <span class="keywordflow">if</span> (all) {
00798     <span class="keywordflow">if</span> (!_array_var-&gt;<a class="code" href="classBaseType.html#Urla40">check_semantics</a>(msg, <span class="keyword">true</span>))
00799         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00800     <span class="keywordflow">for</span> (<a class="code" href="classGrid.html#Gridw1">Map_iter</a> mvi = _map_vars.begin(); mvi != _map_vars.end(); mvi++)
00801     {
00802         <span class="keywordflow">if</span> (!(*mvi)-&gt;check_semantics(msg, <span class="keyword">true</span>))
00803         {
00804         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00805         }
00806     }
00807     }
00808 
00809     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00810 }
00811 
00812 <span class="comment">// $Log: Grid_8cc-source.html,v $
00812 <span class="comment">// Revision 1.4  2004/02/05 06:51:16  jimg
00812 <span class="comment">// Added/update.
00812 <span class="comment">//</span>
00813 <span class="comment">// Revision 1.57.2.3  2003/09/06 22:33:14  jimg</span>
00814 <span class="comment">// Added is_in_selection() method.</span>
00815 <span class="comment">//</span>
00816 <span class="comment">// Revision 1.57.2.2  2003/07/25 06:04:28  jimg</span>
00817 <span class="comment">// Refactored the code so that DDS:send() is now incorporated into</span>
00818 <span class="comment">// DODSFilter::send_data(). The old DDS::send() is still there but is</span>
00819 <span class="comment">// depracated.</span>
00820 <span class="comment">// Added 'smart timeouts' to all the variable classes. This means that</span>
00821 <span class="comment">// the new server timeouts are active only for the data read and CE</span>
00822 <span class="comment">// evaluation. This went inthe BaseType::serialize() methods because it</span>
00823 <span class="comment">// needed to time both the read() calls and the dds::eval() calls.</span>
00824 <span class="comment">//</span>
00825 <span class="comment">// Revision 1.57.2.1  2003/06/05 20:15:26  jimg</span>
00826 <span class="comment">// Removed many uses of strstream and replaced them with stringstream.</span>
00827 <span class="comment">//</span>
00828 <span class="comment">// Revision 1.57  2003/04/22 19:40:27  jimg</span>
00829 <span class="comment">// Merged with 3.3.1.</span>
00830 <span class="comment">//</span>
00831 <span class="comment">// Revision 1.55.2.2  2003/04/15 01:17:12  jimg</span>
00832 <span class="comment">// Added a method to get the iterator for a variable (or map) given its</span>
00833 <span class="comment">// index. To get the iterator for the ith variable/map, call</span>
00834 <span class="comment">// get_vars_iter(i).</span>
00835 <span class="comment">//</span>
00836 <span class="comment">// Revision 1.56  2003/02/21 00:14:24  jimg</span>
00837 <span class="comment">// Repaired copyright.</span>
00838 <span class="comment">//</span>
00839 <span class="comment">// Revision 1.55.2.1  2003/02/21 00:10:07  jimg</span>
00840 <span class="comment">// Repaired copyright.</span>
00841 <span class="comment">//</span>
00842 <span class="comment">// Revision 1.55  2003/01/23 00:22:24  jimg</span>
00843 <span class="comment">// Updated the copyright notice; this implementation of the DAP is</span>
00844 <span class="comment">// copyrighted by OPeNDAP, Inc.</span>
00845 <span class="comment">//</span>
00846 <span class="comment">// Revision 1.54  2003/01/15 19:24:39  pwest</span>
00847 <span class="comment">// Removing IteratorAdapterT and replacing with non-templated versions.</span>
00848 <span class="comment">//</span>
00849 <span class="comment">// Revision 1.53  2003/01/10 19:46:40  jimg</span>
00850 <span class="comment">// Merged with code tagged release-3-2-10 on the release-3-2 branch. In many</span>
00851 <span class="comment">// cases files were added on that branch (so they appear on the trunk for</span>
00852 <span class="comment">// the first time).</span>
00853 <span class="comment">//</span>
00854 <span class="comment">// Revision 1.46.4.15  2002/12/31 16:43:20  rmorris</span>
00855 <span class="comment">// Patches to handle some of the fancier template code under VC++ 6.0.</span>
00856 <span class="comment">//</span>
00857 <span class="comment">// Revision 1.46.4.14  2002/12/27 19:34:42  jimg</span>
00858 <span class="comment">// Modified the var() methods so that www2id() is called before looking</span>
00859 <span class="comment">// up identifier names. See bug 563.</span>
00860 <span class="comment">//</span>
00861 <span class="comment">// Revision 1.46.4.13  2002/12/17 22:35:03  pwest</span>
00862 <span class="comment">// Added and updated methods using stdio. Deprecated methods using iostream.</span>
00863 <span class="comment">//</span>
00864 <span class="comment">// Revision 1.46.4.12  2002/10/28 21:17:44  pwest</span>
00865 <span class="comment">// Converted all return values and method parameters to use non-const iterator.</span>
00866 <span class="comment">// Added operator== and operator!= methods to IteratorAdapter to handle Pix</span>
00867 <span class="comment">// problems.</span>
00868 <span class="comment">//</span>
00869 <span class="comment">// Revision 1.46.4.11  2002/09/22 14:31:08  rmorris</span>
00870 <span class="comment">// VC++ doesn't consider x in 'for(int x,...)' to be only for the block</span>
00871 <span class="comment">// associated with the loop.  Multiple of these therefore case a error</span>
00872 <span class="comment">// because VC++ sees multiple definitions.  Changed to use different vars names</span>
00873 <span class="comment">// in each such block.</span>
00874 <span class="comment">//</span>
00875 <span class="comment">// Revision 1.46.4.10  2002/09/12 22:49:57  pwest</span>
00876 <span class="comment">// Corrected signature changes made with Pix to IteratorAdapter changes. Rather</span>
00877 <span class="comment">// than taking a reference to a Pix, taking a Pix value.</span>
00878 <span class="comment">//</span>
00879 <span class="comment">// Revision 1.46.4.9  2002/09/05 22:52:54  pwest</span>
00880 <span class="comment">// Replaced the GNU data structures SLList and DLList with the STL container</span>
00881 <span class="comment">// class vector&lt;&gt;. To maintain use of Pix, changed the Pix.h header file to</span>
00882 <span class="comment">// redefine Pix to be an IteratorAdapter. Usage remains the same and all code</span>
00883 <span class="comment">// outside of the DAP should compile and link with no problems. Added methods</span>
00884 <span class="comment">// to the different classes where Pix is used to include methods to use STL</span>
00885 <span class="comment">// iterators. Replaced the use of Pix within the DAP to use iterators instead.</span>
00886 <span class="comment">// Updated comments for documentation, updated the test suites, and added some</span>
00887 <span class="comment">// unit tests. Updated the Makefile to remove GNU/SLList and GNU/DLList.</span>
00888 <span class="comment">//</span>
00889 <span class="comment">// Revision 1.46.4.8  2002/08/08 06:54:57  jimg</span>
00890 <span class="comment">// Changes for thread-safety. In many cases I found ugly places at the</span>
00891 <span class="comment">// tops of files while looking for globals, et c., and I fixed them up</span>
00892 <span class="comment">// (hopefully making them easier to read, ...). Only the files RCReader.cc</span>
00893 <span class="comment">// and usage.cc actually use pthreads synchronization functions. In other</span>
00894 <span class="comment">// cases I removed static objects where they were used for supposed</span>
00895 <span class="comment">// improvements in efficiency which had never actually been verifiied (and</span>
00896 <span class="comment">// which looked dubious).</span>
00897 <span class="comment">//</span>
00898 <span class="comment">// Revision 1.52  2002/06/18 15:36:24  tom</span>
00899 <span class="comment">// Moved comments and edited to accommodate doxygen documentation-generator.</span>
00900 <span class="comment">//</span>
00901 <span class="comment">// Revision 1.51  2002/06/03 22:21:15  jimg</span>
00902 <span class="comment">// Merged with release-3-2-9</span>
00903 <span class="comment">//</span>
00904 <span class="comment">// Revision 1.46.4.7  2002/05/22 16:57:51  jimg</span>
00905 <span class="comment">// I modified the `data type classes' so that they do not need to be</span>
00906 <span class="comment">// subclassed for clients. It might be the case that, for a complex client,</span>
00907 <span class="comment">// subclassing is still the best way to go, but you're not required to do</span>
00908 <span class="comment">// it anymore.</span>
00909 <span class="comment">//</span>
00910 <span class="comment">// Revision 1.46.4.6  2002/03/01 21:03:08  jimg</span>
00911 <span class="comment">// Significant changes to the var(...) methods. These now take a btp_stack</span>
00912 <span class="comment">// pointer and are used by DDS::mark(...). The exact_match methods have also</span>
00913 <span class="comment">// been updated so that leaf variables which contain dots in their names</span>
00914 <span class="comment">// will be found. Note that constructor variables with dots in their names</span>
00915 <span class="comment">// will break the lookup routines unless the ctor is the last field in the</span>
00916 <span class="comment">// constraint expression. These changes were made to fix bug 330.</span>
00917 <span class="comment">//</span>
00918 <span class="comment">// Revision 1.46.4.5  2001/10/30 06:55:45  rmorris</span>
00919 <span class="comment">// Win32 porting changes.  Brings core win32 port up-to-date.</span>
00920 <span class="comment">//</span>
00921 <span class="comment">// Revision 1.50  2001/10/14 01:28:38  jimg</span>
00922 <span class="comment">// Merged with release-3-2-8.</span>
00923 <span class="comment">//</span>
00924 <span class="comment">// Revision 1.46.4.4  2001/10/02 17:01:52  jimg</span>
00925 <span class="comment">// Made the behavior of serialize and deserialize uniform. Both methods now</span>
00926 <span class="comment">// use Error exceptions to signal problems with network I/O and InternalErr</span>
00927 <span class="comment">// exceptions to signal other problems. The return codes, always true for</span>
00928 <span class="comment">// serialize and always false for deserialize, are now meaningless. However,</span>
00929 <span class="comment">// by always returning a code that means OK, old code should continue to work.</span>
00930 <span class="comment">//</span>
00931 <span class="comment">// Revision 1.49  2001/09/28 17:50:07  jimg</span>
00932 <span class="comment">// Merged with 3.2.7.</span>
00933 <span class="comment">//</span>
00934 <span class="comment">// Revision 1.46.4.3  2001/09/07 00:38:35  jimg</span>
00935 <span class="comment">// Sequence::deserialize(...) now reads all the sequence values at once.</span>
00936 <span class="comment">// Its call semantics are the same as the other classes' versions. Values</span>
00937 <span class="comment">// are stored in the Sequence object using a vector&lt;BaseType *&gt; for each</span>
00938 <span class="comment">// row (those are themselves held in a vector). Three new accessor methods</span>
00939 <span class="comment">// have been added to Sequence (row_value() and two versions of var_value()).</span>
00940 <span class="comment">// BaseType::deserialize(...) now always returns true. This matches with the</span>
00941 <span class="comment">// expectations of most client code (the seqeunce version returned false</span>
00942 <span class="comment">// when it was done reading, but all the calls for sequences must be changed</span>
00943 <span class="comment">// anyway). If an XDR error is found, deserialize throws InternalErr.</span>
00944 <span class="comment">//</span>
00945 <span class="comment">// Revision 1.48  2001/08/24 17:46:22  jimg</span>
00946 <span class="comment">// Resolved conflicts from the merge of release 3.2.6</span>
00947 <span class="comment">//</span>
00948 <span class="comment">// Revision 1.46.4.2  2001/07/28 00:29:22  jimg</span>
00949 <span class="comment">// Added to operator= code which deletes dynamically allocated memory held by</span>
00950 <span class="comment">// the instance. This prevents a memory leak when the assignment operator is</span>
00951 <span class="comment">// used.</span>
00952 <span class="comment">//</span>
00953 <span class="comment">// Revision 1.47  2001/06/15 23:49:02  jimg</span>
00954 <span class="comment">// Merged with release-3-2-4.</span>
00955 <span class="comment">//</span>
00956 <span class="comment">// Revision 1.46.4.1  2001/06/05 06:49:19  jimg</span>
00957 <span class="comment">// Added the Constructor class which is to Structures, Sequences and Grids</span>
00958 <span class="comment">// what Vector is to Arrays and Lists. This should be used in future</span>
00959 <span class="comment">// refactorings (I thought it was going to be used for the back pointers).</span>
00960 <span class="comment">// Introduced back pointers so children can refer to their parents in</span>
00961 <span class="comment">// hierarchies of variables.</span>
00962 <span class="comment">// Added to Sequence methods to tell if a child sequence is done</span>
00963 <span class="comment">// deserializing its data.</span>
00964 <span class="comment">// Fixed the operator=() and copy ctors; removed redundency from</span>
00965 <span class="comment">// _duplicate().</span>
00966 <span class="comment">// Changed the way serialize and deserialize work for sequences. Now SOI and</span>
00967 <span class="comment">// EOS markers are written for every `level' of a nested Sequence. This</span>
00968 <span class="comment">// should fixed nested Sequences. There is still considerable work to do</span>
00969 <span class="comment">// for these to work in all cases.</span>
00970 <span class="comment">//</span>
00971 <span class="comment">// Revision 1.46  2000/10/06 01:26:05  jimg</span>
00972 <span class="comment">// Changed the way serialize() calls read(). The status from read() is</span>
00973 <span class="comment">// returned by the Structure and Sequence serialize() methods; ignored by</span>
00974 <span class="comment">// all others. Any exceptions thrown by read() are caught and discarded.</span>
00975 <span class="comment">// serialize() returns false if read() throws an exception. This should</span>
00976 <span class="comment">// be fixed once all the servers build using the new read() definition.</span>
00977 <span class="comment">//</span>
00978 <span class="comment">// Revision 1.45  2000/09/22 02:17:20  jimg</span>
00979 <span class="comment">// Rearranged source files so that the CVS logs appear at the end rather than</span>
00980 <span class="comment">// the start. Also made the ifdef guard symbols use the same naming scheme and</span>
00981 <span class="comment">// wrapped headers included in other headers in those guard symbols (to cut</span>
00982 <span class="comment">// down on extraneous file processing - See Lakos).</span>
00983 <span class="comment">//</span>
00984 <span class="comment">// Revision 1.44  2000/09/21 16:22:08  jimg</span>
00985 <span class="comment">// Merged changes from Jose Garcia that add exceptions to the software.</span>
00986 <span class="comment">// Many methods that returned error codes now throw exectptions. There are</span>
00987 <span class="comment">// two classes which are thrown by the software, Error and InternalErr.</span>
00988 <span class="comment">// InternalErr is used to report errors within the library or errors using</span>
00989 <span class="comment">// the library. Error is used to reprot all other errors. Since InternalErr</span>
00990 <span class="comment">// is a subclass of Error, programs need only to catch Error.</span>
00991 <span class="comment">//</span>
00992 <span class="comment">// Revision 1.43  2000/07/09 22:05:36  rmorris</span>
00993 <span class="comment">// Changes to increase portability, minimize ifdef's for win32 and account</span>
00994 <span class="comment">// for differences in the iostreams implementations.</span>
00995 <span class="comment">//</span>
00996 <span class="comment">// Revision 1.42  2000/06/16 18:14:59  jimg</span>
00997 <span class="comment">// Merged with 3.1.7</span>
00998 <span class="comment">//</span>
00999 <span class="comment">// Revision 1.38.6.1  2000/06/07 23:05:31  jimg</span>
01000 <span class="comment">// The first_*() methods return 0 if there are no variables</span>
01001 <span class="comment">//</span>
01002 <span class="comment">// Revision 1.41  2000/06/07 18:06:59  jimg</span>
01003 <span class="comment">// Merged the pc port branch</span>
01004 <span class="comment">//</span>
01005 <span class="comment">// Revision 1.40.4.1  2000/06/02 18:21:27  rmorris</span>
01006 <span class="comment">// Mod's for port to Win32.</span>
01007 <span class="comment">//</span>
01008 <span class="comment">// Revision 1.40  2000/04/07 00:16:29  jimg</span>
01009 <span class="comment">// Fixed an error in print_val() where the method worked OK for the</span>
01010 <span class="comment">// server-side but not the client-side because it demoted any Grid whose</span>
01011 <span class="comment">// send_p flag was not set to a Structure. Since the client-side does not have</span>
01012 <span class="comment">// CEs, there are no projections and send_p will never be set.</span>
01013 <span class="comment">//</span>
01014 <span class="comment">// Revision 1.39.2.3  2000/03/08 00:09:04  jgarcia</span>
01015 <span class="comment">// replace ostrstream with string;added functions to convert from double and long to string</span>
01016 <span class="comment">//</span>
01017 <span class="comment">// Revision 1.39.2.2  2000/02/17 05:03:13  jimg</span>
01018 <span class="comment">// Added file and line number information to calls to InternalErr.</span>
01019 <span class="comment">// Resolved compile-time problems with read due to a change in its</span>
01020 <span class="comment">// parameter list given that errors are now reported using exceptions.</span>
01021 <span class="comment">//</span>
01022 <span class="comment">// Revision 1.39.2.1  2000/01/28 22:14:05  jgarcia</span>
01023 <span class="comment">// Added exception handling and modify add_var to get a copy of the object</span>
01024 <span class="comment">//</span>
01025 <span class="comment">// Revision 1.39  1999/12/02 00:24:32  jimg</span>
01026 <span class="comment">// Fixed print_val for Grids that decay to Structures.</span>
01027 <span class="comment">//</span>
01028 <span class="comment">// Revision 1.38  1999/04/29 02:29:30  jimg</span>
01029 <span class="comment">// Merge of no-gnu branch</span>
01030 <span class="comment">//</span>
01031 <span class="comment">// Revision 1.37  1998/09/17 17:20:00  jimg</span>
01032 <span class="comment">// Changes for the new variable lookup scheme. Fields of ctor types no longer</span>
01033 <span class="comment">// need to be fully qualified. my.thing.f1 can now be named `f1' in a CE. Note</span>
01034 <span class="comment">// that if there are two `f1's in a dataset, the first will be silently used;</span>
01035 <span class="comment">// There's no warning about the situation. The new code in the var member</span>
01036 <span class="comment">// function passes a stack of BaseType pointers so that the projection</span>
01037 <span class="comment">// information (send_p field) can be set properly.</span>
01038 <span class="comment">//</span>
01039 <span class="comment">// Revision 1.36  1998/08/31 21:46:09  jimg</span>
01040 <span class="comment">// Changed the check_semantics member function so that the array and map</span>
01041 <span class="comment">// vectors must be composed of simple-type elements.</span>
01042 <span class="comment">//</span>
01043 <span class="comment">// Revision 1.35.2.1  1999/02/02 21:56:59  jimg</span>
01044 <span class="comment">// String to string version</span>
01045 <span class="comment">//</span>
01046 <span class="comment">// Revision 1.35  1998/08/06 16:19:54  jimg</span>
01047 <span class="comment">// Fixed misuse of read member function in serialize. Test for a read(...)</span>
01048 <span class="comment">// error by checking the value of the `error' parameter, not the return value</span>
01049 <span class="comment">// of the read(...) member function. (from jeh)</span>
01050 <span class="comment">//</span>
01051 <span class="comment">// Revision 1.34  1998/03/17 17:32:00  jimg</span>
01052 <span class="comment">// Added an implementation of element_count().</span>
01053 <span class="comment">//</span>
01054 <span class="comment">// Revision 1.33  1997/09/22 23:02:10  jimg</span>
01055 <span class="comment">// Added DDS * to deserialize parameters.</span>
01056 <span class="comment">//</span>
01057 <span class="comment">// Revision 1.32  1997/06/05 22:50:46  jimg</span>
01058 <span class="comment">// Added two mfuncs: components() and projection_yields_grid(). These aid in</span>
01059 <span class="comment">// sending Grids that have been projected in various ways.</span>
01060 <span class="comment">// Fixed print_decl() so that a Grid that has some components projected either</span>
01061 <span class="comment">// by explicitly listing them or by listing only some of the Grids dimensions</span>
01062 <span class="comment">// will be sent properly. This means that some Grid objects `decay' to either</span>
01063 <span class="comment">// Structures of Arrays or simple Arrays depending on the projection.</span>
01064 <span class="comment">//</span>
01065 <span class="comment">// Revision 1.31  1997/03/08 19:02:02  jimg</span>
01066 <span class="comment">// Changed default param to check_semantics() from  to String()</span>
01067 <span class="comment">// and removed the default from the argument list in the mfunc definition</span>
01068 <span class="comment">//</span>
01069 <span class="comment">// Revision 1.30  1997/02/28 01:27:54  jimg</span>
01070 <span class="comment">// Changed check_semantics() so that it now returns error messages in a String</span>
01071 <span class="comment">// object (passed by reference).</span>
01072 <span class="comment">//</span>
01073 <span class="comment">// Revision 1.29  1997/02/10 02:32:40  jimg</span>
01074 <span class="comment">// Added assert statements for pointers</span>
01075 <span class="comment">//</span>
01076 <span class="comment">// Revision 1.28  1996/09/16 18:08:40  jimg</span>
01077 <span class="comment">// Fixed var(const String name) so that it would correctly descend names of the</span>
01078 <span class="comment">// form &lt;base&gt;.&lt;name&gt; where &lt;name&gt; may itself contain `dots'.</span>
01079 <span class="comment">//</span>
01080 <span class="comment">// Revision 1.27  1996/08/12 21:52:41  jimg</span>
01081 <span class="comment">// Fixed a bug in check_semantics where the array name was confused with the</span>
01082 <span class="comment">// dimension names - this may be a bug in the libg++2.7.1 implementation of the</span>
01083 <span class="comment">// class String or a bug in our usage of the same. The problem did not show up</span>
01084 <span class="comment">// on the SunOS 4.1.3 platform.</span>
01085 <span class="comment">//</span>
01086 <span class="comment">// Revision 1.26  1996/06/04 21:33:31  jimg</span>
01087 <span class="comment">// Multiple connections are now possible. It is now possible to open several</span>
01088 <span class="comment">// URLs at the same time and read from them in a round-robin fashion. To do</span>
01089 <span class="comment">// this I added data source and sink parameters to the serialize and</span>
01090 <span class="comment">// deserialize mfuncs. Connect was also modified so that it manages the data</span>
01091 <span class="comment">// source `object' (which is just an XDR pointer).</span>
01092 <span class="comment">//</span>
01093 <span class="comment">// Revision 1.25  1996/05/31 23:29:46  jimg</span>
01094 <span class="comment">// Updated copyright notice.</span>
01095 <span class="comment">//</span>
01096 <span class="comment">// Revision 1.24  1996/05/22 18:05:12  jimg</span>
01097 <span class="comment">// Merged files from the old netio directory into the dap directory.</span>
01098 <span class="comment">// Removed the errmsg library from the software.</span>
01099 <span class="comment">//</span>
01100 <span class="comment">// Revision 1.23  1996/05/16 22:49:47  jimg</span>
01101 <span class="comment">// Dan's changes for version 2.0. Added a parameter to read that returns</span>
01102 <span class="comment">// an error code so that EOF can be distinguished from an actual error when</span>
01103 <span class="comment">// reading sequences. This *may* be replaced by an error member function</span>
01104 <span class="comment">// in the future.</span>
01105 <span class="comment">//</span>
01106 <span class="comment">// Revision 1.22  1996/05/14 15:38:26  jimg</span>
01107 <span class="comment">// These changes have already been checked in once before. However, I</span>
01108 <span class="comment">// corrupted the source repository and restored it from a 5/9/96 backup</span>
01109 <span class="comment">// tape. The previous version's log entry should cover the changes.</span>
01110 <span class="comment">//</span>
01111 <span class="comment">// Revision 1.21  1996/04/05 00:21:33  jimg</span>
01112 <span class="comment">// Compiled with g++ -Wall and fixed various warnings.</span>
01113 <span class="comment">//</span>
01114 <span class="comment">// Revision 1.20  1996/04/04 18:26:50  jimg</span>
01115 <span class="comment">// Merged changes from version 1.1.1.</span>
01116 <span class="comment">//</span>
01117 <span class="comment">// Revision 1.19  1996/03/05 18:10:14  jimg</span>
01118 <span class="comment">// Fixed serialize bug where Maps might not be sent.</span>
01119 <span class="comment">// Added ce_eval to serailize member function.</span>
01120 <span class="comment">//</span>
01121 <span class="comment">// Revision 1.18  1996/02/02 00:31:05  jimg</span>
01122 <span class="comment">// Merge changes for DODS-1.1.0 into DODS-2.x</span>
01123 <span class="comment">//</span>
01124 <span class="comment">// Revision 1.17  1995/12/09  01:06:46  jimg</span>
01125 <span class="comment">// Added changes so that relational operators will work properly for all the</span>
01126 <span class="comment">// datatypes (including Sequences). The relational ops are evaluated in</span>
01127 <span class="comment">// DDS::eval_constraint() after being parsed by DDS::parse_constraint().</span>
01128 <span class="comment">//</span>
01129 <span class="comment">// Revision 1.16  1995/12/06  21:56:24  jimg</span>
01130 <span class="comment">// Added `constrained' flag to print_decl.</span>
01131 <span class="comment">// Removed third parameter of read.</span>
01132 <span class="comment">// Modified print_decl() to print only those parts of a dataset that are</span>
01133 <span class="comment">// selected when `constrained' is true.</span>
01134 <span class="comment">//</span>
01135 <span class="comment">// Revision 1.15  1995/10/23  23:20:55  jimg</span>
01136 <span class="comment">// Added _send_p and _read_p fields (and their accessors) along with the</span>
01137 <span class="comment">// virtual mfuncs set_send_p() and set_read_p().</span>
01138 <span class="comment">//</span>
01139 <span class="comment">// Revision 1.14  1995/08/26  00:31:33  jimg</span>
01140 <span class="comment">// Removed code enclosed in #ifdef NEVER #endif.</span>
01141 <span class="comment">//</span>
01142 <span class="comment">// Revision 1.13  1995/08/23  00:11:12  jimg</span>
01143 <span class="comment">// Changed old, deprecated member functions to new ones.</span>
01144 <span class="comment">// Switched from String representation of type to enum.</span>
01145 <span class="comment">//</span>
01146 <span class="comment">// Revision 1.12.2.2  1996/03/01 00:06:12  jimg</span>
01147 <span class="comment">// Removed bad attempt at multiple connect implementation.</span>
01148 <span class="comment">//</span>
01149 <span class="comment">// Revision 1.12.2.1  1995/09/14  20:58:16  jimg</span>
01150 <span class="comment">// Moved some loop index variables out of the loop statement.</span>
01151 <span class="comment">//</span>
01152 <span class="comment">// Revision 1.12  1995/07/09  21:28:59  jimg</span>
01153 <span class="comment">// Added copyright notice.</span>
01154 <span class="comment">//</span>
01155 <span class="comment">// Revision 1.11  1995/05/10  15:34:00  jimg</span>
01156 <span class="comment">// Failed to change `config.h' to `config_dap.h' in these files.</span>
01157 <span class="comment">//</span>
01158 <span class="comment">// Revision 1.10  1995/05/10  13:45:18  jimg</span>
01159 <span class="comment">// Changed the name of the configuration header file from `config.h' to</span>
01160 <span class="comment">// `config_dap.h' so that other libraries could have header files which were</span>
01161 <span class="comment">// installed in the DODS include directory without overwriting this one. Each</span>
01162 <span class="comment">// config header should follow the convention config_&lt;name&gt;.h.</span>
01163 <span class="comment">//</span>
01164 <span class="comment">// Revision 1.9  1995/03/16  17:29:10  jimg</span>
01165 <span class="comment">// Added include config_dap.h to top of include list.</span>
01166 <span class="comment">// Added TRACE_NEW switched dbnew includes.</span>
01167 <span class="comment">// Fixed bug in read_val() where **val was passed incorrectly to</span>
01168 <span class="comment">// subordinate read_val() calls.</span>
01169 <span class="comment">//</span>
01170 <span class="comment">// Revision 1.8  1995/03/04  14:34:45  jimg</span>
01171 <span class="comment">// Major modifications to the transmission and representation of values:</span>
01172 <span class="comment">// Added card() virtual function which is true for classes that</span>
01173 <span class="comment">// contain cardinal types (byte, int float, string).</span>
01174 <span class="comment">// Changed the representation of Str from the C rep to a C++</span>
01175 <span class="comment">// class represenation.</span>
01176 <span class="comment">// Chnaged read_val and store_val so that they take and return</span>
01177 <span class="comment">// types that are stored by the object (e.g., inthe case of Str</span>
01178 <span class="comment">// an URL, read_val returns a C++ String object).</span>
01179 <span class="comment">// Modified Array representations so that arrays of card()</span>
01180 <span class="comment">// objects are just that - no more storing strings, ... as</span>
01181 <span class="comment">// C would store them.</span>
01182 <span class="comment">// Arrays of non cardinal types are arrays of the DODS objects (e.g.,</span>
01183 <span class="comment">// an array of a structure is represented as an array of Structure</span>
01184 <span class="comment">// objects).</span>
01185 <span class="comment">//</span>
01186 <span class="comment">// Revision 1.7  1995/02/10  02:23:07  jimg</span>
01187 <span class="comment">// Added DBMALLOC includes and switch to code which uses malloc/free.</span>
01188 <span class="comment">// Private and protected symbols now start with `_'.</span>
01189 <span class="comment">// Added new accessors for name and type fields of BaseType; the old ones</span>
01190 <span class="comment">// will be removed in a future release.</span>
01191 <span class="comment">// Added the store_val() mfunc. It stores the given value in the object's</span>
01192 <span class="comment">// internal buffer.</span>
01193 <span class="comment">// Made both List and Str handle their values via pointers to memory.</span>
01194 <span class="comment">// Fixed read_val().</span>
01195 <span class="comment">// Made serialize/deserialize handle all malloc/free calls (even in those</span>
01196 <span class="comment">// cases where xdr initiates the allocation).</span>
01197 <span class="comment">// Fixed print_val().</span>
01198 <span class="comment">//</span>
01199 <span class="comment">// Revision 1.6  1995/01/19  20:05:27  jimg</span>
01200 <span class="comment">// ptr_duplicate() mfunc is now abstract virtual.</span>
01201 <span class="comment">// Array, ... Grid duplicate mfuncs were modified to take pointers, not</span>
01202 <span class="comment">// referenves.</span>
01203 <span class="comment">//</span>
01204 <span class="comment">// Revision 1.5  1995/01/11  15:54:46  jimg</span>
01205 <span class="comment">// Added modifications necessary for BaseType's static XDR pointers. This</span>
01206 <span class="comment">// was mostly a name change from xdrin/out to _xdrin/out.</span>
01207 <span class="comment">// Removed the two FILE pointers from ctors, since those are now set with</span>
01208 <span class="comment">// functions which are friends of BaseType.</span>
01209 <span class="comment">//</span>
01210 <span class="comment">// Revision 1.4  1994/12/14  20:56:57  dan</span>
01211 <span class="comment">// Fixed deserialize() to return correct size count.</span>
01212 <span class="comment">// Fixed check_semantics() to use new Array dimension member functions.</span>
01213 <span class="comment">//</span>
01214 <span class="comment">// Revision 1.3  1994/10/17  23:34:53  jimg</span>
01215 <span class="comment">// Added code to print_decl so that variable declarations are pretty</span>
01216 <span class="comment">// printed.</span>
01217 <span class="comment">// Added private mfunc duplicate().</span>
01218 <span class="comment">// Added ptr_duplicate().</span>
01219 <span class="comment">// Added Copy ctor, dtor and operator=.</span>
01220 <span class="comment">//</span>
01221 <span class="comment">// Revision 1.2  1994/09/23  14:45:28  jimg</span>
01222 <span class="comment">// Added mfunc check_semantics().</span>
01223 <span class="comment">// Added sanity checking on the variable list (is it empty?).</span>
01224 <span class="comment">//</span>
01225 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Feb 4 23:43:00 2004 for libdap++ by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
