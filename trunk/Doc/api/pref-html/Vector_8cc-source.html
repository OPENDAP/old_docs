<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libdap++: Vector.cc Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Vector.cc</h1><a href="Vector_8cc.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00002 <span class="comment">// -*- mode: c++; c-basic-offset:4 -*-</span>
00003 
00004 <span class="comment">// This file is part of libdap, A C++ implementation of the OPeNDAP Data</span>
00005 <span class="comment">// Access Protocol.</span>
00006 
00007 <span class="comment">// Copyright (c) 2002,2003 OPeNDAP, Inc.</span>
00008 <span class="comment">// Author: James Gallagher &lt;jgallagher@opendap.org&gt;</span>
00009 <span class="comment">//</span>
00010 <span class="comment">// This library is free software; you can redistribute it and/or</span>
00011 <span class="comment">// modify it under the terms of the GNU Lesser General Public</span>
00012 <span class="comment">// License as published by the Free Software Foundation; either</span>
00013 <span class="comment">// version 2.1 of the License, or (at your option) any later version.</span>
00014 <span class="comment">// </span>
00015 <span class="comment">// This library is distributed in the hope that it will be useful,</span>
00016 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00017 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00018 <span class="comment">// Lesser General Public License for more details.</span>
00019 <span class="comment">// </span>
00020 <span class="comment">// You should have received a copy of the GNU Lesser General Public</span>
00021 <span class="comment">// License along with this library; if not, write to the Free Software</span>
00022 <span class="comment">// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00023 <span class="comment">//</span>
00024 <span class="comment">// You can contact OPeNDAP, Inc. at PO Box 112, Saunderstown, RI. 02874-0112.</span>
00025  
00026 <span class="comment">// (c) COPYRIGHT URI/MIT 1995-1999</span>
00027 <span class="comment">// Please read the full copyright statement in the file COPYRIGHT_URI.</span>
00028 <span class="comment">//</span>
00029 <span class="comment">// Authors:</span>
00030 <span class="comment">//      jhrg,jimg       James Gallagher &lt;jgallagher@gso.uri.edu&gt;</span>
00031 
00032 <span class="comment">// Implementation for class Vector. This class is the basis for all the</span>
00033 <span class="comment">// vector-type classes in DODS &lt;Array, List&gt;. </span>
00034 <span class="comment">//</span>
00035 <span class="comment">// 11/21/95 jhrg</span>
00036 
00037 <span class="preprocessor">#include "<a class="code" href="config__dap_8h.html">config_dap.h</a>"</span>
00038 
00039 <span class="keyword">static</span> <span class="keywordtype">char</span> rcsid[] <a class="code" href="config__dap_8h.html#a49">not_used</a> = {<span class="stringliteral">"$Id$"</span>};
00040 
00041 <span class="preprocessor">#ifdef __GNUG__</span>
00042 <span class="preprocessor"></span><span class="preprocessor">#pragma implementation</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00044 <span class="preprocessor"></span>
00045 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00046 
00047 <span class="preprocessor">#include "<a class="code" href="Vector_8h.html">Vector.h</a>"</span>
00048 <span class="preprocessor">#include "<a class="code" href="escaping_8h.html">escaping.h</a>"</span>
00049 <span class="preprocessor">#include "<a class="code" href="util_8h.html">util.h</a>"</span>
00050 <span class="preprocessor">#include "<a class="code" href="debug_8h.html">debug.h</a>"</span>
00051 <span class="preprocessor">#include "<a class="code" href="InternalErr_8h.html">InternalErr.h</a>"</span>
00052 
00053 <span class="preprocessor">#ifdef TRACE_NEW</span>
00054 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="trace__new_8h.html">trace_new.h</a>"</span>
00055 <span class="preprocessor">#endif</span>
00056 <span class="preprocessor"></span>
00057 <span class="keyword">using</span> std::cerr;
00058 <span class="keyword">using</span> std::endl;
00059 
00060 <span class="keywordtype">void</span>
<a name="l00061"></a><a class="code" href="classVector.html#Vectorb0">00061</a> <a class="code" href="classVector.html#Vectorb0">Vector::_duplicate</a>(<span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;v)
00062 {
00063     <span class="comment">// BaseType::_duplicate(v);</span>
00064 
00065     _length = v.<a class="code" href="classVector.html#Vectorr0">_length</a>;
00066     _var = v.<a class="code" href="classVector.html#Vectorr1">_var</a>-&gt;<a class="code" href="classBaseType.html#Constructora6">ptr_duplicate</a>(); <span class="comment">// use ptr_duplicate() </span>
00067     _var-&gt;<a class="code" href="classBaseType.html#Vectora42">set_parent</a>(<span class="keyword">this</span>); <span class="comment">// ptr_duplicate does not set d_parent.</span>
00068 
00069     <span class="comment">// Note that for vectors of non-numeric stuff we don't maintain a back</span>
00070     <span class="comment">// pointer for each element, just _var (the template) has a back pointer. </span>
00071     <span class="keywordflow">if</span> (v.<a class="code" href="classVector.html#Vectorr3">_vec</a>.size() == 0)
00072     _vec = v.<a class="code" href="classVector.html#Vectorr3">_vec</a>;
00073     <span class="keywordflow">else</span> {
00074     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; _vec.size(); ++i)
00075         _vec[i] = v.<a class="code" href="classVector.html#Vectorr3">_vec</a>[i];
00076     }
00077 
00078     _buf = 0;           <span class="comment">// init to null</span>
00079     <span class="keywordflow">if</span> (v.<a class="code" href="classVector.html#Vectorr2">_buf</a>)         <span class="comment">// only copy if data present</span>
00080     <a class="code" href="classVector.html#Vectora13">val2buf</a>(v.<a class="code" href="classVector.html#Vectorr2">_buf</a>);    <span class="comment">// store this's value in v's _BUF.</span>
00081 }
00082 
<a name="l00099"></a><a class="code" href="classVector.html#Vectora0">00099</a> <a class="code" href="classVector.html#Vectora0">Vector::Vector</a>(<span class="keyword">const</span> string &amp;n, <a class="code" href="classBaseType.html">BaseType</a> *v, <span class="keyword">const</span> Type &amp;t) 
00100     :<a class="code" href="classBaseType.html">BaseType</a>(n, t), _length(-1), _var(v), _buf(0), _vec(0)
00101 {
00102     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Entering Vector ctor for object: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl);
00103     <span class="keywordflow">if</span> (_var)
00104     _var-&gt;<a class="code" href="classBaseType.html#Vectora42">set_parent</a>(<span class="keyword">this</span>);
00105 }
00106 
<a name="l00108"></a><a class="code" href="classVector.html#Vectora1">00108</a> <a class="code" href="classVector.html#Vectora0">Vector::Vector</a>(<span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;rhs) : <a class="code" href="classBaseType.html">BaseType</a>(rhs)
00109 {
00110     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Entering Vector const ctor for object: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl);
00111     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"RHS: "</span> &lt;&lt; &amp;rhs &lt;&lt; endl);
00112 
00113     <a class="code" href="classVector.html#Vectorb0">_duplicate</a>(rhs);
00114 }
00115 
<a name="l00116"></a><a class="code" href="classVector.html#Vectora2">00116</a> <a class="code" href="classVector.html#Vectora2">Vector::~Vector</a>()
00117 {
00118     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Entering ~Vector ("</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="stringliteral">")"</span> &lt;&lt; endl);
00119 
00120     <span class="keyword">delete</span> _var; _var = 0;
00121 
00122     <span class="keywordflow">if</span> (_buf) {
00123     <span class="keyword">delete</span>[] _buf; _buf = 0;
00124     }
00125     <span class="keywordflow">else</span> {
00126     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; _vec.size(); ++i) {
00127         <span class="keyword">delete</span> _vec[i]; _vec[i] = 0;
00128     }
00129     }
00130 
00131     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Exiting ~Vector"</span> &lt;&lt; endl);
00132 }
00133 
00134 <a class="code" href="classVector.html">Vector</a> &amp;
<a name="l00135"></a><a class="code" href="classVector.html#Vectora3">00135</a> <a class="code" href="classVector.html#Vectora3">Vector::operator=</a>(<span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;rhs)
00136 {
00137     <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;rhs)
00138     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00139 
00140     dynamic_cast&lt;BaseType &amp;&gt;(*this) = rhs;
00141 
00142     <a class="code" href="classVector.html#Vectorb0">_duplicate</a>(rhs);
00143 
00144     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00145 }
00146 
00147 <span class="keywordtype">int</span>
<a name="l00148"></a><a class="code" href="classVector.html#Vectora5">00148</a> <a class="code" href="classVector.html#Vectora5">Vector::element_count</a>(<span class="keywordtype">bool</span> leaves)
00149 {
00150     <span class="keywordflow">if</span> (!leaves)
00151     <span class="keywordflow">return</span> 1;
00152     <span class="keywordflow">else</span>
00153     <span class="comment">// var() only works for simple types! </span>
00154     <span class="keywordflow">return</span> <a class="code" href="classVector.html#Vectora17">var</a>(0)-&gt;<a class="code" href="classBaseType.html#Urla21">element_count</a>(leaves);
00155 }
00156 
00157 <span class="comment">// These mfuncs set the _send_p and _read_p fields of BaseType. They differ</span>
00158 <span class="comment">// from BaseType's version in that they set both the Vector object's copy of</span>
00159 <span class="comment">// _send_p (_read_p) but also _VAR's copy. This does not matter much when _VAR</span>
00160 <span class="comment">// is a scalar, but does matter when it is an aggregate.</span>
00161 
00168 <span class="keywordtype">void</span>
<a name="l00169"></a><a class="code" href="classVector.html#Vectora6">00169</a> <a class="code" href="classVector.html#Vectora6">Vector::set_send_p</a>(<span class="keywordtype">bool</span> state)
00170 {
00171     _var-&gt;<a class="code" href="classBaseType.html#Urla27">set_send_p</a>(state);
00172     <a class="code" href="classBaseType.html#Urla27">BaseType::set_send_p</a>(state);
00173 }
00174 
00181 <span class="keywordtype">void</span> 
<a name="l00182"></a><a class="code" href="classVector.html#Vectora7">00182</a> <a class="code" href="classVector.html#Vectora7">Vector::set_read_p</a>(<span class="keywordtype">bool</span> state)
00183 {
00184     _var-&gt;<a class="code" href="classBaseType.html#Urla25">set_read_p</a>(state);
00185     <a class="code" href="classBaseType.html#Urla25">BaseType::set_read_p</a>(state);
00186 }
00187 
00201 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00202"></a><a class="code" href="classVector.html#Vectora17">00202</a> <a class="code" href="classVector.html#Vectora17">Vector::var</a>(<span class="keyword">const</span> string &amp;n, <span class="keywordtype">bool</span> exact)
00203 {
00204     string <a class="code" href="classBaseType.html#Vectora27">name</a> = <a class="code" href="escaping_8cc.html#a7">www2id</a>(n);
00205 
00206     <span class="comment">// Make sure to check for the case where name is the default (the empty</span>
00207     <span class="comment">// string). 9/1/98 jhrg</span>
00208     <span class="keywordflow">if</span> (_var-&gt;<a class="code" href="classBaseType.html#Vectora34">is_constructor_type</a>()) {
00209     <span class="keywordflow">if</span> (name == <span class="stringliteral">""</span> || _var-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>() == name)
00210         <span class="keywordflow">return</span> _var;
00211     <span class="keywordflow">else</span>
00212         <span class="keywordflow">return</span> _var-&gt;<a class="code" href="classBaseType.html#Vectora44">var</a>(name, exact);
00213     }
00214     <span class="keywordflow">else</span>
00215     <span class="keywordflow">return</span> _var;
00216 }
00217 
00228 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00229"></a><a class="code" href="classVector.html#Vectora18">00229</a> <a class="code" href="classVector.html#Vectora17">Vector::var</a>(<span class="keyword">const</span> string &amp;n, <a class="code" href="BaseType_8h.html#a1">btp_stack</a> &amp;s)
00230 {
00231     string <a class="code" href="classBaseType.html#Vectora27">name</a> = <a class="code" href="escaping_8cc.html#a7">www2id</a>(n);
00232 
00233     <span class="keywordflow">if</span> (_var-&gt;<a class="code" href="classBaseType.html#Vectora34">is_constructor_type</a>())
00234     <span class="keywordflow">return</span> _var-&gt;<a class="code" href="classBaseType.html#Vectora44">var</a>(name, s);
00235     <span class="keywordflow">else</span> {
00236     s.push((<a class="code" href="classBaseType.html">BaseType</a> *)<span class="keyword">this</span>);
00237     <span class="keywordflow">return</span> _var;
00238     }
00239 }
00240 
00241 <span class="comment">// Return a pointer the the BaseType object for element I. If the Vector is</span>
00242 <span class="comment">// of a cardinal type, store the Ith element's value in the BaseType</span>
00243 <span class="comment">// object. If it is a Vector of a non-cardinal type, then this mfunc returns</span>
00244 <span class="comment">// _vec[i]. </span>
00245 <span class="comment">//</span>
00246 <span class="comment">// NB: I defaults to zero.</span>
00247 <span class="comment">//</span>
00248 <span class="comment">// Returns: A BaseType pointer to the Ith element of the Vector.</span>
00249 
00260 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00261"></a><a class="code" href="classVector.html#Vectora19">00261</a> <a class="code" href="classVector.html#Vectora17">Vector::var</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i)
00262 {
00263     
00264     <span class="keywordflow">switch</span> (_var-&gt;<a class="code" href="classBaseType.html#Vectora29">type</a>()) {
00265       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a6">dods_byte_c</a>:
00266       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a7">dods_int16_c</a>:
00267       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a8">dods_uint16_c</a>:
00268       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a9">dods_int32_c</a>:
00269       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a10">dods_uint32_c</a>:
00270       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a11">dods_float32_c</a>:
00271       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a12">dods_float64_c</a>: {
00272       <span class="comment">// Transfer the ith value to the BaseType *_var; There are more</span>
00273       <span class="comment">// efficient ways to get a whole array using buf2val() but this is</span>
00274       <span class="comment">// an OK way to get a single value or several non-contiguous values.</span>
00275       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz = _var-&gt;<a class="code" href="classBaseType.html#Constructora30">width</a>();
00276       _var-&gt;<a class="code" href="classBaseType.html#Constructora33">val2buf</a>((<span class="keywordtype">char</span> *)_buf + (i * sz));
00277       <span class="keywordflow">return</span> _var;
00278       <span class="keywordflow">break</span>;
00279       }
00280 
00281       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a13">dods_str_c</a>:
00282       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a14">dods_url_c</a>:
00283       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a15">dods_array_c</a>:
00284       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a16">dods_list_c</a>:
00285       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a17">dods_structure_c</a>:
00286       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a18">dods_sequence_c</a>:
00287       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a19">dods_grid_c</a>:
00288     <span class="keywordflow">return</span> _vec[i];
00289     <span class="keywordflow">break</span>;
00290 
00291       <span class="keywordflow">default</span>:
00292     cerr &lt;&lt; <span class="stringliteral">"Vector::var: Unrecognized type"</span> &lt;&lt; endl;
00293     }
00294 
00295     <span class="keywordflow">return</span> 0;
00296 }
00297 
00298 <span class="comment">// Return: The number of bytes required to store the vector `in a C</span>
00299 <span class="comment">// program'. For an array of cardinal types this is the same as the storage</span>
00300 <span class="comment">// used by _BUF. For anything else, it is the product of length() and the</span>
00301 <span class="comment">// element width(). It turns out that both values can be computed the same</span>
00302 <span class="comment">// way. </span>
00303 <span class="comment">//</span>
00304 <span class="comment">// Returns: The number of bytes used to store the vector.</span>
00305 
00311 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00312"></a><a class="code" href="classVector.html#Vectora8">00312</a> <a class="code" href="classVector.html#Vectora8">Vector::width</a>()
00313 {
00314     <span class="comment">// Jose Garcia</span>
00315     <span class="keywordflow">if</span> (!_var)
00316       <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, 
00317           <span class="stringliteral">"Cannot get width since *this* object is not holding data."</span>);
00318 
00319     <span class="keywordflow">return</span> <a class="code" href="classVector.html#Vectora9">length</a>() * _var-&gt;<a class="code" href="classBaseType.html#Constructora30">width</a>();
00320 }
00321 
00322 <span class="comment">// Returns: the number of elements in the vector. </span>
00323 
00328 <span class="keywordtype">int</span>
<a name="l00329"></a><a class="code" href="classVector.html#Vectora9">00329</a> <a class="code" href="classVector.html#Vectora9">Vector::length</a>()
00330 {
00331     <span class="keywordflow">return</span> _length;
00332 }
00333 
00334 <span class="comment">// set the number of elements in the vector.</span>
00335 <span class="comment">//</span>
00336 <span class="comment">// Returns: void</span>
00337 
00340 <span class="keywordtype">void</span>
<a name="l00341"></a><a class="code" href="classVector.html#Vectora10">00341</a> <a class="code" href="classVector.html#Vectora10">Vector::set_length</a>(<span class="keywordtype">int</span> l)
00342 {
00343     _length = l;
00344 }
00345 
00346 <span class="comment">// \e l is the number of elements the vector can hold (e.g., if l == 20, then</span>
00347 <span class="comment">// the vector can hold elements 0, .., 19).</span>
00348 
00354 <span class="keywordtype">void</span>
<a name="l00355"></a><a class="code" href="classVector.html#Vectora16">00355</a> <a class="code" href="classVector.html#Vectora16">Vector::vec_resize</a>(<span class="keywordtype">int</span> l)
00356 {
00357     _vec.resize((l &gt; 0) ? l : 0, 0); <span class="comment">// Fill with NULLs</span>
00358 }
00359 
00372 <span class="keywordtype">bool</span>
<a name="l00373"></a><a class="code" href="classVector.html#Vectora11">00373</a> <a class="code" href="classVector.html#Vectora11">Vector::serialize</a>(<span class="keyword">const</span> string &amp;dataset, <a class="code" href="classDDS.html">DDS</a> &amp;dds, XDR *sink, 
00374           <span class="keywordtype">bool</span> ce_eval)
00375 {
00376     <span class="keywordtype">int</span> i = 0;
00377 
00378     dds.<a class="code" href="classDDS.html#DDSa18">timeout_on</a>();
00379 
00380     <span class="keywordflow">if</span> (!<a class="code" href="classBaseType.html#Vectora37">read_p</a>())
00381     <a class="code" href="classBaseType.html#Vectora45">read</a>(dataset);      <span class="comment">// read() throws Error and InternalErr</span>
00382 
00383     <span class="keywordflow">if</span> (ce_eval &amp;&amp; !dds.<a class="code" href="classDDS.html#DDSa31">eval_selection</a>(dataset))
00384     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00385 
00386     dds.<a class="code" href="classDDS.html#DDSa19">timeout_off</a>();
00387 
00388     <span class="comment">// length() is not capacity; it must be set explicitly in read().</span>
00389     <span class="keywordtype">int</span> num = <a class="code" href="classVector.html#Vectora9">length</a>();
00390 
00391     <span class="keywordflow">switch</span> (_var-&gt;<a class="code" href="classBaseType.html#Vectora29">type</a>()) {
00392       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a6">dods_byte_c</a>:
00393       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a7">dods_int16_c</a>:
00394       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a8">dods_uint16_c</a>:
00395       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a9">dods_int32_c</a>:
00396       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a10">dods_uint32_c</a>:
00397       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a11">dods_float32_c</a>:
00398       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a12">dods_float64_c</a>:
00399     <span class="comment">// Jose Garcia</span>
00400     <span class="comment">// If we are trying to serialize data and the internal buffer is</span>
00401     <span class="comment">// unset, then the read method failed to do its job.</span>
00402     <span class="keywordflow">if</span>(!_buf)
00403         <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, 
00404                   <span class="stringliteral">"Buffer pointer is not set."</span>);
00405 
00406     <span class="keywordflow">if</span> ((0 == xdr_int(sink, (<span class="keywordtype">int</span> *)&amp;num))) <span class="comment">// send vector length</span>
00407         <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(
00408 <span class="stringliteral">"Network I/O Error. This may be due to a bug in DODS or a\n\</span>
00409 <span class="stringliteral">problem with the network connection."</span>);
00410 
00411     <span class="comment">// Note that xdr_bytes and xdr_array both send the length themselves,</span>
00412     <span class="comment">// so the length is actually sent twice. 12/31/99 jhrg</span>
00413     <span class="keywordtype">bool</span> status;
00414     <span class="keywordflow">if</span> (_var-&gt;<a class="code" href="classBaseType.html#Vectora29">type</a>() == <a class="code" href="BaseType_8h.html#a21a6">dods_byte_c</a>)
00415         status = (0 != xdr_bytes(sink, (<span class="keywordtype">char</span> **)&amp;_buf, 
00416                      (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *)&amp;num,
00417                      <a class="code" href="Array_8h.html#a1">DODS_MAX_ARRAY</a>)); 
00418     <span class="keywordflow">else</span>
00419         status = (0 != xdr_array(sink, (<span class="keywordtype">char</span> **)&amp;_buf,
00420                      (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *)&amp;num,
00421                      <a class="code" href="Array_8h.html#a1">DODS_MAX_ARRAY</a>, _var-&gt;<a class="code" href="classBaseType.html#Constructora30">width</a>(),
00422                      (xdrproc_t)(_var-&gt;<a class="code" href="classBaseType.html#Vectora41">xdr_coder</a>())));
00423     <span class="keywordflow">if</span> (!status)
00424         <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(
00425 <span class="stringliteral">"Network I/O Error. This may be due to a bug in DODS or a\n\</span>
00426 <span class="stringliteral">problem with the network connection."</span>);
00427     
00428     <span class="keywordflow">break</span>;
00429 
00430       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a13">dods_str_c</a>:
00431       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a14">dods_url_c</a>:
00432       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a15">dods_array_c</a>:
00433       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a16">dods_list_c</a>:
00434       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a17">dods_structure_c</a>:
00435       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a18">dods_sequence_c</a>:
00436       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a19">dods_grid_c</a>:
00437     <span class="comment">//Jose Garcia</span>
00438     <span class="comment">// Not setting the capacity of _vec is an internal error.</span>
00439     <span class="keywordflow">if</span>(_vec.capacity() == 0)
00440         <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, 
00441                   <span class="stringliteral">"The capacity of *this* vector is 0."</span>);
00442 
00443     <span class="keywordflow">if</span> ((0 == xdr_int(sink, (<span class="keywordtype">int</span> *)&amp;num)))
00444         <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(
00445 <span class="stringliteral">"Network I/O Error. This may be due to a bug in DODS or a\n\</span>
00446 <span class="stringliteral">problem with the network connection."</span>);
00447 
00448     <span class="keywordflow">for</span> (i = 0; i &lt; num; ++i)
00449         _vec[i]-&gt;serialize(dataset, dds, sink, <span class="keyword">false</span>);
00450 
00451     <span class="keywordflow">break</span>;
00452 
00453       <span class="keywordflow">default</span>:
00454     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, <span class="stringliteral">"Unknown datatype."</span>);
00455     <span class="keywordflow">break</span>;
00456     }
00457 
00458     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00459 }
00460 
00461 <span class="comment">// Read an object from the network and internalize it. For a Vector this is</span>
00462 <span class="comment">// handled differently for a `cardinal' type. Vectors of Cardinals are</span>
00463 <span class="comment">// stored using the `C' representations because these objects often are used</span>
00464 <span class="comment">// to build huge arrays (e.g., an array of 1024 by 1024 bytes). However,</span>
00465 <span class="comment">// arrays of non-cardinal types are stored as Vectors of the C++ objects or</span>
00466 <span class="comment">// DODS objects (Str and Url are vectors of the string class, Structure, ...,</span>
00467 <span class="comment">// Grid are vectors of the DODS Structure, ... classes). </span>
00468 <span class="comment">//</span>
00469 <span class="comment">// The boolean parameter REUSE determines whether internal storage is reused</span>
00470 <span class="comment">// or not. If true, the _buf member is assumed to be large enough to hold the</span>
00471 <span class="comment">// incoming cardinal data and is *not* reallocated. If false, new storage is</span>
00472 <span class="comment">// allocated. If the internal buffer has not yet been allocated, then this</span>
00473 <span class="comment">// parameter has no effect (i.e., storage is allocated). This parameter</span>
00474 <span class="comment">// effects storage for cardinal data only.</span>
00475 <span class="comment">//</span>
00476 <span class="comment">// Returns: True is successful, false otherwise.</span>
00477 
00478 <span class="keywordtype">bool</span>
<a name="l00479"></a><a class="code" href="classVector.html#Vectora12">00479</a> <a class="code" href="classVector.html#Vectora12">Vector::deserialize</a>(XDR *source, <a class="code" href="classDDS.html">DDS</a> *dds, <span class="keywordtype">bool</span> reuse)
00480 {
00481     <span class="keywordtype">bool</span> status;
00482     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num;
00483     <span class="keywordtype">unsigned</span> i = 0;
00484 
00485     <span class="keywordflow">switch</span> (_var-&gt;<a class="code" href="classBaseType.html#Vectora29">type</a>()) {
00486       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a6">dods_byte_c</a>:
00487       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a7">dods_int16_c</a>:
00488       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a8">dods_uint16_c</a>:
00489       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a9">dods_int32_c</a>:
00490       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a10">dods_uint32_c</a>:
00491       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a11">dods_float32_c</a>:
00492       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a12">dods_float64_c</a>:
00493     <span class="keywordflow">if</span> (_buf &amp;&amp; !reuse)
00494         <span class="keyword">delete</span>[] _buf; _buf = 0;
00495 
00496     <span class="keywordflow">if</span> ((0 == xdr_int(source, (<span class="keywordtype">int</span> *)&amp;num)))
00497         <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(
00498 <span class="stringliteral">"Network I/O error. Could not read the array length.\n\</span>
00499 <span class="stringliteral">This may be due to a bug in DODS or a problem with\n\</span>
00500 <span class="stringliteral">the network connection."</span>);
00501 
00502     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Vector::deserialize: num = "</span> &lt;&lt; num &lt;&lt; endl);
00503     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Vector::deserialize: length = "</span> &lt;&lt; <a class="code" href="classVector.html#Vectora9">length</a>() &lt;&lt; endl);
00504 
00505     <span class="keywordflow">if</span> (<a class="code" href="classVector.html#Vectora9">length</a>() == -1)
00506         <a class="code" href="classVector.html#Vectora10">set_length</a>(num);
00507     
00508     <span class="keywordflow">if</span> (num != (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<a class="code" href="classVector.html#Vectora9">length</a>())
00509         <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__,
00510           <span class="stringliteral">"The client sent declarations and data with mismatched sizes."</span>);
00511 
00512     <span class="keywordflow">if</span> (!_buf) {
00513         _buf = <span class="keyword">new</span> <span class="keywordtype">char</span>[<a class="code" href="classVector.html#Vectora8">width</a>()]; <span class="comment">// we always do the allocation!</span>
00514         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"List::deserialize: allocating "</span> \
00515         &lt;&lt; <a class="code" href="classVector.html#Vectora8">width</a>() &lt;&lt; <span class="stringliteral">" bytes for an array of "</span> \
00516         &lt;&lt; <a class="code" href="classVector.html#Vectora9">length</a>() &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; _var-&gt;<a class="code" href="classBaseType.html#Vectora31">type_name</a>() &lt;&lt; endl);
00517     }
00518 
00519     <span class="keywordflow">if</span> (_var-&gt;<a class="code" href="classBaseType.html#Vectora29">type</a>() == <a class="code" href="BaseType_8h.html#a21a6">dods_byte_c</a>)
00520         status = (0 != xdr_bytes(source, (<span class="keywordtype">char</span> **)&amp;_buf, &amp;num,
00521                      <a class="code" href="Array_8h.html#a1">DODS_MAX_ARRAY</a>)); 
00522     <span class="keywordflow">else</span>
00523         status = (0 != xdr_array(source, (<span class="keywordtype">char</span> **)&amp;_buf, &amp;num,
00524                      <a class="code" href="Array_8h.html#a1">DODS_MAX_ARRAY</a>, _var-&gt;<a class="code" href="classBaseType.html#Constructora30">width</a>(),
00525                      (xdrproc_t)(_var-&gt;<a class="code" href="classBaseType.html#Vectora41">xdr_coder</a>())));
00526 
00527     <span class="keywordflow">if</span> (!status)
00528         <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(
00529 <span class="stringliteral">"Network I/O error. Could not read packed array data.\n\</span>
00530 <span class="stringliteral">This may be due to a bug in DODS or a problem with\n\</span>
00531 <span class="stringliteral">the network connection."</span>);
00532 
00533     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Vector::deserialize: read "</span> &lt;&lt; num &lt;&lt;  <span class="stringliteral">" elements\n"</span>);
00534 
00535     <span class="keywordflow">break</span>;
00536 
00537       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a13">dods_str_c</a>:
00538       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a14">dods_url_c</a>:
00539       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a15">dods_array_c</a>:
00540       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a16">dods_list_c</a>:
00541       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a17">dods_structure_c</a>:
00542       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a18">dods_sequence_c</a>:
00543       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a19">dods_grid_c</a>:
00544     <span class="keywordflow">if</span> ((0 == xdr_int(source, (<span class="keywordtype">int</span> *)&amp;num)))
00545         <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(
00546 <span class="stringliteral">"Network I/O error. Could not read the array length.\n\</span>
00547 <span class="stringliteral">This may be due to a bug in DODS or a problem with\n\</span>
00548 <span class="stringliteral">the network connection."</span>);
00549 
00550     <span class="keywordflow">if</span> (<a class="code" href="classVector.html#Vectora9">length</a>() == -1)
00551         <a class="code" href="classVector.html#Vectora10">set_length</a>(num);
00552     
00553     <span class="keywordflow">if</span> (num != (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<a class="code" href="classVector.html#Vectora9">length</a>())
00554         <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__,
00555           <span class="stringliteral">"The client sent declarations and data with mismatched sizes."</span>);
00556 
00557     <a class="code" href="classVector.html#Vectora16">vec_resize</a>(num);
00558 
00559     <span class="keywordflow">for</span> (i = 0; i &lt; num; ++i) {
00560         _vec[i] = _var-&gt;<a class="code" href="classBaseType.html#Constructora6">ptr_duplicate</a>();
00561         _vec[i]-&gt;deserialize(source, dds);
00562     }
00563 
00564     <span class="keywordflow">break</span>;
00565 
00566       <span class="keywordflow">default</span>:
00567     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, <span class="stringliteral">"Unknow type!"</span>);
00568     <span class="keywordflow">break</span>;
00569     }
00570 
00571     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00572 }
00573 
00574 <span class="comment">// copy contents of VAL to the internal buffer (val to buf)</span>
00575 <span class="comment">//</span>
00576 <span class="comment">// Assume that VAL points to memory which contains, in row major order,</span>
00577 <span class="comment">// enough elements of the correct type to fill the array. For an array of a</span>
00578 <span class="comment">// cardinal type they are memcpy'd into _buf, otherwise val2buf is called</span>
00579 <span class="comment">// length() times on each successive _var-&gt;width() piece of VAL.</span>
00580 <span class="comment">//</span>
00581 <span class="comment">// Returns: The number of bytes used by the array</span>
00582 
00600 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00601"></a><a class="code" href="classVector.html#Vectora13">00601</a> <a class="code" href="classVector.html#Vectora13">Vector::val2buf</a>(<span class="keywordtype">void</span> *val, <span class="keywordtype">bool</span> reuse)
00602 {
00603     <span class="comment">// Jose Garcia</span>
00604 
00605     <span class="comment">// I *think* this method has been mainly designed to be use by read which</span>
00606     <span class="comment">// is implemented in the surrogate library. Passing NULL as a pointer to</span>
00607     <span class="comment">// this method will be an error of the creator of the surrogate library.</span>
00608     <span class="comment">// Even though I recognize the fact that some methods inside libdap++ can</span>
00609     <span class="comment">// call val2buf, I think by now no coding bugs such as missusing val2buf</span>
00610     <span class="comment">// will be in libdap++, so it will be an internal error from the</span>
00611     <span class="comment">// surrogate library.</span>
00612     <span class="keywordflow">if</span>(!val)
00613     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, 
00614               <span class="stringliteral">"The incoming pointer does not contain any data."</span>);
00615 
00616     <span class="keywordflow">switch</span> (_var-&gt;<a class="code" href="classBaseType.html#Vectora29">type</a>()) {
00617       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a6">dods_byte_c</a>:
00618       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a7">dods_int16_c</a>:
00619       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a8">dods_uint16_c</a>:
00620       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a9">dods_int32_c</a>:
00621       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a10">dods_uint32_c</a>:
00622       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a11">dods_float32_c</a>:
00623       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a12">dods_float64_c</a>: {
00624       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> array_wid = <a class="code" href="classVector.html#Vectora8">width</a>();
00625 
00626       <span class="keywordflow">if</span> (_buf &amp;&amp; !reuse) {
00627           <span class="keyword">delete</span>[] _buf; _buf = 0;
00628       }
00629 
00630       <span class="keywordflow">if</span> (!_buf) {      <span class="comment">// First time or no reuse (free'd above)</span>
00631           _buf = <span class="keyword">new</span> <span class="keywordtype">char</span>[array_wid];
00632           memcpy(_buf, val, array_wid);
00633       }
00634       <span class="keywordflow">else</span> { 
00635           memcpy(_buf, val, array_wid);
00636       }
00637 
00638       <span class="keywordflow">break</span>;
00639       }
00640 
00641       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a13">dods_str_c</a>:
00642       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a14">dods_url_c</a>: {
00643       <span class="keywordtype">unsigned</span> elem_wid = _var-&gt;<a class="code" href="classBaseType.html#Constructora30">width</a>();
00644       <span class="keywordtype">unsigned</span> len = <a class="code" href="classVector.html#Vectora9">length</a>();
00645 
00646       <a class="code" href="classVector.html#Vectora16">vec_resize</a>(len);
00647 
00648       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; len; ++i) {
00649           _vec[i] = _var-&gt;<a class="code" href="classBaseType.html#Constructora6">ptr_duplicate</a>(); <span class="comment">//changed, reza</span>
00650           _vec[i]-&gt;val2buf((<span class="keywordtype">char</span> *)val + i * elem_wid, reuse);
00651       }
00652 
00653       <span class="keywordflow">break</span>;
00654       }
00655 
00656       <span class="keywordflow">default</span>:
00657     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, <span class="stringliteral">"Vector::val2buf: bad type"</span>);
00658     <span class="keywordflow">return</span> 0;
00659     }
00660 
00661     <span class="keywordflow">return</span> <a class="code" href="classVector.html#Vectora8">width</a>();
00662 }
00663 
00664 <span class="comment">// copy contents of the internal buffer to VAL (buf to val).</span>
00665 <span class="comment">//</span>
00666 <span class="comment">// In the case of a cardinal type, assume that val points to an array large</span>
00667 <span class="comment">// enough to hold N instances of the `C' representation of the element type.</span>
00668 <span class="comment">// In the case of a non-cardinal type, assume that val points to an array</span>
00669 <span class="comment">// loarge enough to hold N instances of the DODS class used to represent that</span>
00670 <span class="comment">// type. </span>
00671 <span class="comment">//</span>
00672 <span class="comment">// Returns: The number of bytes used to store the array.</span>
00673  
00692 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00693"></a><a class="code" href="classVector.html#Vectora14">00693</a> <a class="code" href="classVector.html#Vectora14">Vector::buf2val</a>(<span class="keywordtype">void</span> **val)
00694 {
00695     <span class="comment">// Jose Garcia</span>
00696     <span class="comment">// The same comment in Vector::val2buf applies here!</span>
00697     <span class="keywordflow">if</span> (!val)
00698     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, <span class="stringliteral">"NULL pointer."</span>);
00699     
00700     <span class="keywordtype">int</span> wid = <a class="code" href="classVector.html#Vectora8">width</a>();
00701 
00702     <span class="keywordflow">switch</span> (_var-&gt;<a class="code" href="classBaseType.html#Vectora29">type</a>()) {
00703       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a6">dods_byte_c</a>:
00704       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a7">dods_int16_c</a>:
00705       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a8">dods_uint16_c</a>:
00706       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a9">dods_int32_c</a>:
00707       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a10">dods_uint32_c</a>:
00708       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a11">dods_float32_c</a>:
00709       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a12">dods_float64_c</a>:
00710     <span class="keywordflow">if</span> (!*val)
00711         *val = <span class="keyword">new</span> <span class="keywordtype">char</span>[wid];
00712 
00713     (<span class="keywordtype">void</span>)memcpy(*val, _buf, wid);
00714 
00715     <span class="keywordflow">break</span>;
00716 
00717       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a13">dods_str_c</a>:
00718       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a21a14">dods_url_c</a>: {
00719     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elem_wid = _var-&gt;<a class="code" href="classBaseType.html#Constructora30">width</a>();
00720     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len = <a class="code" href="classVector.html#Vectora9">length</a>();
00721 
00722     <span class="keywordflow">if</span> (!*val)
00723         *val = <span class="keyword">new</span> string [len]; 
00724 
00725     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; len; ++i) {
00726         <span class="keywordtype">void</span> *val_elem = (<span class="keywordtype">char</span> *)*val + i * elem_wid;
00727         _vec[i]-&gt;buf2val(&amp;val_elem);
00728     }
00729 
00730     <span class="keywordflow">break</span>;
00731       }
00732 
00733       <span class="keywordflow">default</span>:
00734     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, <span class="stringliteral">"Vector::buf2val: bad type"</span>);
00735     <span class="keywordflow">return</span> 0;
00736     }
00737 
00738     <span class="keywordflow">return</span> wid;
00739 }
00740 
00741 <span class="comment">// Given an index I into the _vec BaseType * vector, set the Ith element to</span>
00742 <span class="comment">// VAL. </span>
00743 <span class="comment">//</span>
00744 <span class="comment">// Returns: False if a type mis-match is detected, True otherwise.</span>
00745 
00764 <span class="keywordtype">void</span>
<a name="l00765"></a><a class="code" href="classVector.html#Vectora15">00765</a> <a class="code" href="classVector.html#Vectora15">Vector::set_vec</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, <a class="code" href="classBaseType.html">BaseType</a> *val)
00766 {
00767     <span class="comment">// Jose Garcia</span>
00768     <span class="comment">// This is a public method which allows users to set the elements</span>
00769     <span class="comment">// of *this* vector. Passing an invalid index, a NULL pointer or </span>
00770     <span class="comment">// missmatching the vector type are internal errors.</span>
00771     <span class="keywordflow">if</span>(i&lt;0)
00772     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, <span class="stringliteral">"Invalid data: wrong index."</span>);
00773     <span class="keywordflow">if</span>(!val)
00774     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, 
00775               <span class="stringliteral">"Invalid data: null pointer to BaseType object."</span>);
00776 
00777     <span class="keywordflow">if</span> (val-&gt;<a class="code" href="classBaseType.html#Vectora29">type</a>() != _var-&gt;<a class="code" href="classBaseType.html#Vectora29">type</a>())
00778     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, 
00779   <span class="stringliteral">"invalid data: type of incoming object does not match *this* vector type."</span>);
00780 
00781     <span class="keywordflow">if</span> (i &gt;= _vec.capacity())
00782     <a class="code" href="classVector.html#Vectora16">vec_resize</a>(i + 10);
00783     _vec[i] = val;
00784 
00785 }
00786  
00796 <span class="keywordtype">void</span>
<a name="l00797"></a><a class="code" href="classVector.html#Vectora20">00797</a> <a class="code" href="classVector.html#Vectora20">Vector::add_var</a>(<a class="code" href="classBaseType.html">BaseType</a> *v, Part)
00798 {
00799     <span class="comment">// Jose Garcia</span>
00800     <span class="comment">// By getting a copy of this object to be assigned to _var</span>
00801     <span class="comment">// we let the owner of 'v' to deallocate it as necessary.</span>
00802 
00803     _var = v-&gt;<a class="code" href="classBaseType.html#Constructora6">ptr_duplicate</a>();
00804     <a class="code" href="classBaseType.html#Vectora28">set_name</a>(v-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>());    <span class="comment">// Vector name becomes base object's name</span>
00805     _var-&gt;<a class="code" href="classBaseType.html#Vectora42">set_parent</a>(<span class="keyword">this</span>); <span class="comment">// Vector --&gt; child</span>
00806   
00807     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Vector::add_var: Added variable "</span> &lt;&lt; v &lt;&lt; <span class="stringliteral">" ("</span> \
00808     &lt;&lt; v-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>() &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; v-&gt;<a class="code" href="classBaseType.html#Vectora31">type_name</a>() &lt;&lt; <span class="stringliteral">")"</span> &lt;&lt; endl);
00809 }
00810 
00811 <span class="keywordtype">void</span>
<a name="l00812"></a><a class="code" href="classVector.html#Vectora21">00812</a> <a class="code" href="classVector.html#Vectora21">Vector::print_decl</a>(ostream &amp;os, string space, <span class="keywordtype">bool</span> print_semi,
00813           <span class="keywordtype">bool</span> constraint_info, <span class="keywordtype">bool</span> constrained)
00814 {
00815     <span class="keywordflow">if</span> (constrained &amp;&amp; !<a class="code" href="classBaseType.html#Vectora38">send_p</a>())
00816     <span class="keywordflow">return</span>;
00817 
00818     os &lt;&lt; space &lt;&lt; <a class="code" href="classBaseType.html#Vectora31">type_name</a>();
00819     <a class="code" href="classVector.html#Vectora17">var</a>()-&gt;<a class="code" href="classBaseType.html#Urla38">print_decl</a>(os, <span class="stringliteral">" "</span>, print_semi, constraint_info, constrained);
00820 }
00821 
00822 <span class="keywordtype">void</span>
<a name="l00823"></a><a class="code" href="classVector.html#Vectora22">00823</a> <a class="code" href="classVector.html#Vectora21">Vector::print_decl</a>(FILE *out, string space, <span class="keywordtype">bool</span> print_semi,
00824           <span class="keywordtype">bool</span> constraint_info, <span class="keywordtype">bool</span> constrained)
00825 {
00826     <span class="keywordflow">if</span> (constrained &amp;&amp; !<a class="code" href="classBaseType.html#Vectora38">send_p</a>())
00827     <span class="keywordflow">return</span>;
00828 
00829     fprintf( out, <span class="stringliteral">"%s%s"</span>, space.c_str(), <a class="code" href="classBaseType.html#Vectora31">type_name</a>().c_str() ) ;
00830     <a class="code" href="classVector.html#Vectora17">var</a>()-&gt;<a class="code" href="classBaseType.html#Urla38">print_decl</a>(out, <span class="stringliteral">" "</span>, print_semi, constraint_info, constrained);
00831 }
00832 
00833 <span class="keywordtype">void</span> 
<a name="l00834"></a><a class="code" href="classVector.html#Vectora23">00834</a> <a class="code" href="classVector.html#Vectora23">Vector::print_val</a>(ostream &amp;os, string space, <span class="keywordtype">bool</span> print_decl_p)
00835 {
00836     <span class="keywordflow">if</span> (print_decl_p) {
00837     <a class="code" href="classVector.html#Vectora21">print_decl</a>(os, space, <span class="keyword">false</span>);
00838     os &lt;&lt; <span class="stringliteral">" = "</span>;
00839     }
00840 
00841     os &lt;&lt; <span class="stringliteral">"{ "</span>;
00842 
00843     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00844     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l = <a class="code" href="classVector.html#Vectora9">length</a>();
00845 
00846     <span class="keywordflow">for</span> (i = 0; i &lt; l-1; ++i) {
00847     <a class="code" href="classVector.html#Vectora17">var</a>(i)-&gt;<a class="code" href="classBaseType.html#Constructora39">print_val</a>(os, <span class="stringliteral">""</span>, <span class="keyword">false</span>);
00848     os &lt;&lt; <span class="stringliteral">", "</span>;
00849     }
00850 
00851     <a class="code" href="classVector.html#Vectora17">var</a>(i)-&gt;<a class="code" href="classBaseType.html#Constructora39">print_val</a>(os, <span class="stringliteral">""</span>, <span class="keyword">false</span>);
00852 
00853     <span class="keywordflow">if</span> (print_decl_p)
00854     os &lt;&lt; <span class="stringliteral">"};"</span> &lt;&lt; endl;
00855     <span class="keywordflow">else</span>
00856     os &lt;&lt; <span class="stringliteral">"}"</span>;
00857 }
00858 
00859 <span class="keywordtype">void</span> 
<a name="l00860"></a><a class="code" href="classVector.html#Vectora24">00860</a> <a class="code" href="classVector.html#Vectora23">Vector::print_val</a>(FILE *out, string space, <span class="keywordtype">bool</span> print_decl_p)
00861 {
00862     <span class="keywordflow">if</span> (print_decl_p) {
00863     <a class="code" href="classVector.html#Vectora21">print_decl</a>(out, space, <span class="keyword">false</span>);
00864     fprintf( out, <span class="stringliteral">" = "</span> ) ;
00865     }
00866 
00867     fprintf( out, <span class="stringliteral">"{ "</span> ) ;
00868 
00869     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00870     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l = <a class="code" href="classVector.html#Vectora9">length</a>();
00871 
00872     <span class="keywordflow">for</span> (i = 0; i &lt; l-1; ++i) {
00873     <a class="code" href="classVector.html#Vectora17">var</a>(i)-&gt;<a class="code" href="classBaseType.html#Constructora39">print_val</a>(out, <span class="stringliteral">""</span>, <span class="keyword">false</span>);
00874     fprintf( out, <span class="stringliteral">", "</span> ) ;
00875     }
00876 
00877     <a class="code" href="classVector.html#Vectora17">var</a>(i)-&gt;<a class="code" href="classBaseType.html#Constructora39">print_val</a>(out, <span class="stringliteral">""</span>, <span class="keyword">false</span>);
00878 
00879     <span class="keywordflow">if</span> (print_decl_p)
00880     fprintf( out, <span class="stringliteral">"};\n"</span> ) ;
00881     <span class="keywordflow">else</span>
00882     fprintf( out, <span class="stringliteral">"}"</span> ) ;
00883 }
00884 
00885 <span class="keywordtype">bool</span>
<a name="l00886"></a><a class="code" href="classVector.html#Vectora25">00886</a> <a class="code" href="classVector.html#Vectora25">Vector::check_semantics</a>(string &amp;msg, <span class="keywordtype">bool</span>) 
00887 {
00888     <span class="keywordflow">return</span> <a class="code" href="classBaseType.html#Urla40">BaseType::check_semantics</a>(msg);
00889 }
00890 
00891 <span class="comment">// $Log: Vector_8cc-source.html,v $
00891 <span class="comment">// Revision 1.4  2004/02/05 06:51:16  jimg
00891 <span class="comment">// Added/update.
00891 <span class="comment">//</span>
00892 <span class="comment">// Revision 1.45.2.6  2003/09/28 20:57:22  rmorris</span>
00893 <span class="comment">// Discontinued use of XDR_PROC typedef, using xdrproc_t instead - a</span>
00894 <span class="comment">// define from the xdr portion of the rpc library.</span>
00895 <span class="comment">//</span>
00896 <span class="comment">// Revision 1.45.2.5  2003/09/06 22:58:06  jimg</span>
00897 <span class="comment">// Updated the documentation. Now uses the XDR_PROC typedef.</span>
00898 <span class="comment">//</span>
00899 <span class="comment">// Revision 1.45.2.4  2003/08/18 00:31:45  rmorris</span>
00900 <span class="comment">// Removed casting xdr_* routines to bool.  bool is size of 1</span>
00901 <span class="comment">// under win32 yet size of 4 under unix.  This is cleanup in regards</span>
00902 <span class="comment">// to win32 and 'performance warnings' at compile time.</span>
00903 <span class="comment">//</span>
00904 <span class="comment">// Revision 1.45.2.3  2003/08/17 01:34:26  rmorris</span>
00905 <span class="comment">// Account for trivial differences to scope of variables in case</span>
00906 <span class="comment">// statements under win32.  It's not in the case block, but the enclosing</span>
00907 <span class="comment">// scope.</span>
00908 <span class="comment">//</span>
00909 <span class="comment">// Revision 1.45.2.2  2003/07/25 06:04:28  jimg</span>
00910 <span class="comment">// Refactored the code so that DDS:send() is now incorporated into</span>
00911 <span class="comment">// DODSFilter::send_data(). The old DDS::send() is still there but is</span>
00912 <span class="comment">// depracated.</span>
00913 <span class="comment">// Added 'smart timeouts' to all the variable classes. This means that</span>
00914 <span class="comment">// the new server timeouts are active only for the data read and CE</span>
00915 <span class="comment">// evaluation. This went inthe BaseType::serialize() methods because it</span>
00916 <span class="comment">// needed to time both the read() calls and the dds::eval() calls.</span>
00917 <span class="comment">//</span>
00918 <span class="comment">// Revision 1.45.2.1  2003/07/18 01:07:15  jimg</span>
00919 <span class="comment">// I fixed up the documentation.</span>
00920 <span class="comment">//</span>
00921 <span class="comment">// Revision 1.45  2003/04/22 19:40:28  jimg</span>
00922 <span class="comment">// Merged with 3.3.1.</span>
00923 <span class="comment">//</span>
00924 <span class="comment">// Revision 1.44  2003/02/21 00:14:25  jimg</span>
00925 <span class="comment">// Repaired copyright.</span>
00926 <span class="comment">//</span>
00927 <span class="comment">// Revision 1.43.2.1  2003/02/21 00:10:07  jimg</span>
00928 <span class="comment">// Repaired copyright.</span>
00929 <span class="comment">//</span>
00930 <span class="comment">// Revision 1.43  2003/01/23 00:22:24  jimg</span>
00931 <span class="comment">// Updated the copyright notice; this implementation of the DAP is</span>
00932 <span class="comment">// copyrighted by OPeNDAP, Inc.</span>
00933 <span class="comment">//</span>
00934 <span class="comment">// Revision 1.42  2003/01/10 19:46:40  jimg</span>
00935 <span class="comment">// Merged with code tagged release-3-2-10 on the release-3-2 branch. In many</span>
00936 <span class="comment">// cases files were added on that branch (so they appear on the trunk for</span>
00937 <span class="comment">// the first time).</span>
00938 <span class="comment">//</span>
00939 <span class="comment">// Revision 1.35.4.12  2002/12/27 19:34:42  jimg</span>
00940 <span class="comment">// Modified the var() methods so that www2id() is called before looking</span>
00941 <span class="comment">// up identifier names. See bug 563.</span>
00942 <span class="comment">//</span>
00943 <span class="comment">// Revision 1.35.4.11  2002/12/17 22:35:03  pwest</span>
00944 <span class="comment">// Added and updated methods using stdio. Deprecated methods using iostream.</span>
00945 <span class="comment">//</span>
00946 <span class="comment">// Revision 1.35.4.10  2002/08/08 06:54:57  jimg</span>
00947 <span class="comment">// Changes for thread-safety. In many cases I found ugly places at the</span>
00948 <span class="comment">// tops of files while looking for globals, et c., and I fixed them up</span>
00949 <span class="comment">// (hopefully making them easier to read, ...). Only the files RCReader.cc</span>
00950 <span class="comment">// and usage.cc actually use pthreads synchronization functions. In other</span>
00951 <span class="comment">// cases I removed static objects where they were used for supposed</span>
00952 <span class="comment">// improvements in efficiency which had never actually been verifiied (and</span>
00953 <span class="comment">// which looked dubious).</span>
00954 <span class="comment">//</span>
00955 <span class="comment">// Revision 1.41  2002/06/18 15:36:24  tom</span>
00956 <span class="comment">// Moved comments and edited to accommodate doxygen documentation-generator.</span>
00957 <span class="comment">//</span>
00958 <span class="comment">// Revision 1.40  2002/06/03 22:21:15  jimg</span>
00959 <span class="comment">// Merged with release-3-2-9</span>
00960 <span class="comment">//</span>
00961 <span class="comment">// Revision 1.35.4.9  2002/05/22 16:57:51  jimg</span>
00962 <span class="comment">// I modified the `data type classes' so that they do not need to be</span>
00963 <span class="comment">// subclassed for clients. It might be the case that, for a complex client,</span>
00964 <span class="comment">// subclassing is still the best way to go, but you're not required to do</span>
00965 <span class="comment">// it anymore.</span>
00966 <span class="comment">//</span>
00967 <span class="comment">// Revision 1.35.4.8  2002/01/30 18:52:26  jimg</span>
00968 <span class="comment">// Vector now throws an InternalErr object when a DataDDS arrives and the amount</span>
00969 <span class="comment">// of data differs from the declarations. Note that List (a subclass of Vector)</span>
00970 <span class="comment">// does not include any size info, so we assume that the size information in the</span>
00971 <span class="comment">// binary object is correct.</span>
00972 <span class="comment">//</span>
00973 <span class="comment">// Revision 1.35.4.7  2001/10/30 06:55:45  rmorris</span>
00974 <span class="comment">// Win32 porting changes.  Brings core win32 port up-to-date.</span>
00975 <span class="comment">//</span>
00976 <span class="comment">// Revision 1.39  2001/10/14 01:28:38  jimg</span>
00977 <span class="comment">// Merged with release-3-2-8.</span>
00978 <span class="comment">//</span>
00979 <span class="comment">// Revision 1.35.4.6  2001/10/02 17:01:52  jimg</span>
00980 <span class="comment">// Made the behavior of serialize and deserialize uniform. Both methods now</span>
00981 <span class="comment">// use Error exceptions to signal problems with network I/O and InternalErr</span>
00982 <span class="comment">// exceptions to signal other problems. The return codes, always true for</span>
00983 <span class="comment">// serialize and always false for deserialize, are now meaningless. However,</span>
00984 <span class="comment">// by always returning a code that means OK, old code should continue to work.</span>
00985 <span class="comment">//</span>
00986 <span class="comment">// Revision 1.38  2001/09/28 17:50:07  jimg</span>
00987 <span class="comment">// Merged with 3.2.7.</span>
00988 <span class="comment">//</span>
00989 <span class="comment">// Revision 1.35.4.5  2001/09/07 00:38:35  jimg</span>
00990 <span class="comment">// Sequence::deserialize(...) now reads all the sequence values at once.</span>
00991 <span class="comment">// Its call semantics are the same as the other classes' versions. Values</span>
00992 <span class="comment">// are stored in the Sequence object using a vector&lt;BaseType *&gt; for each</span>
00993 <span class="comment">// row (those are themselves held in a vector). Three new accessor methods</span>
00994 <span class="comment">// have been added to Sequence (row_value() and two versions of var_value()).</span>
00995 <span class="comment">// BaseType::deserialize(...) now always returns true. This matches with the</span>
00996 <span class="comment">// expectations of most client code (the seqeunce version returned false</span>
00997 <span class="comment">// when it was done reading, but all the calls for sequences must be changed</span>
00998 <span class="comment">// anyway). If an XDR error is found, deserialize throws InternalErr.</span>
00999 <span class="comment">//</span>
01000 <span class="comment">// Revision 1.37  2001/08/24 17:46:22  jimg</span>
01001 <span class="comment">// Resolved conflicts from the merge of release 3.2.6</span>
01002 <span class="comment">//</span>
01003 <span class="comment">// Revision 1.35.4.4  2001/08/18 00:13:21  jimg</span>
01004 <span class="comment">// Removed WIN32 compile guards from using statements.</span>
01005 <span class="comment">//</span>
01006 <span class="comment">// Revision 1.35.4.3  2001/07/28 01:10:42  jimg</span>
01007 <span class="comment">// Some of the numeric type classes did not have copy ctors or operator=.</span>
01008 <span class="comment">// I added those where they were needed.</span>
01009 <span class="comment">// In every place where delete (or delete []) was called, I set the pointer</span>
01010 <span class="comment">// just deleted to zero. Thus if for some reason delete is called again</span>
01011 <span class="comment">// before new memory is allocated there won't be a mysterious crash. This is</span>
01012 <span class="comment">// just good form when using delete.</span>
01013 <span class="comment">// I added calls to www2id and id2www where appropriate. The DAP now handles</span>
01014 <span class="comment">// making sure that names are escaped and unescaped as needed. Connect is</span>
01015 <span class="comment">// set to handle CEs that contain names as they are in the dataset (see the</span>
01016 <span class="comment">// comments/Log there). Servers should not handle escaping or unescaping</span>
01017 <span class="comment">// characters on their own.</span>
01018 <span class="comment">//</span>
01019 <span class="comment">// Revision 1.36  2001/06/15 23:49:03  jimg</span>
01020 <span class="comment">// Merged with release-3-2-4.</span>
01021 <span class="comment">//</span>
01022 <span class="comment">// Revision 1.35.4.2  2001/06/05 06:49:19  jimg</span>
01023 <span class="comment">// Added the Constructor class which is to Structures, Sequences and Grids</span>
01024 <span class="comment">// what Vector is to Arrays and Lists. This should be used in future</span>
01025 <span class="comment">// refactorings (I thought it was going to be used for the back pointers).</span>
01026 <span class="comment">// Introduced back pointers so children can refer to their parents in</span>
01027 <span class="comment">// hierarchies of variables.</span>
01028 <span class="comment">// Added to Sequence methods to tell if a child sequence is done</span>
01029 <span class="comment">// deserializing its data.</span>
01030 <span class="comment">// Fixed the operator=() and copy ctors; removed redundency from</span>
01031 <span class="comment">// _duplicate().</span>
01032 <span class="comment">// Changed the way serialize and deserialize work for sequences. Now SOI and</span>
01033 <span class="comment">// EOS markers are written for every `level' of a nested Sequence. This</span>
01034 <span class="comment">// should fixed nested Sequences. There is still considerable work to do</span>
01035 <span class="comment">// for these to work in all cases.</span>
01036 <span class="comment">//</span>
01037 <span class="comment">// Revision 1.35.4.1  2001/05/23 16:23:17  jimg</span>
01038 <span class="comment">// Replaced errors written to cerr with Error exceptions.</span>
01039 <span class="comment">// Removed some WIN32 specific code that could be generalized for both Win32 and</span>
01040 <span class="comment">// Unix.</span>
01041 <span class="comment">//</span>
01042 <span class="comment">// Revision 1.35  2000/10/06 01:26:05  jimg</span>
01043 <span class="comment">// Changed the way serialize() calls read(). The status from read() is</span>
01044 <span class="comment">// returned by the Structure and Sequence serialize() methods; ignored by</span>
01045 <span class="comment">// all others. Any exceptions thrown by read() are caught and discarded.</span>
01046 <span class="comment">// serialize() returns false if read() throws an exception. This should</span>
01047 <span class="comment">// be fixed once all the servers build using the new read() definition.</span>
01048 <span class="comment">//</span>
01049 <span class="comment">// Revision 1.34  2000/10/02 18:48:59  jimg</span>
01050 <span class="comment">// Changed type of num in the serialize method to int</span>
01051 <span class="comment">//</span>
01052 <span class="comment">// Revision 1.33  2000/09/22 02:17:22  jimg</span>
01053 <span class="comment">// Rearranged source files so that the CVS logs appear at the end rather than</span>
01054 <span class="comment">// the start. Also made the ifdef guard symbols use the same naming scheme and</span>
01055 <span class="comment">// wrapped headers included in other headers in those guard symbols (to cut</span>
01056 <span class="comment">// down on extraneous file processing - See Lakos).</span>
01057 <span class="comment">//</span>
01058 <span class="comment">// Revision 1.32  2000/09/21 16:22:09  jimg</span>
01059 <span class="comment">// Merged changes from Jose Garcia that add exceptions to the software.</span>
01060 <span class="comment">// Many methods that returned error codes now throw exectptions. There are</span>
01061 <span class="comment">// two classes which are thrown by the software, Error and InternalErr.</span>
01062 <span class="comment">// InternalErr is used to report errors within the library or errors using</span>
01063 <span class="comment">// the library. Error is used to reprot all other errors. Since InternalErr</span>
01064 <span class="comment">// is a subclass of Error, programs need only to catch Error.</span>
01065 <span class="comment">//</span>
01066 <span class="comment">// Revision 1.31  2000/07/09 22:05:36  rmorris</span>
01067 <span class="comment">// Changes to increase portability, minimize ifdef's for win32 and account</span>
01068 <span class="comment">// for differences in the iostreams implementations.</span>
01069 <span class="comment">//</span>
01070 <span class="comment">// Revision 1.30  2000/06/16 18:15:00  jimg</span>
01071 <span class="comment">// Merged with 3.1.7</span>
01072 <span class="comment">//</span>
01073 <span class="comment">// Revision 1.27.6.2  2000/06/14 16:59:01  jimg</span>
01074 <span class="comment">// Added instrumentation for the dtor.</span>
01075 <span class="comment">//</span>
01076 <span class="comment">// Revision 1.27.6.1  2000/06/07 23:08:31  jimg</span>
01077 <span class="comment">// Added code to explicitly delete BaseType *s in _vec.</span>
01078 <span class="comment">// Also tried recoding using DLList, but that didn't fix the problem I was</span>
01079 <span class="comment">// after---fixed in the client code but decided to leave this is with #if 0</span>
01080 <span class="comment">// just in case.</span>
01081 <span class="comment">//</span>
01082 <span class="comment">// Revision 1.29  2000/06/07 18:06:59  jimg</span>
01083 <span class="comment">// Merged the pc port branch</span>
01084 <span class="comment">//</span>
01085 <span class="comment">// Revision 1.28.8.1  2000/06/02 18:29:32  rmorris</span>
01086 <span class="comment">// Mod's for port to Win32.</span>
01087 <span class="comment">//</span>
01088 <span class="comment">// Revision 1.28.2.2  2000/02/17 05:03:16  jimg</span>
01089 <span class="comment">// Added file and line number information to calls to InternalErr.</span>
01090 <span class="comment">// Resolved compile-time problems with read due to a change in its</span>
01091 <span class="comment">// parameter list given that errors are now reported using exceptions.</span>
01092 <span class="comment">//</span>
01093 <span class="comment">// Revision 1.28.2.1  2000/01/28 22:14:07  jgarcia</span>
01094 <span class="comment">// Added exception handling and modify add_var to get a copy of the object</span>
01095 <span class="comment">//</span>
01096 <span class="comment">// Revision 1.28  2000/01/05 22:37:18  jimg</span>
01097 <span class="comment">// Added a comment about the odd `protocol' for sending array/list lengths twice</span>
01098 <span class="comment">// for arrays/lists of simple types.</span>
01099 <span class="comment">// Removed some cruft.</span>
01100 <span class="comment">//</span>
01101 <span class="comment">// Revision 1.27  1999/05/04 19:47:23  jimg</span>
01102 <span class="comment">// Fixed copyright statements. Removed more of the GNU classes.</span>
01103 <span class="comment">//</span>
01104 <span class="comment">// Revision 1.26  1999/04/29 02:29:34  jimg</span>
01105 <span class="comment">// Merge of no-gnu branch</span>
01106 <span class="comment">//</span>
01107 <span class="comment">// Revision 1.25  1999/03/24 23:34:49  jimg</span>
01108 <span class="comment">// Added support for the new Int16, UInt16 and Float32 types.</span>
01109 <span class="comment">//</span>
01110 <span class="comment">// Revision 1.24  1998/09/17 17:05:46  jimg</span>
01111 <span class="comment">// Changes for the new variable lookup scheme. Fields of ctor types no longer</span>
01112 <span class="comment">// need to be fully qualified. my.thing.f1 can now be named `f1' in a CE. Note</span>
01113 <span class="comment">// that if there are two `f1's in a dataset, the first will be silently used;</span>
01114 <span class="comment">// There's no warning about the situation. The new code in the var member</span>
01115 <span class="comment">// function passes a stack of BaseType pointers so that the projection</span>
01116 <span class="comment">// information (send_p field) can be set properly.</span>
01117 <span class="comment">//</span>
01118 <span class="comment">// Revision 1.23.2.2  1999/02/05 09:32:35  jimg</span>
01119 <span class="comment">// Fixed __unused__ so that it not longer clashes with Red Hat 5.2 inlined</span>
01120 <span class="comment">// math code. </span>
01121 <span class="comment">//</span>
01122 <span class="comment">// Revision 1.23.2.1  1999/02/02 21:57:04  jimg</span>
01123 <span class="comment">// String to string version</span>
01124 <span class="comment">//</span>
01125 <span class="comment">// Revision 1.23  1998/08/06 16:22:38  jimg</span>
01126 <span class="comment">// Fixed the misuse of the read(...) member function. See Grid.c (from jeh).</span>
01127 <span class="comment">//</span>
01128 <span class="comment">// Revision 1.22  1998/03/17 17:51:06  jimg</span>
01129 <span class="comment">// Added an implementation of element_count().</span>
01130 <span class="comment">//</span>
01131 <span class="comment">// Revision 1.21  1998/02/05 20:13:58  jimg</span>
01132 <span class="comment">// DODS now compiles with gcc 2.8.x</span>
01133 <span class="comment">//</span>
01134 <span class="comment">// Revision 1.20  1997/12/31 21:48:12  jimg</span>
01135 <span class="comment">// Enclosed print_basetype_pointer() function in #if DODS_DEBUG == 1 #endif</span>
01136 <span class="comment">// to stop compiler warnings about it being unused.</span>
01137 <span class="comment">//</span>
01138 <span class="comment">// Revision 1.19  1997/12/15 22:33:00  jimg</span>
01139 <span class="comment">// Added type checking set_vec. If the type of the element to include in the</span>
01140 <span class="comment">// vector does not match the vector's type, set_vec() returns false.</span>
01141 <span class="comment">//</span>
01142 <span class="comment">// Revision 1.18  1997/09/22 22:37:53  jimg</span>
01143 <span class="comment">// Fixed a bug in vec_resize.</span>
01144 <span class="comment">//</span>
01145 <span class="comment">// Revision 1.17  1997/03/08 19:02:11  jimg</span>
01146 <span class="comment">// Changed default param to check_semantics() from  to String()</span>
01147 <span class="comment">// and removed the default from the argument list in the mfunc definition</span>
01148 <span class="comment">//</span>
01149 <span class="comment">// Revision 1.16  1997/02/28 01:28:03  jimg</span>
01150 <span class="comment">// Changed check_semantics() so that it now returns error messages in a String</span>
01151 <span class="comment">// object (passed by reference).</span>
01152 <span class="comment">//</span>
01153 <span class="comment">// Revision 1.15  1996/12/02 18:22:08  jimg</span>
01154 <span class="comment">// Added cases for uint32 to various parts of Vector.</span>
01155 <span class="comment">//</span>
01156 <span class="comment">// Revision 1.14  1996/11/13 19:23:10  jimg</span>
01157 <span class="comment">// Fixed debugging.</span>
01158 <span class="comment">//</span>
01159 <span class="comment">// Revision 1.13  1996/08/13 18:39:25  jimg</span>
01160 <span class="comment">// Added not_used to definition of char rcsid[].</span>
01161 <span class="comment">// Fixed int -vs- unsigned int discrepancies.</span>
01162 <span class="comment">//</span>
01163 <span class="comment">// Revision 1.12  1996/06/04 21:33:50  jimg</span>
01164 <span class="comment">// Multiple connections are now possible. It is now possible to open several</span>
01165 <span class="comment">// URLs at the same time and read from them in a round-robin fashion. To do</span>
01166 <span class="comment">// this I added data source and sink parameters to the serialize and</span>
01167 <span class="comment">// deserialize mfuncs. Connect was also modified so that it manages the data</span>
01168 <span class="comment">// source `object' (which is just an XDR pointer).</span>
01169 <span class="comment">//</span>
01170 <span class="comment">// Revision 1.11  1996/05/31 23:30:42  jimg</span>
01171 <span class="comment">// Updated copyright notice.</span>
01172 <span class="comment">//</span>
01173 <span class="comment">// Revision 1.10  1996/05/30 17:14:56  jimg</span>
01174 <span class="comment">// Fixed the allocation of vectors of DODS variable objects; use the</span>
01175 <span class="comment">// ptr_duplicate member function instead of the copy ctor in val2buf().</span>
01176 <span class="comment">// Fixed allocation of vector of String in buf2val(). From Reza.</span>
01177 <span class="comment">//</span>
01178 <span class="comment">// Revision 1.9  1996/05/29 22:08:53  jimg</span>
01179 <span class="comment">// Made changes necessary to support CEs that return the value of a function</span>
01180 <span class="comment">// instead of the value of a variable. This was done so that it would be</span>
01181 <span class="comment">// possible to translate Sequences into Arrays without first reading the</span>
01182 <span class="comment">// entire sequence over the network.</span>
01183 <span class="comment">//</span>
01184 <span class="comment">// Revision 1.8  1996/05/16 22:49:53  jimg</span>
01185 <span class="comment">// Dan's changes for version 2.0. Added a parameter to read that returns</span>
01186 <span class="comment">// an error code so that EOF can be distinguished from an actual error when</span>
01187 <span class="comment">// reading sequences. This *may* be replaced by an error member function</span>
01188 <span class="comment">// in the future.</span>
01189 <span class="comment">//</span>
01190 <span class="comment">// Revision 1.7  1996/05/14 15:38:46  jimg</span>
01191 <span class="comment">// These changes have already been checked in once before. However, I</span>
01192 <span class="comment">// corrupted the source repository and restored it from a 5/9/96 backup</span>
01193 <span class="comment">// tape. The previous version's log entry should cover the changes.</span>
01194 <span class="comment">//</span>
01195 <span class="comment">// Revision 1.6  1996/04/05 00:22:09  jimg</span>
01196 <span class="comment">// Compiled with g++ -Wall and fixed various warnings.</span>
01197 <span class="comment">//</span>
01198 <span class="comment">// Revision 1.5  1996/03/05 01:09:09  jimg</span>
01199 <span class="comment">// Added to the Vector dtor (now the BaseType * vector is properly deleted.</span>
01200 <span class="comment">// Created the vec_resize() member function.</span>
01201 <span class="comment">// Modified serialize() member function so that the ce_eval flag is used.</span>
01202 <span class="comment">//</span>
01203 <span class="comment">// Revision 1.4  1996/02/01 17:43:14  jimg</span>
01204 <span class="comment">// Added support for lists as operands in constraint expressions.</span>
01205 <span class="comment">//</span>
01206 <span class="comment">// Revision 1.3  1995/12/09  01:07:33  jimg</span>
01207 <span class="comment">// Added changes so that relational operators will work properly for all the</span>
01208 <span class="comment">// datatypes (including Sequences). The relational ops are evaluated in</span>
01209 <span class="comment">// DDS::eval_constraint() after being parsed by DDS::parse_constraint().</span>
01210 <span class="comment">//</span>
01211 <span class="comment">// Revision 1.2  1995/12/06  19:52:26  jimg</span>
01212 <span class="comment">// Modified print_decl() so that the declaration is printed only if the</span>
01213 <span class="comment">// variable is selected.</span>
01214 <span class="comment">//</span>
01215 <span class="comment">// Revision 1.1  1995/11/22  22:30:18  jimg</span>
01216 <span class="comment">// Created.</span>
01217 <span class="comment">//</span>
01218 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Feb 4 23:43:05 2004 for libdap++ by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
