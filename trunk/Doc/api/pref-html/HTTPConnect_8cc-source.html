<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libdap++: HTTPConnect.cc Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>HTTPConnect.cc</h1><a href="HTTPConnect_8cc.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00002 <span class="comment">// -*- mode: c++; c-basic-offset:4 -*-</span>
00003 
00004 <span class="comment">// This file is part of libdap, A C++ implementation of the OPeNDAP Data</span>
00005 <span class="comment">// Access Protocol.</span>
00006 
00007 <span class="comment">// Copyright (c) 2002,2003 OPeNDAP, Inc.</span>
00008 <span class="comment">// Author: James Gallagher &lt;jgallagher@opendap.org&gt;</span>
00009 <span class="comment">//</span>
00010 <span class="comment">// This library is free software; you can redistribute it and/or</span>
00011 <span class="comment">// modify it under the terms of the GNU Lesser General Public</span>
00012 <span class="comment">// License as published by the Free Software Foundation; either</span>
00013 <span class="comment">// version 2.1 of the License, or (at your option) any later version.</span>
00014 <span class="comment">// </span>
00015 <span class="comment">// This library is distributed in the hope that it will be useful,</span>
00016 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00017 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00018 <span class="comment">// Lesser General Public License for more details.</span>
00019 <span class="comment">// </span>
00020 <span class="comment">// You should have received a copy of the GNU Lesser General Public</span>
00021 <span class="comment">// License along with this library; if not, write to the Free Software</span>
00022 <span class="comment">// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00023 <span class="comment">//</span>
00024 <span class="comment">// You can contact OPeNDAP, Inc. at PO Box 112, Saunderstown, RI. 02874-0112.</span>
00025  
00026 <span class="preprocessor">#ifdef __GNUG__</span>
00027 <span class="preprocessor"></span><span class="preprocessor">#pragma implementation</span>
00028 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00029 <span class="preprocessor"></span>
00030 <span class="preprocessor">#include "<a class="code" href="config__dap_8h.html">config_dap.h</a>"</span>
00031 
00032 <span class="keyword">static</span> <span class="keywordtype">char</span> rcsid[] <a class="code" href="config__dap_8h.html#a49">not_used</a> =
00033     { <span class="stringliteral">"$Id$"</span> };
00034 
00035 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00036 
00037 <span class="preprocessor">#ifdef WIN32</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#include &lt;io.h&gt;</span>
00039 <span class="preprocessor">#else</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#include &lt;unistd.h&gt;</span>
00041 <span class="preprocessor">#endif</span>
00042 <span class="preprocessor"></span>
00043 <span class="preprocessor">#include &lt;string&gt;</span>
00044 <span class="preprocessor">#include &lt;vector&gt;</span>
00045 <span class="preprocessor">#include &lt;functional&gt;</span>
00046 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00047 <span class="preprocessor">#include &lt;sstream&gt;</span>
00048 <span class="preprocessor">#include &lt;iterator&gt;</span>
00049 
00050 <span class="preprocessor">#include "<a class="code" href="debug_8h.html">debug.h</a>"</span>
00051 <span class="preprocessor">#include "Regex.h"</span>
00052 <span class="preprocessor">#include "<a class="code" href="HTTPConnect_8h.html">HTTPConnect.h</a>"</span>
00053 <span class="preprocessor">#include "<a class="code" href="HTTPCache_8h.html">HTTPCache.h</a>"</span>
00054 <span class="preprocessor">#include "<a class="code" href="RCReader_8h.html">RCReader.h</a>"</span>
00055 <span class="preprocessor">#include "<a class="code" href="HTTPResponse_8h.html">HTTPResponse.h</a>"</span>
00056 <span class="preprocessor">#include "<a class="code" href="HTTPCacheResponse_8h.html">HTTPCacheResponse.h</a>"</span>
00057 
00058 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00059 
00060 <span class="comment">// These global variables are not MT-Safe, but I'm leaving them as is because</span>
00061 <span class="comment">// they are used only for debugging (set them in a debugger like gdb or ddd).</span>
00062 <span class="comment">// They are not static because I *believe* that many debuggers cannot access</span>
00063 <span class="comment">// static variables. 08/07/02 jhrg</span>
00064 
00065 <span class="comment">// Set this to 1 to turn on libcurl's verbose mode (for debugging).</span>
<a name="l00066"></a><a class="code" href="HTTPConnect_8cc.html#a1">00066</a> <span class="keywordtype">int</span> <a class="code" href="HTTPConnect_8cc.html#a1">www_trace</a> = 0;
00067 
00068 <span class="comment">// Keep the temporary files; useful for debugging.</span>
<a name="l00069"></a><a class="code" href="HTTPConnect_8cc.html#a2">00069</a> <span class="keywordtype">int</span> <a class="code" href="geturl_8cc.html#a2">dods_keep_temps</a> = 0;
00070 
00075 <span class="keyword">class </span>ParseHeader : <span class="keyword">public</span> unary_function&lt;const string &amp;, void&gt; {
00076     <a class="code" href="ObjectType_8h.html#a6">ObjectType</a> type;        <span class="comment">// What type of object is in the stream?</span>
00077     string server;      <span class="comment">// Server's version string.</span>
00078 
00079 <span class="keyword">public</span>:
00080     ParseHeader() :type(<a class="code" href="ObjectType_8h.html#a6a0">unknown_type</a>), server(<span class="stringliteral">"dods/0.0"</span>) { }
00081 
00082     <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> string &amp;header) {
00083     std::istringstream line(header);
00084 
00085     string name;
00086     line &gt;&gt; name;
00087     <a class="code" href="util_8cc.html#a12">downcase</a>(name);
00088     <span class="keywordflow">if</span> (name == <span class="stringliteral">"content-description:"</span>) {
00089         string value; 
00090         line &gt;&gt; value;
00091         <a class="code" href="util_8cc.html#a12">downcase</a>(value);
00092         <a class="code" href="debug_8h.html#a3">DBG2</a>(cout &lt;&lt; name &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; value &lt;&lt; endl);
00093         type = <a class="code" href="HTTPConnect_8h.html#a0">get_type</a>(value);
00094     }
00095     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (name == <span class="stringliteral">"xdods-server:"</span>) {
00096         string value; 
00097         line &gt;&gt; value;
00098         <a class="code" href="util_8cc.html#a12">downcase</a>(value);
00099         <a class="code" href="debug_8h.html#a3">DBG2</a>(cout &lt;&lt; name &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; value &lt;&lt; endl);
00100         server = value;
00101     }
00102     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (server == <span class="stringliteral">"dods/0.0"</span> &amp;&amp; name == <span class="stringliteral">"server:"</span>) {
00103         string value; 
00104         line &gt;&gt; value;
00105         <a class="code" href="util_8cc.html#a12">downcase</a>(value);
00106         <a class="code" href="debug_8h.html#a3">DBG2</a>(cout &lt;&lt; name &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; value &lt;&lt; endl);
00107         server = value;
00108     }
00109     }
00110 
00111     <a class="code" href="ObjectType_8h.html#a6">ObjectType</a> get_object_type() {
00112     <span class="keywordflow">return</span> type;
00113     }
00114     
00115     string get_server() {
00116     <span class="keywordflow">return</span> server;
00117     }
00118 };
00119 
00136 <span class="keyword">static</span> size_t 
00137 save_raw_http_headers(<span class="keywordtype">void</span> *ptr, size_t size, size_t nmemb, <span class="keywordtype">void</span> *resp_hdrs)
00138 {
00139     <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"Inside the header parser."</span> &lt;&lt; endl);
00140     vector&lt;string&gt; *hdrs = static_cast&lt;vector&lt;string&gt; *&gt;(resp_hdrs);
00141 
00142     <span class="comment">// Grab the header, minus the trailing newline.</span>
00143     string complete_line(static_cast&lt;char *&gt;(ptr), size * nmemb - 1);
00144 
00145     <span class="comment">// Store all non-empty headers that are not HTTP status codes</span>
00146     <span class="keywordflow">if</span> (complete_line != <span class="stringliteral">""</span> &amp;&amp; complete_line.find(<span class="stringliteral">"HTTP"</span>) == string::npos) {
00147     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Header line: "</span> &lt;&lt; complete_line &lt;&lt; endl);
00148     hdrs-&gt;push_back(complete_line);
00149     }
00150 
00151     <span class="keywordflow">return</span> size * nmemb;
00152 }
00153 
00155 <span class="keyword">static</span> <span class="keywordtype">int</span>
00156 curl_debug(CURL *curl, curl_infotype info, <span class="keywordtype">char</span> *msg, size_t size, <span class="keywordtype">void</span>  *data)
00157 {
00158     string message(msg, size);
00159 
00160     <span class="keywordflow">switch</span> (info) {
00161       <span class="keywordflow">case</span> CURLINFO_TEXT:
00162     cerr &lt;&lt; <span class="stringliteral">"Text: "</span> &lt;&lt; message; <span class="keywordflow">break</span>;
00163       <span class="keywordflow">case</span> CURLINFO_HEADER_IN:
00164     cerr &lt;&lt; <span class="stringliteral">"Header in: "</span> &lt;&lt; message; <span class="keywordflow">break</span>;
00165       <span class="keywordflow">case</span> CURLINFO_HEADER_OUT:
00166     cerr &lt;&lt; <span class="stringliteral">"Header out: "</span> &lt;&lt; message; <span class="keywordflow">break</span>;
00167       <span class="keywordflow">case</span> CURLINFO_DATA_IN:
00168     cerr &lt;&lt; <span class="stringliteral">"Data in: "</span> &lt;&lt; message; <span class="keywordflow">break</span>;
00169       <span class="keywordflow">case</span> CURLINFO_DATA_OUT:
00170     cerr &lt;&lt; <span class="stringliteral">"Data out: "</span> &lt;&lt; message; <span class="keywordflow">break</span>;
00171       <span class="keywordflow">case</span> CURLINFO_END:
00172     cerr &lt;&lt; <span class="stringliteral">"End: "</span> &lt;&lt; message; <span class="keywordflow">break</span>;
00173     }
00174     <span class="keywordflow">return</span> 0;
00175 }
00176 
00180 <span class="keywordtype">void</span> 
00181 HTTPConnect::www_lib_init() <span class="keywordflow">throw</span>(<a class="code" href="classError.html">Error</a>, <a class="code" href="classInternalErr.html">InternalErr</a>)
00182 {
00183     d_curl = curl_easy_init();
00184     <span class="keywordflow">if</span> (!d_curl)
00185     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, <span class="stringliteral">"Could not initialize libcurl."</span>);
00186 
00187     <span class="comment">// Now set options that will remain constant for the duration of this</span>
00188     <span class="comment">// CURL object.</span>
00189 
00190     <span class="comment">// We must set the proxy host (it's really a host, if a URL is given, the</span>
00191     <span class="comment">// protocol part is ignored by libcurl).</span>
00192     <span class="keywordflow">if</span> (d_rcr-&gt;get_proxy_server_host_url() != <span class="stringliteral">""</span>) {
00193     string proxy = d_rcr-&gt;get_proxy_server_host_url();
00194     curl_easy_setopt(d_curl, CURLOPT_PROXY, proxy.c_str());
00195     <span class="comment">// If the port number is not part of the proxy server host, then use</span>
00196     <span class="comment">// the protocol to divine a default port number. Support http, https</span>
00197     <span class="comment">// and ftp for now. If protocol is not one of those, throw Error.</span>
00198     Regex find_port(<span class="stringliteral">"^.*:[0-9]+$"</span>);
00199     <span class="keywordtype">int</span> index=0, matchlen;
00200     <span class="keywordflow">if</span> (find_port.search(proxy.c_str(), proxy.length(), matchlen, index)
00201         == -1) {
00202         string protocol = d_rcr-&gt;get_proxy_server_protocol();
00203         <span class="keywordflow">if</span> (protocol == <span class="stringliteral">"http"</span>)
00204         curl_easy_setopt(d_curl, CURLOPT_PROXYPORT, (<span class="keywordtype">long</span>)80);
00205         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (protocol == <span class="stringliteral">"https"</span>)
00206         curl_easy_setopt(d_curl, CURLOPT_PROXYPORT, (<span class="keywordtype">long</span>)443);
00207         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (protocol == <span class="stringliteral">"ftp"</span>)
00208         curl_easy_setopt(d_curl, CURLOPT_PROXYPORT, (<span class="keywordtype">long</span>)21);
00209         <span class="keywordflow">else</span> 
00210         <span class="keywordflow">throw</span> Error(<span class="stringliteral">"Proxies for the protocol '"</span> + protocol 
00211                 + <span class="stringliteral">"' are not supported."</span>);
00212     }
00213     }
00214 
00215     curl_easy_setopt(d_curl, CURLOPT_ERRORBUFFER, d_error_buffer);
00216     <span class="comment">// We have to set FailOnError to false for any of the non-Basic</span>
00217     <span class="comment">// authentication schemes to work. 07/28/03 jhrg</span>
00218     curl_easy_setopt(d_curl, CURLOPT_FAILONERROR, 0);
00219 
00220     <span class="comment">// This means libcurl will use Basic, Digest, GSS Negotiate, or NTLM,</span>
00221     <span class="comment">// choosing the the 'safest' one supported by the server.</span>
00222     <span class="comment">// This requires curl 7.10.6 which is still in pre-release. 07/25/03 jhrg</span>
00223     curl_easy_setopt(d_curl, CURLOPT_HTTPAUTH, (<span class="keywordtype">long</span>)CURLAUTH_ANY);
00224 
00225     curl_easy_setopt(d_curl, CURLOPT_NOPROGRESS, 1);
00226     curl_easy_setopt(d_curl, CURLOPT_MUTE, 1);
00227     curl_easy_setopt(d_curl, CURLOPT_NOSIGNAL, (<span class="keywordtype">long</span>)1);
00228 
00229     curl_easy_setopt(d_curl, CURLOPT_HEADERFUNCTION, save_raw_http_headers);
00230     <span class="comment">// In read_url a call to CURLOPT_WRITEHEADER is used to set the fourth</span>
00231     <span class="comment">// param of save_raw_http_headers to a vector&lt;string&gt; object. </span>
00232 
00233     <span class="keywordflow">if</span> (<a class="code" href="HTTPConnect_8cc.html#a1">www_trace</a>) {
00234     curl_easy_setopt(d_curl, CURLOPT_VERBOSE, 1);
00235     curl_easy_setopt(d_curl, CURLOPT_DEBUGFUNCTION, curl_debug);
00236     }
00237     
00238 }
00239 
00243 <span class="keyword">class </span>BuildHeaders : <span class="keyword">public</span> unary_function&lt;const string &amp;, void&gt; {
00244     <span class="keyword">struct </span>curl_slist *d_cl;
00245 
00246 <span class="keyword">public</span>:
00247     BuildHeaders() : d_cl(0) {}
00248 
00249     <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> string &amp;header) {
00250     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Adding '"</span> &lt;&lt; header.c_str() &lt;&lt; <span class="stringliteral">"' to the header list."</span> 
00251         &lt;&lt; endl);
00252     d_cl = curl_slist_append(d_cl, header.c_str());
00253     }
00254 
00255     <span class="keyword">struct </span>curl_slist *get_headers() {
00256     <span class="keywordflow">return</span> d_cl;
00257     }
00258 };
00259 
00274 <span class="keywordtype">long</span>
00275 HTTPConnect::read_url(<span class="keyword">const</span> string &amp;url, FILE *stream, 
00276               vector&lt;string&gt; *resp_hdrs,
00277               <span class="keyword">const</span> vector&lt;string&gt; *headers) <span class="keywordflow">throw</span>(Error)
00278 {
00279     curl_easy_setopt(d_curl, CURLOPT_URL, url.c_str());
00280     curl_easy_setopt(d_curl, CURLOPT_FILE, stream);
00281 
00282     <a class="code" href="debug_8h.html#a1">DBG</a>(copy(d_request_headers.begin(), d_request_headers.end(),
00283          ostream_iterator&lt;string&gt;(cerr, <span class="stringliteral">"\n"</span>)));
00284 
00285     BuildHeaders req_hdrs;
00286     req_hdrs = for_each(d_request_headers.begin(), d_request_headers.end(),
00287              req_hdrs);
00288     <span class="keywordflow">if</span> (headers)
00289     req_hdrs = for_each(headers-&gt;begin(), headers-&gt;end(), req_hdrs);
00290     curl_easy_setopt(d_curl, CURLOPT_HTTPHEADER, req_hdrs.get_headers());
00291 
00292     <span class="keywordflow">if</span> (d_accept_deflate)
00293     curl_easy_setopt(d_curl, CURLOPT_ENCODING, <span class="stringliteral">"deflate"</span>);
00294 
00295     <span class="keywordtype">bool</span> temporary_proxy = <span class="keyword">false</span>;
00296     <span class="keywordflow">if</span> ((temporary_proxy = url_uses_proxy_for(url))) {
00297     <span class="comment">// Set the new proxy.</span>
00298     curl_easy_setopt(d_curl, CURLOPT_PROXY,
00299              d_rcr-&gt;get_proxy_for_proxy_host_url().c_str());
00300     }
00301     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((temporary_proxy = url_uses_no_proxy_for(url))) {
00302     <span class="comment">// Turn off the proxy for this URL.</span>
00303     curl_easy_setopt(d_curl, CURLOPT_PROXY, 0); 
00304     }
00305 
00306     string::size_type at_sign = url.find(<span class="charliteral">'@'</span>);
00307     <span class="comment">// Assume username:password present *and assume it's an HTTP URL; it *is*</span>
00308     <span class="comment">// HTTPConnect, after all). 7 is position after "http://"; the second arg</span>
00309     <span class="comment">// to substr() is the sub string length.</span>
00310     <span class="keywordflow">if</span> (at_sign != url.npos)
00311     d_upstring = url.substr(7, at_sign-7);
00312 
00313     <span class="keywordflow">if</span> (!d_upstring.empty()) {
00314     curl_easy_setopt(d_curl, CURLOPT_USERPWD, d_upstring.c_str());
00315     curl_easy_setopt(d_curl, CURLOPT_PROXYUSERPWD, d_upstring.c_str());
00316     }
00317 
00318     <span class="comment">// Pass save_raw_http_headers() a pointer to the vector&lt;string&gt; where the</span>
00319     <span class="comment">// response headers may be stored. Callers can use the resp_hdrs</span>
00320     <span class="comment">// value/result parameter to get the raw response header information .</span>
00321     curl_easy_setopt(d_curl, CURLOPT_WRITEHEADER, resp_hdrs);
00322 
00323     CURLcode res = curl_easy_perform(d_curl);
00324 
00325     <span class="comment">// Free the header list and null the value in d_curl.</span>
00326     curl_slist_free_all(req_hdrs.get_headers());
00327     curl_easy_setopt(d_curl, CURLOPT_HTTPHEADER, 0);
00328 
00329     <span class="comment">// Reset the proxy?</span>
00330     <span class="keywordflow">if</span> (temporary_proxy &amp;&amp; d_rcr-&gt;get_proxy_server_host_url() != <span class="stringliteral">""</span>)
00331     curl_easy_setopt(d_curl, CURLOPT_PROXY,
00332              d_rcr-&gt;get_proxy_server_host_url().c_str());
00333     
00334     <span class="keywordflow">if</span> (res != 0)
00335     <span class="keywordflow">throw</span> Error(d_error_buffer);
00336 
00337     <span class="keywordtype">long</span> status;
00338     res = curl_easy_getinfo(d_curl, CURLINFO_HTTP_CODE, &amp;status);
00339     <span class="keywordflow">if</span> (res != 0)
00340     <span class="keywordflow">throw</span> Error(d_error_buffer);
00341 
00342     <span class="keywordflow">return</span> status;
00343 }
00344 
00348 <span class="keywordtype">bool</span>
00349 HTTPConnect::url_uses_proxy_for(<span class="keyword">const</span> string &amp;url) <span class="keywordflow">throw</span>()
00350 {
00351     <span class="keywordflow">if</span> (d_rcr-&gt;is_proxy_for_used()) {
00352     Regex host_regex(d_rcr-&gt;get_proxy_for_regexp().c_str());
00353     <span class="keywordtype">int</span> index=0, matchlen;
00354     <span class="keywordflow">return</span> host_regex.search(url.c_str(), url.size(), matchlen, index)
00355         != -1;
00356     }
00357     
00358     <span class="keywordflow">return</span> <span class="keyword">false</span>;   
00359 }
00360 
00364 <span class="keywordtype">bool</span>
00365 HTTPConnect::url_uses_no_proxy_for(<span class="keyword">const</span> string &amp;url) <span class="keywordflow">throw</span>()
00366 {
00367     <span class="keywordflow">return</span> d_rcr-&gt;is_no_proxy_for_used()
00368     &amp;&amp; url.find(d_rcr-&gt;get_no_proxy_for_host()) != string::npos;
00369 }
00370 
00371 <span class="comment">// Public methods. Mostly...</span>
00372 
<a name="l00379"></a><a class="code" href="classHTTPConnect.html#HTTPConnecta0">00379</a> <a class="code" href="classHTTPConnect.html#HTTPConnectz84_0">HTTPConnect::HTTPConnect</a>(<a class="code" href="classRCReader.html">RCReader</a> *rcr) <span class="keywordflow">throw</span>(Error, <a class="code" href="classInternalErr.html">InternalErr</a>)
00380     : d_username(<span class="stringliteral">""</span>), d_password(<span class="stringliteral">""</span>)
00381 {
00382     d_accept_deflate = rcr-&gt;get_deflate();
00383     d_rcr = rcr;
00384 
00385     <span class="comment">// Load in the default headers to send with a request. The empty Pragma</span>
00386     <span class="comment">// headers overrides libcurl's default Pragma: no-cache header (which</span>
00387     <span class="comment">// will disable caching by Squid, et c.). The User-Agent header helps</span>
00388     <span class="comment">// make server logs more readable. 05/05/03 jhrg</span>
00389     d_request_headers.push_back(string(<span class="stringliteral">"Pragma:"</span>));
00390     string user_agent = string(<span class="stringliteral">"User-Agent: "</span>) + string(<a class="code" href="config__dap_8h.html#a0">CNAME</a>)
00391     + string(<span class="stringliteral">"/"</span>) + string(<a class="code" href="config__dap_8h.html#a1">CVER</a>);
00392     d_request_headers.push_back(user_agent);
00393     <span class="keywordflow">if</span> (d_accept_deflate)
00394     d_request_headers.push_back(string(<span class="stringliteral">"Accept-Encoding: deflate"</span>));
00395 
00396     <span class="comment">// HTTPCache::instance returns a valid ptr or 0.</span>
00397     <span class="keywordflow">if</span> (d_rcr-&gt;get_use_cache())
00398     d_http_cache = <a class="code" href="classHTTPCache.html#HTTPCachee0">HTTPCache::instance</a>(d_rcr-&gt;get_dods_cache_root(),
00399                        <span class="keyword">false</span>);
00400     <span class="keywordflow">else</span>
00401     d_http_cache = 0;
00402 
00403     <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"Cache object created ("</span> &lt;&lt; hex &lt;&lt; d_http_cache &lt;&lt; dec
00404      &lt;&lt; <span class="stringliteral">")"</span> &lt;&lt; endl);
00405 
00406     <span class="keywordflow">if</span> (d_http_cache) {
00407     d_http_cache-&gt;set_cache_enabled(d_rcr-&gt;get_use_cache());
00408     d_http_cache-&gt;set_expire_ignored(d_rcr-&gt;get_ignore_expires() != 0);
00409     d_http_cache-&gt;set_max_size(d_rcr-&gt;get_max_cache_size());
00410     d_http_cache-&gt;set_max_entry_size(d_rcr-&gt;get_max_cached_obj());
00411     d_http_cache-&gt;set_default_expiration(d_rcr-&gt;get_default_expires());
00412     d_http_cache-&gt;set_always_validate(d_rcr-&gt;get_always_validate() != 0);
00413     }
00414     
00415     www_lib_init();     <span class="comment">// This may throw either Error or InternalErr</span>
00416 }
00417 
<a name="l00418"></a><a class="code" href="classHTTPConnect.html#HTTPConnecta1">00418</a> <a class="code" href="classHTTPConnect.html#HTTPConnecta1">HTTPConnect::~HTTPConnect</a>()
00419 {
00420     <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"Entering the HTTPConnect dtor"</span> &lt;&lt; endl);
00421 
00422     curl_easy_cleanup(d_curl);
00423 
00424     <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"Leaving the HTTPConnect dtor"</span> &lt;&lt; endl);
00425 }
00426 
00439 <a class="code" href="classHTTPResponse.html">HTTPResponse</a> *
<a name="l00440"></a><a class="code" href="classHTTPConnect.html#HTTPConnecta6">00440</a> <a class="code" href="classHTTPConnect.html#HTTPConnecta6">HTTPConnect::fetch_url</a>(<span class="keyword">const</span> string &amp;url) <span class="keywordflow">throw</span>(Error, <a class="code" href="classInternalErr.html">InternalErr</a>)
00441 {
00442     <a class="code" href="classHTTPResponse.html">HTTPResponse</a> *stream;
00443 
00444     <span class="keywordflow">if</span> (d_http_cache &amp;&amp; d_http_cache-&gt;is_cache_enabled())
00445     stream = caching_fetch_url(url);
00446     <span class="keywordflow">else</span>
00447     stream = plain_fetch_url(url);
00448     
00449     ParseHeader parser;
00450 
00451     parser = for_each(stream-&gt;<a class="code" href="classHTTPResponse.html#HTTPResponsez88_0">get_headers</a>()-&gt;begin(), 
00452               stream-&gt;<a class="code" href="classHTTPResponse.html#HTTPResponsez88_0">get_headers</a>()-&gt;end(), ParseHeader());
00453 
00454     stream-&gt;<a class="code" href="classResponse.html#Responsez107_0">set_type</a>(parser.get_object_type());
00455     stream-&gt;<a class="code" href="classResponse.html#Responsez107_1">set_version</a>(parser.get_server());
00456     
00457     <span class="keywordflow">return</span> stream;
00458 }
00459 
00478 string
00479 HTTPConnect::get_temp_file(FILE *&amp;stream) <span class="keywordflow">throw</span>(<a class="code" href="classInternalErr.html">InternalErr</a>)
00480 {
00481     <span class="comment">// get_tempfile_template() uses new, must call delete</span>
00482     <span class="keywordtype">char</span> *dods_temp = <a class="code" href="util_8cc.html#a19">get_tempfile_template</a>(<span class="stringliteral">"dodsXXXXXX"</span>);
00483 
00484     <span class="comment">// Open truncated for update. NB: mkstemp() returns a file descriptor.</span>
00485 <span class="preprocessor">#if defined(WIN32) || defined(TEST_WIN32_TEMPS)</span>
00486 <span class="preprocessor"></span>    stream = fopen(_mktemp(dods_temp), <span class="stringliteral">"w+b"</span>);
00487 <span class="preprocessor">#else</span>
00488 <span class="preprocessor"></span>    stream = fdopen(mkstemp(dods_temp), <span class="stringliteral">"w+"</span>);
00489 <span class="preprocessor">#endif</span>
00490 <span class="preprocessor"></span>
00491     <span class="keywordflow">if</span> (!stream)
00492     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(<span class="stringliteral">"I/O Error: Failed to open a temporary file for the data values."</span>);
00493 
00494     string dods_temp_s = dods_temp;
00495     <span class="keyword">delete</span>[] dods_temp;
00496 
00497     <span class="keywordflow">return</span> dods_temp_s;
00498 }
00499 
00501 <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">void</span>
00502 close_temp(FILE *s, <span class="keyword">const</span> string &amp;name)
00503 {
00504     <span class="keywordtype">int</span> res = fclose(s);
00505     <span class="keywordflow">if</span> (res)
00506     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Failed to close "</span> &lt;&lt; (<span class="keywordtype">void</span> *)s &lt;&lt; endl);
00507     
00508     unlink(name.c_str());
00509 }
00510 
00532 <a class="code" href="classHTTPResponse.html">HTTPResponse</a> *
00533 HTTPConnect::caching_fetch_url(<span class="keyword">const</span> string &amp;url) <span class="keywordflow">throw</span>(Error, <a class="code" href="classInternalErr.html">InternalErr</a>)
00534 {
00535     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Is this URL ("</span> &lt;&lt; url &lt;&lt; <span class="stringliteral">") in the cache?... "</span>);
00536 
00537     <span class="keywordflow">if</span> (d_http_cache-&gt;is_url_in_cache(url)) { <span class="comment">// url in cache</span>
00538     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"yes... "</span>);
00539 
00540     <span class="keywordflow">if</span> (d_http_cache-&gt;is_url_valid(url)) { <span class="comment">// url in cache and valid</span>
00541         <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"and it's valid; using cached response."</span> &lt;&lt; endl);
00542 
00543         vector&lt;string&gt; *headers = <span class="keyword">new</span> vector&lt;string&gt;;;
00544         FILE *s = d_http_cache-&gt;get_cached_response(url, *headers);
00545         <a class="code" href="classHTTPCacheResponse.html">HTTPCacheResponse</a> *crs = <span class="keyword">new</span> <a class="code" href="classHTTPCacheResponse.html">HTTPCacheResponse</a>(s, headers, d_http_cache);
00546         
00547         <span class="keywordflow">return</span> crs;
00548     }
00549     <span class="keywordflow">else</span> {          <span class="comment">// url in cache but not valid; validate</span>
00550         <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"but it's not valid; validating... "</span>);
00551 
00552         <span class="comment">// *** auto_ptr??? resp_hdrs not deleted! 10/10/03 jhrg </span>
00553         vector&lt;string&gt; *resp_hdrs = <span class="keyword">new</span> vector&lt;string&gt;;
00554         vector&lt;string&gt; cond_hdrs 
00555         = d_http_cache-&gt;get_conditional_request_headers(url);
00556         FILE *body = 0;
00557         string dods_temp = get_temp_file(body);
00558         time_t now = time(0); <span class="comment">// When was the request made (now).</span>
00559         <span class="keywordtype">long</span> http_status;
00560 
00561         <span class="keywordflow">try</span> {
00562         http_status = read_url(url, body, resp_hdrs, &amp;cond_hdrs);
00563         rewind(body);
00564         }
00565         <span class="keywordflow">catch</span>(Error &amp;e) {
00566         close_temp(body, dods_temp);
00567         <span class="keywordflow">throw</span>;
00568         }
00569 
00570         <span class="keywordflow">switch</span> (http_status) {
00571           <span class="keywordflow">case</span> 200: {       <span class="comment">// New headers and new body</span>
00572             <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"read a new response; caching."</span> &lt;&lt; endl);
00573 
00574             d_http_cache-&gt;cache_response(url, now, *resp_hdrs, body);
00575             <a class="code" href="classHTTPResponse.html">HTTPResponse</a> *rs = <span class="keyword">new</span> <a class="code" href="classHTTPResponse.html">HTTPResponse</a>(body, resp_hdrs,
00576                             dods_temp);
00577 
00578             <span class="keywordflow">return</span> rs;
00579         }
00580         <span class="keywordflow">break</span>;
00581 
00582           <span class="keywordflow">case</span> 304: {       <span class="comment">// Just new headers, use cached body</span>
00583             <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"cached response valid; updating."</span> &lt;&lt; endl);
00584 
00585             close_temp(body, dods_temp);
00586             d_http_cache-&gt;update_response(url, now, *resp_hdrs);
00587 
00588             vector&lt;string&gt; *headers = <span class="keyword">new</span> vector&lt;string&gt;;;
00589             FILE *s = d_http_cache-&gt;get_cached_response(url, *headers);
00590             <a class="code" href="classHTTPCacheResponse.html">HTTPCacheResponse</a> *crs 
00591             = <span class="keyword">new</span> <a class="code" href="classHTTPCacheResponse.html">HTTPCacheResponse</a>(s, headers, d_http_cache);
00592 <span class="preprocessor">#if 0</span>
00593 <span class="preprocessor"></span>            <span class="comment">// Problem: When a 304 comes back it sometimes (?) has</span>
00594             <span class="comment">// only a Date header. We need all the headers, so after</span>
00595             <span class="comment">// updating the cache with the single Date header, get</span>
00596             <span class="comment">// _all_ the headers and return them. See bug 672.</span>
00597             <span class="comment">// 10/10/03 jhrg</span>
00598             FILE *s = d_http_cache-&gt;get_cached_response_body(url);
00599             HTTPCacheResponse *crs 
00600             = <span class="keyword">new</span> HTTPCacheResponse(s, resp_hdrs, d_http_cache);
00601 <span class="preprocessor">#endif</span>
00602 <span class="preprocessor"></span>            <span class="keywordflow">return</span> crs;
00603         }
00604         <span class="keywordflow">break</span>;
00605 
00606           <span class="keywordflow">default</span>: {        <span class="comment">// Oops.</span>
00607           close_temp(body, dods_temp);
00608 
00609           <span class="keywordflow">throw</span> Error(<span class="stringliteral">"Bad response from the HTTP server: This implemenation of the DAP does not understand how to handle an HTTP status response of "</span> + <a class="code" href="util_8cc.html#a14">long_to_string</a>(http_status));
00610         }
00611         <span class="keywordflow">break</span>;
00612         }
00613     }
00614     }
00615     <span class="keywordflow">else</span> {          <span class="comment">// url not in cache; get it and cache it</span>
00616     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"no; getting response and caching."</span> &lt;&lt; endl);
00617     time_t now = time(0);
00618     <a class="code" href="classHTTPResponse.html">HTTPResponse</a> *rs = plain_fetch_url(url);
00619     d_http_cache-&gt;cache_response(url, now, *(rs-&gt;<a class="code" href="classHTTPResponse.html#HTTPResponsez88_0">get_headers</a>()), 
00620                      rs-&gt;<a class="code" href="classResponse.html#Responsez105_0">get_stream</a>());
00621     
00622     <span class="keywordflow">return</span> rs;
00623     }
00624 
00625     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, <span class="stringliteral">"Unexpected cache response."</span>);
00626 }
00627 
00628 
00640 <a class="code" href="classHTTPResponse.html">HTTPResponse</a> *
00641 HTTPConnect::plain_fetch_url(<span class="keyword">const</span> string &amp;url) <span class="keywordflow">throw</span>(Error, <a class="code" href="classInternalErr.html">InternalErr</a>)
00642 {
00643     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Getting URL: "</span> &lt;&lt; url &lt;&lt; endl);
00644     FILE *stream = 0;
00645     string dods_temp = get_temp_file(stream);
00646     vector&lt;string&gt; *resp_hdrs = <span class="keyword">new</span> vector&lt;string&gt;;
00647 
00648     <span class="keywordflow">try</span> {
00649     read_url(url, stream, resp_hdrs);   <span class="comment">// Throws Error.</span>
00650     }
00651 
00652     <span class="keywordflow">catch</span>(Error &amp;e) {
00653     close_temp(stream, dods_temp);
00654     <span class="keywordflow">throw</span> e;
00655     }
00656 
00657     rewind(stream);
00658 
00659     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classHTTPResponse.html">HTTPResponse</a>(stream, resp_hdrs, dods_temp);
00660 }
00661 
00673 <span class="keywordtype">void</span>
<a name="l00674"></a><a class="code" href="classHTTPConnect.html#HTTPConnecta3">00674</a> <a class="code" href="classHTTPConnect.html#HTTPConnecta3">HTTPConnect::set_accept_deflate</a>(<span class="keywordtype">bool</span> deflate)
00675 {
00676     d_accept_deflate = <a class="code" href="EncodingType_8h.html#a3a1">deflate</a>;
00677 
00678     <span class="keywordflow">if</span> (d_accept_deflate) {
00679     <span class="keywordflow">if</span> (find(d_request_headers.begin(), d_request_headers.end(), 
00680          <span class="stringliteral">"Accept-Encoding: deflate"</span>) == d_request_headers.end())
00681         d_request_headers.push_back(string(<span class="stringliteral">"Accept-Encoding: deflate"</span>));
00682     <a class="code" href="debug_8h.html#a1">DBG</a>(copy(d_request_headers.begin(), d_request_headers.end(),
00683          ostream_iterator&lt;string&gt;(cerr, <span class="stringliteral">"\n"</span>)));
00684     }
00685     <span class="keywordflow">else</span> {
00686     vector&lt;string&gt;::iterator i;
00687     i = remove_if(d_request_headers.begin(), d_request_headers.end(),
00688               bind2nd(equal_to&lt;string&gt;(), 
00689                   string(<span class="stringliteral">"Accept-Encoding: deflate"</span>)));
00690     d_request_headers.erase(i, d_request_headers.end());
00691     }
00692 }
00693 
00709 <span class="keywordtype">void</span> 
<a name="l00710"></a><a class="code" href="classHTTPConnect.html#HTTPConnecta2">00710</a> <a class="code" href="classHTTPConnect.html#HTTPConnecta2">HTTPConnect::set_credentials</a>(<span class="keyword">const</span> string &amp;u, <span class="keyword">const</span> string &amp;p) 
00711     <span class="keywordflow">throw</span>(<a class="code" href="classInternalErr.html">InternalErr</a>)
00712 {
00713     <span class="keywordflow">if</span> (u.empty())
00714     <span class="keywordflow">return</span>;
00715 
00716     <span class="comment">// Store the credentials locally.</span>
00717     d_username = u;
00718     d_password = p;
00719 
00720     d_upstring = u + <span class="stringliteral">":"</span> + p;
00721 }
00722 
00723 <span class="comment">// $Log: HTTPConnect_8cc-source.html,v $
00723 <span class="comment">// Revision 1.4  2004/02/05 06:51:16  jimg
00723 <span class="comment">// Added/update.
00723 <span class="comment">//</span>
00724 <span class="comment">// Revision 1.14.2.12  2004/02/04 00:05:11  jimg</span>
00725 <span class="comment">// Memory errors: I've fixed a number of memory errors (leaks, references)</span>
00726 <span class="comment">// found using valgrind. Many remain. I need to come up with a systematic</span>
00727 <span class="comment">// way of running the tests under valgrind.</span>
00728 <span class="comment">//</span>
00729 <span class="comment">// Revision 1.14.2.11  2003/10/10 23:13:12  jimg</span>
00730 <span class="comment">// Fix for bug 672: When a cached response needs to be validated and the origin</span>
00731 <span class="comment">// server returns a 304 response (i.e., use what you've got) only the Date</span>
00732 <span class="comment">// header is sent with the 304 response. This code was using the</span>
00733 <span class="comment">// HTTPCache::get_cahced_body() method and the header from the 304 response.</span>
00734 <span class="comment">// This meant that Content-Description and server/DAP-protocol version headers</span>
00735 <span class="comment">// were missing in the Response object returned by caching_fetch_url(). This</span>
00736 <span class="comment">// caused an Error to be thrown in Connect (because we just modified it to</span>
00737 <span class="comment">// require the Content-Description information). I fixed this by using the</span>
00738 <span class="comment">// get_cached_response() method which reads the body _and_ headers from the</span>
00739 <span class="comment">// cache.</span>
00740 <span class="comment">//</span>
00741 <span class="comment">// Revision 1.14.2.10  2003/10/03 16:21:17  jimg</span>
00742 <span class="comment">// Minor changes: save_raw_http_headers is now static and some comments were</span>
00743 <span class="comment">// fixed.</span>
00744 <span class="comment">//</span>
00745 <span class="comment">// Revision 1.14.2.9  2003/09/08 18:54:41  jimg</span>
00746 <span class="comment">// Now we check to see that USE_CACHE is set (1) in .dodsrc before trying to</span>
00747 <span class="comment">// create an instance of HTTPCache. This makes sense since HTTPCache will create</span>
00748 <span class="comment">// teh cache directory structure regardless of the value of USE_CACHE. If</span>
00749 <span class="comment">// USE_CACHE is clear (0), the the pointer to the HTTPCache instance is zero.</span>
00750 <span class="comment">//</span>
00751 <span class="comment">// Revision 1.14.2.8  2003/09/06 22:37:50  jimg</span>
00752 <span class="comment">// Updated the documentation.</span>
00753 <span class="comment">//</span>
00754 <span class="comment">// Revision 1.14.2.7  2003/08/18 00:33:14  rmorris</span>
00755 <span class="comment">// Win32-related cleanup.</span>
00756 <span class="comment">//</span>
00757 <span class="comment">// Revision 1.14.2.6  2003/07/29 01:46:33  jimg</span>
00758 <span class="comment">// Now supports digest authentication.</span>
00759 <span class="comment">//</span>
00760 <span class="comment">// Revision 1.14.2.5  2003/07/26 02:08:18  jimg</span>
00761 <span class="comment">// Added curl options to suppress signals and supply passwords to proxy servers.</span>
00762 <span class="comment">//</span>
00763 <span class="comment">// Revision 1.14.2.4  2003/07/16 04:20:55  jimg</span>
00764 <span class="comment">// Fixed some documentation.</span>
00765 <span class="comment">//</span>
00766 <span class="comment">// Revision 1.14.2.3  2003/05/06 06:44:15  jimg</span>
00767 <span class="comment">// Modified HTTPConnect so that the response headers are no longer a class</span>
00768 <span class="comment">// member. This cleans up the class interface and paves the way for using</span>
00769 <span class="comment">// the multi interface of libcurl. That'll have to wait for another day...</span>
00770 <span class="comment">//</span>
00771 <span class="comment">// Revision 1.14.2.2  2003/05/05 21:45:30  jimg</span>
00772 <span class="comment">// Added support for the http://user:passwd@machine... convention.</span>
00773 <span class="comment">//</span>
00774 <span class="comment">// Revision 1.14.2.1  2003/05/05 19:45:25  jimg</span>
00775 <span class="comment">// Fixed a problem where libcurl sent a Pragma: no-cache request header. This</span>
00776 <span class="comment">// caused third-party caches to not cache requests. I fixed this by forcing</span>
00777 <span class="comment">// libcurl to send an empty Pragma: header (suggested by Benno Blumenthal and</span>
00778 <span class="comment">// the libcurl list). At the same time I repaired the set_accept_deflate method</span>
00779 <span class="comment">// so that it worked (it didn't but nobody noticed...) and changed the class so</span>
00780 <span class="comment">// that *any* headers present in the new filed d_request_headers are sent</span>
00781 <span class="comment">// whenever read_url() is run. I also now set the User-Agent request header to</span>
00782 <span class="comment">// a value that announces who we are.</span>
00783 <span class="comment">//</span>
00784 <span class="comment">// Revision 1.14  2003/05/02 16:22:52  jimg</span>
00785 <span class="comment">// Minor fixes: Fixed a spelling mistake and removed #if 1 ... #endif. Mostly I</span>
00786 <span class="comment">// wanted this code in for the 3.4 branch.</span>
00787 <span class="comment">//</span>
00788 <span class="comment">// Revision 1.13  2003/05/01 23:37:01  jimg</span>
00789 <span class="comment">// Changed some of struct Functors to classes.</span>
00790 <span class="comment">//</span>
00791 <span class="comment">// Revision 1.12  2003/05/01 23:25:14  jimg</span>
00792 <span class="comment">// Fixed a bug in the code that handles conditional requests. Once a conditional</span>
00793 <span class="comment">// request was made, the curl_slist was freed but the HTTPHEADER option (set</span>
00794 <span class="comment">// with curl_easy_setopt()) was not cleared. Subsequent calls to</span>
00795 <span class="comment">// curl_easy_perform() would try to use the freed slist with predictably bad</span>
00796 <span class="comment">// results. Also removed strstream code in place of Rob's stringstream</span>
00797 <span class="comment">// replacement for Win32.</span>
00798 <span class="comment">//</span>
00799 <span class="comment">// Revision 1.11  2003/04/22 19:40:27  jimg</span>
00800 <span class="comment">// Merged with 3.3.1.</span>
00801 <span class="comment">//</span>
00802 <span class="comment">// Revision 1.3.2.4  2003/04/18 03:22:58  jimg</span>
00803 <span class="comment">// Undid a typo that made it into CVS...</span>
00804 <span class="comment">//</span>
00805 <span class="comment">// Revision 1.3.2.3  2003/04/18 03:21:17  jimg</span>
00806 <span class="comment">// I removed some old code (some of which has been seriously hacked already on</span>
00807 <span class="comment">// the trunk) and changed the catch part of a try-catch block so that it only</span>
00808 <span class="comment">// catches and re-throws the objects listed in the throw() declaration. Using</span>
00809 <span class="comment">// catch(...) and re-throwing when exceptions have been explicitly declared</span>
00810 <span class="comment">// aborts.</span>
00811 <span class="comment">//</span>
00812 <span class="comment">// Revision 1.3.2.2  2003/04/09 20:36:21  jimg</span>
00813 <span class="comment">// Changed the catch(...) clauses to ones that explicitly name the objects. By</span>
00814 <span class="comment">// just using catch(...) with a method that declares the types of exceptions it</span>
00815 <span class="comment">// throws causes an abort if the catch(...) re-throws the exception.</span>
00816 <span class="comment">// I also removed some old code that called output(), et cetera.</span>
00817 <span class="comment">//</span>
00818 <span class="comment">// Revision 1.10  2003/03/13 23:51:31  jimg</span>
00819 <span class="comment">// Added a DBG2 statement to track down a bug. Useful when you cannot use a</span>
00820 <span class="comment">// debugger.</span>
00821 <span class="comment">//</span>
00822 <span class="comment">// Revision 1.9  2003/03/04 21:41:44  jimg</span>
00823 <span class="comment">// Removed code in #if 0 ... #endif. This was mostly WIN32 code that I don't</span>
00824 <span class="comment">// think we need anymore.</span>
00825 <span class="comment">//</span>
00826 <span class="comment">// Revision 1.8  2003/03/04 17:28:37  jimg</span>
00827 <span class="comment">// Switched to Response objects. Removed unneeded methods. The Response objects</span>
00828 <span class="comment">// now control the release of resources such as deleting temporary files, et c.</span>
00829 <span class="comment">//</span>
00830 <span class="comment">// Revision 1.7  2003/02/27 23:36:10  jimg</span>
00831 <span class="comment">// Added set_accept_deflate() method.</span>
00832 <span class="comment">//</span>
00833 <span class="comment">// Revision 1.6  2003/02/27 08:32:51  jimg</span>
00834 <span class="comment">// Removed old code.</span>
00835 <span class="comment">//</span>
00836 <span class="comment">// Revision 1.5  2003/02/21 00:14:24  jimg</span>
00837 <span class="comment">// Repaired copyright.</span>
00838 <span class="comment">//</span>
00839 <span class="comment">// Revision 1.3.2.1  2003/02/21 00:10:07  jimg</span>
00840 <span class="comment">// Repaired copyright.</span>
00841 <span class="comment">//</span>
00842 <span class="comment">// Revision 1.4  2003/02/20 23:13:52  jimg</span>
00843 <span class="comment">// Fixed the comment for getch_url.</span>
00844 <span class="comment">//</span>
00845 <span class="comment">// Revision 1.3  2003/01/23 00:22:24  jimg</span>
00846 <span class="comment">// Updated the copyright notice; this implementation of the DAP is</span>
00847 <span class="comment">// copyrighted by OPeNDAP, Inc.</span>
00848 <span class="comment">//</span>
00849 <span class="comment">// Revision 1.2  2003/01/10 19:46:40  jimg</span>
00850 <span class="comment">// Merged with code tagged release-3-2-10 on the release-3-2 branch. In many</span>
00851 <span class="comment">// cases files were added on that branch (so they appear on the trunk for</span>
00852 <span class="comment">// the first time).</span>
00853 <span class="comment">//</span>
00854 <span class="comment">// Revision 1.1.2.14  2002/12/27 00:56:24  jimg</span>
00855 <span class="comment">// is_response_present() is now deprecated.</span>
00856 <span class="comment">//</span>
00857 <span class="comment">// Revision 1.1.2.13  2002/12/24 00:22:00  jimg</span>
00858 <span class="comment">// Removed the output() and close_output() methods from the interface.</span>
00859 <span class="comment">// The fetch_url() method now returns a FILE * instead of forcing clients to</span>
00860 <span class="comment">// call the output() method.</span>
00861 <span class="comment">//</span>
00862 <span class="comment">// Revision 1.1.2.12  2002/12/05 20:36:19  pwest</span>
00863 <span class="comment">// Corrected problems with IteratorAdapter code, making methods non-inline,</span>
00864 <span class="comment">// creating source files and template instantiation file. Cleaned up file</span>
00865 <span class="comment">// descriptors and memory management problems. Corrected problem in Connect</span>
00866 <span class="comment">// where the xdr source was not being cleaned up or a new one created when a</span>
00867 <span class="comment">// new file was opened for reading.</span>
00868 <span class="comment">//</span>
00869 <span class="comment">// Revision 1.1.2.11  2002/11/21 21:24:17  pwest</span>
00870 <span class="comment">// memory leak cleanup and file descriptor cleanup</span>
00871 <span class="comment">//</span>
00872 <span class="comment">// Revision 1.1.2.10  2002/10/18 22:48:46  jimg</span>
00873 <span class="comment">// Resolved conflicts with Rob's changes</span>
00874 <span class="comment">//</span>
00875 <span class="comment">// Revision 1.1.2.9  2002/09/22 14:31:56  rmorris</span>
00876 <span class="comment">// Minor mod's to get the code to go through VC++.</span>
00877 <span class="comment">//</span>
00878 <span class="comment">// Revision 1.1.2.8  2002/09/14 03:40:32  jimg</span>
00879 <span class="comment">// Added get_response_headers() method. This method provides a way to access the</span>
00880 <span class="comment">// headers included in a response, specifically so that they can be cached.</span>
00881 <span class="comment">// Added is_response_present() which returns true when fetch_url() has been</span>
00882 <span class="comment">// called and a response is present. Also added tests which cause the four</span>
00883 <span class="comment">// methods that access information from the response (output, et c.) to throw an</span>
00884 <span class="comment">// InternalErr if they are called and is_response_present() would return false.</span>
00885 <span class="comment">//</span>
00886 <span class="comment">// Revision 1.1.2.7  2002/08/22 21:23:23  jimg</span>
00887 <span class="comment">// Fixes for the Win32 Build made at ESRI by Vlad Plenchoy and myslef.</span>
00888 <span class="comment">//</span>
00889 <span class="comment">// Revision 1.1.2.6  2002/08/08 06:54:57  jimg</span>
00890 <span class="comment">// Changes for thread-safety. In many cases I found ugly places at the</span>
00891 <span class="comment">// tops of files while looking for globals, et c., and I fixed them up</span>
00892 <span class="comment">// (hopefully making them easier to read, ...). Only the files RCReader.cc</span>
00893 <span class="comment">// and usage.cc actually use pthreads synchronization functions. In other</span>
00894 <span class="comment">// cases I removed static objects where they were used for supposed</span>
00895 <span class="comment">// improvements in efficiency which had never actually been verifiied (and</span>
00896 <span class="comment">// which looked dubious).</span>
00897 <span class="comment">//</span>
00898 <span class="comment">// Revision 1.1.2.5  2002/08/06 22:09:49  jimg</span>
00899 <span class="comment">// Removed old code about cache control.</span>
00900 <span class="comment">// Fixed set_credentials() so that it is MT-safe.</span>
00901 <span class="comment">//</span>
00902 <span class="comment">// Revision 1.1.2.4  2002/07/06 20:57:08  jimg</span>
00903 <span class="comment">// *** empty log message ***</span>
00904 <span class="comment">//</span>
00905 <span class="comment">// Revision 1.1.2.3  2002/07/06 20:08:08  jimg</span>
00906 <span class="comment">// Added support for proxies. Fixed the deflate stuff so that it matches the new</span>
00907 <span class="comment">// `sense' of the _dods_deflate field. Compression still does not work since</span>
00908 <span class="comment">// libcurl doesn't handle it yet.</span>
00909 <span class="comment">//</span>
00910 <span class="comment">// Revision 1.1.2.2  2002/06/20 03:18:48  jimg</span>
00911 <span class="comment">// Fixes and modifications to the Connect and HTTPConnect classes. Neither</span>
00912 <span class="comment">// of these two classes is complete, but they should compile and their</span>
00913 <span class="comment">// basic functions should work.</span>
00914 <span class="comment">//</span>
00915 <span class="comment">// Revision 1.1.2.1  2002/06/18 21:57:24  jimg</span>
00916 <span class="comment">// Created. This is a DODS interface to a HTTP library. This version uses</span>
00917 <span class="comment">// libwww. A lot of the methods here should be removed...</span>
00918 <span class="comment">//</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Feb 4 23:43:01 2004 for libdap++ by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
