<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>expr.y Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>expr.y</h1><a href="expr_8y.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00002 <span class="comment">// -*- mode: c++; c-basic-offset:4 -*-</span>
00003 
00004 <span class="comment">// This file is part of libdap, A C++ implementation of the OPeNDAP Data</span>
00005 <span class="comment">// Access Protocol.</span>
00006 
00007 <span class="comment">// Copyright (c) 2002,2003 OPeNDAP, Inc.</span>
00008 <span class="comment">// Author: James Gallagher &lt;jgallagher@opendap.org&gt;</span>
00009 <span class="comment">//</span>
00010 <span class="comment">// This library is free software; you can redistribute it and/or</span>
00011 <span class="comment">// modify it under the terms of the GNU Lesser General Public</span>
00012 <span class="comment">// License as published by the Free Software Foundation; either</span>
00013 <span class="comment">// version 2.1 of the License, or (at your option) any later version.</span>
00014 <span class="comment">// </span>
00015 <span class="comment">// This library is distributed in the hope that it will be useful,</span>
00016 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00017 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00018 <span class="comment">// Lesser General Public License for more details.</span>
00019 <span class="comment">// </span>
00020 <span class="comment">// You should have received a copy of the GNU Lesser General Public</span>
00021 <span class="comment">// License along with this library; if not, write to the Free Software</span>
00022 <span class="comment">// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00023 <span class="comment">//</span>
00024 <span class="comment">// You can contact OPeNDAP, Inc. at PO Box 112, Saunderstown, RI. 02874-0112.</span>
00025  
00026 <span class="comment">// (c) COPYRIGHT URI/MIT 1995-1999</span>
00027 <span class="comment">// Please read the full copyright statement in the file COPYRIGHT_URI.</span>
00028 <span class="comment">//</span>
00029 <span class="comment">// Authors:</span>
00030 <span class="comment">//      jhrg,jimg       James Gallagher &lt;jgallagher@gso.uri.edu&gt;</span>
00031 
00032 <span class="comment">/*</span>
00033 <span class="comment">  This is the parser for the DODS constraint expression grammar. The parser</span>
00034 <span class="comment">  calls various `helper' functions defined by the DAP classes which either</span>
00035 <span class="comment">  implement the operations (in the case of relational ops) or store</span>
00036 <span class="comment">  information (in the case of selection operations). </span>
00037 <span class="comment"></span>
00038 <span class="comment">  jhrg 9/5/95</span>
00039 <span class="comment">*/</span>
00040 
00041 %{
00042 
00043 <span class="preprocessor">#include "<a class="code" href="config__dap_8h.html">config_dap.h</a>"</span>
00044 
00045 <span class="keyword">static</span> <span class="keywordtype">char</span> rcsid[] not_used = {<span class="stringliteral">"$Id$"</span>};
00046 
00047 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00048 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00049 <span class="preprocessor">#include &lt;string.h&gt;</span>
00050 <span class="preprocessor">#include &lt;assert.h&gt;</span>
00051 
00052 <span class="preprocessor">#include &lt;string&gt;</span>
00053 <span class="preprocessor">#include &lt;strstream&gt;</span>
00054 
00055 <span class="preprocessor">#include "<a class="code" href="debug_8h.html">debug.h</a>"</span>
00056 <span class="preprocessor">#include "<a class="code" href="escaping_8h.html">escaping.h</a>"</span>
00057 
00058 <span class="preprocessor">#include "<a class="code" href="DDS_8h.html">DDS.h</a>"</span>
00059 
00060 <span class="preprocessor">#include "<a class="code" href="Connect_8h.html">Connect.h</a>"</span>
00061 
00062 <span class="preprocessor">#include "<a class="code" href="BaseType_8h.html">BaseType.h</a>"</span>
00063 <span class="preprocessor">#include "<a class="code" href="Array_8h.html">Array.h</a>"</span>
00064 <span class="preprocessor">#include "<a class="code" href="List_8h.html">List.h</a>"</span>
00065 <span class="preprocessor">#include "<a class="code" href="Structure_8h.html">Structure.h</a>"</span>
00066 <span class="preprocessor">#include "<a class="code" href="Sequence_8h.html">Sequence.h</a>"</span>
00067 <span class="preprocessor">#include "<a class="code" href="Grid_8h.html">Grid.h</a>"</span>
00068 <span class="preprocessor">#include "<a class="code" href="Error_8h.html">Error.h</a>"</span>
00069 
00070 <span class="preprocessor">#include "<a class="code" href="util_8h.html">util.h</a>"</span>
00071 <span class="preprocessor">#include "<a class="code" href="parser_8h.html">parser.h</a>"</span>
00072 <span class="preprocessor">#include "<a class="code" href="expr_8h.html">expr.h</a>"</span>
00073 <span class="preprocessor">#include "<a class="code" href="RValue_8h.html">RValue.h</a>"</span>
00074 
00075 <span class="preprocessor">#ifdef TRACE_NEW</span>
00076 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="trace__new_8h.html">trace_new.h</a>"</span>
00077 <span class="preprocessor">#endif</span>
00078 <span class="preprocessor"></span>
00079 <span class="keyword">using</span> std::cerr;
00080 <span class="keyword">using</span> std::endl;
00081 <span class="keyword">using</span> std::ends;
00082 <span class="keyword">using</span> std::ostrstream;
00083 
00084 <span class="comment">// These macros are used to access the `arguments' passed to the parser. A</span>
00085 <span class="comment">// pointer to an error object and a pointer to an integer status variable are</span>
00086 <span class="comment">// passed into the parser within a strucutre (which itself is passed as a</span>
00087 <span class="comment">// pointer). Note that the ERROR macro does not explicitly casts OBJ to an</span>
00088 <span class="comment">// ERROR *.</span>
00089 
00090 <span class="preprocessor">#define DDS_OBJ(arg) ((DDS *)((parser_arg *)(arg))-&gt;_object)</span>
00091 <span class="preprocessor"></span>
00092 <span class="preprocessor">#define YYPARSE_PARAM arg</span>
00093 <span class="preprocessor"></span>
00094 <span class="keywordtype">int</span> <a class="code" href="expr-test_8cc.html#a17">exprlex</a>(<span class="keywordtype">void</span>);      <span class="comment">/* the scanner; see expr.lex */</span>
00095 
00096 <span class="keywordtype">void</span> exprerror(<span class="keyword">const</span> <span class="keywordtype">char</span> *s);  <span class="comment">/* easier to overload than to use stdarg... */</span>
00097 <span class="keywordtype">void</span> exprerror(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keyword">const</span> <span class="keywordtype">char</span> *s2);
00098 <span class="keywordtype">void</span> no_such_func(<span class="keywordtype">void</span> *arg, <span class="keywordtype">char</span> *<a class="code" href="das_8y.html#a18">name</a>);
00099 <span class="keywordtype">void</span> no_such_ident(<span class="keywordtype">void</span> *arg, <span class="keywordtype">char</span> *<a class="code" href="das_8y.html#a18">name</a>, <span class="keywordtype">char</span> *word);
00100 
00101 <span class="keywordtype">void</span> exprerror(<span class="keyword">const</span> string &amp;s); 
00102 <span class="keywordtype">void</span> exprerror(<span class="keyword">const</span> string &amp;s, <span class="keyword">const</span> string &amp;s2);
00103 <span class="keywordtype">void</span> no_such_func(<span class="keywordtype">void</span> *arg, <span class="keyword">const</span> string &amp;<a class="code" href="das_8y.html#a18">name</a>);
00104 <span class="keywordtype">void</span> no_such_ident(<span class="keywordtype">void</span> *arg, <span class="keyword">const</span> string &amp;<a class="code" href="das_8y.html#a18">name</a>, <span class="keyword">const</span> string &amp;word);
00105 
00106 <a class="code" href="classstd_1_1vector.html">int_list</a> *make_array_index(<a class="code" href="structvalue.html">value</a> &amp;i1, <a class="code" href="structvalue.html">value</a> &amp;i2, <a class="code" href="structvalue.html">value</a> &amp;i3);
00107 <a class="code" href="classstd_1_1vector.html">int_list</a> *make_array_index(<a class="code" href="structvalue.html">value</a> &amp;i1, <a class="code" href="structvalue.html">value</a> &amp;i2);
00108 <a class="code" href="classstd_1_1vector.html">int_list</a> *make_array_index(<a class="code" href="structvalue.html">value</a> &amp;i1);
00109 <a class="code" href="expr_8h.html#a6">int_list_list</a> *make_array_indices(<a class="code" href="classstd_1_1vector.html">int_list</a> *index);
00110 <a class="code" href="expr_8h.html#a6">int_list_list</a> *append_array_index(<a class="code" href="expr_8h.html#a6">int_list_list</a> *indices, <a class="code" href="classstd_1_1vector.html">int_list</a> *index);
00111 
00112 <span class="keywordtype">void</span> delete_array_indices(<a class="code" href="expr_8h.html#a6">int_list_list</a> *indices);
00113 <span class="keywordtype">bool</span> bracket_projection(<a class="code" href="classDDS.html">DDS</a> &amp;table, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="das_8y.html#a18">name</a>, 
00114             <a class="code" href="expr_8h.html#a6">int_list_list</a> *indices);
00115 
00116 <span class="keywordtype">bool</span> process_array_indices(<a class="code" href="classBaseType.html">BaseType</a> *variable, <a class="code" href="expr_8h.html#a6">int_list_list</a> *indices); 
00117 <span class="keywordtype">bool</span> process_grid_indices(<a class="code" href="classBaseType.html">BaseType</a> *variable, <a class="code" href="expr_8h.html#a6">int_list_list</a> *indices); 
00118 <span class="keywordtype">bool</span> process_sequence_indices(<a class="code" href="classBaseType.html">BaseType</a> *variable, <a class="code" href="expr_8h.html#a6">int_list_list</a> *indices);
00119 
00120 <span class="keywordtype">bool</span> is_array_t(<a class="code" href="classBaseType.html">BaseType</a> *variable);
00121 <span class="keywordtype">bool</span> is_grid_t(<a class="code" href="classBaseType.html">BaseType</a> *variable);
00122 <span class="keywordtype">bool</span> is_sequence_t(<a class="code" href="classBaseType.html">BaseType</a> *variable);
00123 
00124 <a class="code" href="RValue_8h.html#a0">rvalue_list</a> *make_rvalue_list(<a class="code" href="classrvalue.html">rvalue</a> *rv);
00125 <a class="code" href="RValue_8h.html#a0">rvalue_list</a> *append_rvalue_list(<a class="code" href="RValue_8h.html#a0">rvalue_list</a> *rvals, <a class="code" href="classrvalue.html">rvalue</a> *rv);
00126 
00127 <a class="code" href="classBaseType.html">BaseType</a> *make_variable(<a class="code" href="classDDS.html">DDS</a> &amp;table, <span class="keyword">const</span> <a class="code" href="structvalue.html">value</a> &amp;val);
00128 
00129 <a class="code" href="classrvalue.html">rvalue</a> *dereference_variable(<a class="code" href="classrvalue.html">rvalue</a> *rv, <a class="code" href="classDDS.html">DDS</a> &amp;dds);
00130 <a class="code" href="classrvalue.html">rvalue</a> *dereference_url(<a class="code" href="structvalue.html">value</a> &amp;val);
00131 
00132 <a class="code" href="expr_8h.html#a0">bool_func</a> get_function(<span class="keyword">const</span> <a class="code" href="classDDS.html">DDS</a> &amp;table, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="das_8y.html#a18">name</a>);
00133 <a class="code" href="expr_8h.html#a1">btp_func</a> get_btp_function(<span class="keyword">const</span> <a class="code" href="classDDS.html">DDS</a> &amp;table, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="das_8y.html#a18">name</a>);
00134 <a class="code" href="expr_8h.html#a2">proj_func</a> get_proj_function(<span class="keyword">const</span> <a class="code" href="classDDS.html">DDS</a> &amp;table, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="das_8y.html#a18">name</a>);
00135 
00136 %}
00137 
00138 %<span class="keyword">union </span>{
00139     <span class="keywordtype">bool</span> <span class="keywordtype">boolean</span>;
00140     <span class="keywordtype">int</span> op;
00141     <span class="keywordtype">char</span> id[ID_MAX];
00142 
00143     <a class="code" href="structvalue.html">value</a> val;
00144 
00145     <a class="code" href="expr_8h.html#a0">bool_func</a> b_func;
00146     <a class="code" href="expr_8h.html#a1">btp_func</a> bt_func;
00147 
00148     <a class="code" href="classstd_1_1vector.html">int_list</a> *int_l_ptr;
00149     <a class="code" href="expr_8h.html#a6">int_list_list</a> *int_ll_ptr;
00150     
00151     <a class="code" href="classrvalue.html">rvalue</a> *rval_ptr;
00152     <a class="code" href="RValue_8h.html#a0">rvalue_list</a> *r_val_l_ptr;
00153 }
00154 
00155 %token &lt;val&gt; SCAN_STR
00156 
00157 %token &lt;id&gt; SCAN_WORD
00158 
00159 %token &lt;op&gt; SCAN_EQUAL
00160 %token &lt;op&gt; SCAN_NOT_EQUAL
00161 %token &lt;op&gt; SCAN_GREATER
00162 %token &lt;op&gt; SCAN_GREATER_EQL
00163 %token &lt;op&gt; SCAN_LESS
00164 %token &lt;op&gt; SCAN_LESS_EQL
00165 %token &lt;op&gt; SCAN_REGEXP
00166 
00167 %type &lt;boolean&gt; constraint_expr projection proj_clause proj_function array_proj
00168 %type &lt;boolean&gt; selection clause bool_function
00169 %type &lt;op&gt; rel_op
00170 %type &lt;int_l_ptr&gt; array_index
00171 %type &lt;int_ll_ptr&gt; array_indices
00172 %type &lt;rval_ptr&gt; r_value id_or_const
00173 %type &lt;r_val_l_ptr&gt; r_value_list arg_list
00174 
00175 %%
00176 
00177 constraint_expr: <span class="comment">/* empty constraint --&gt; send all */</span>
00178                  {
00179              (*DDS_OBJ(arg)).mark_all(<span class="keyword">true</span>);
00180              $$ = <span class="keyword">true</span>;
00181          }
00182                  <span class="comment">/* projection only */</span>
00183                  | projection
00184          <span class="comment">/* selection only --&gt; project everything */</span>
00185                  | <span class="charliteral">'&amp;'</span> { (*DDS_OBJ(arg)).mark_all(<span class="keyword">true</span>); } selection
00186                  { 
00187              $$ = $3;
00188          }
00189                  | projection <span class="charliteral">'&amp;'</span> selection
00190                  {
00191              $$ = $1 &amp;&amp; $3;
00192          }
00193 ;
00194 
00195 projection:     proj_clause
00196                 | proj_clause <span class="charliteral">','</span> projection
00197                 {
00198             $$ = $1 &amp;&amp; $3;
00199         }
00200 ;
00201 
00202 proj_clause:    SCAN_WORD 
00203                 { 
00204             <a class="code" href="classBaseType.html">BaseType</a> *var = (*DDS_OBJ(arg)).var($1);
00205             <span class="keywordflow">if</span> (var) {
00206             <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Marking "</span> &lt;&lt; $1 &lt;&lt; endl);
00207             $$ = (*DDS_OBJ(arg)).mark($1, <span class="keyword">true</span>);
00208             <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"result: "</span> &lt;&lt; $$ &lt;&lt; endl);
00209             }
00210             <span class="keywordflow">else</span> {
00211             no_such_ident(arg, $1, <span class="stringliteral">"identifier"</span>);
00212             }
00213         }
00214                 | proj_function
00215                 {
00216             $$ = $1;
00217         }
00218         | array_proj
00219                 {
00220             $$ = $1;
00221         }
00222 ;
00223 
00224 proj_function:  SCAN_WORD <span class="charliteral">'('</span> arg_list <span class="charliteral">')'</span>
00225             {
00226             <a class="code" href="expr_8h.html#a2">proj_func</a> p_f = 0;
00227             <a class="code" href="expr_8h.html#a1">btp_func</a> <a class="code" href="expr_8y.html#a5">f</a> = 0;
00228 
00229             <span class="keywordflow">if</span> ((<a class="code" href="expr_8y.html#a5">f</a> = get_btp_function(*(DDS_OBJ(arg)), $1))) {
00230             (*DDS_OBJ(arg)).append_clause(<a class="code" href="expr_8y.html#a5">f</a>, $3);
00231             $$ = <span class="keyword">true</span>;
00232             }
00233             <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((p_f = get_proj_function(*(DDS_OBJ(arg)), $1))) {
00234             <a class="code" href="classBaseType.html">BaseType</a> **args = <a class="code" href="RValue_8cc.html#a1">build_btp_args</a>($3, *(DDS_OBJ(arg)));
00235             (*p_f)(($3) ? $3-&gt;size():0, args, *(DDS_OBJ(arg)));
00236             $$ = <span class="keyword">true</span>;
00237             }
00238             <span class="keywordflow">else</span> {
00239             no_such_func(arg, $1);
00240             }
00241         }
00242 ;
00243 
00244 selection:  clause
00245         | selection <span class="charliteral">'&amp;'</span> clause
00246                 {
00247             $$ = $1 &amp;&amp; $3;
00248         }
00249 ;
00250 
00251 clause:     r_value rel_op <span class="charliteral">'{'</span> r_value_list <span class="charliteral">'}'</span>
00252                 {
00253             <span class="keywordflow">if</span> ($1) {
00254             (*DDS_OBJ(arg)).append_clause($2, $1, $4);
00255             $$ = <span class="keyword">true</span>;
00256             }
00257             <span class="keywordflow">else</span>
00258             $$ = <span class="keyword">false</span>;
00259         }
00260         | r_value rel_op r_value
00261                 {
00262             <span class="keywordflow">if</span> ($1) {
00263             <a class="code" href="RValue_8h.html#a0">rvalue_list</a> *rv = <span class="keyword">new</span> <a class="code" href="RValue_8h.html#a0">rvalue_list</a>;
00264             rv-&gt;push_back($3);
00265             (*DDS_OBJ(arg)).append_clause($2, $1, rv);
00266             $$ = <span class="keyword">true</span>;
00267             }
00268             <span class="keywordflow">else</span>
00269             $$ = <span class="keyword">false</span>;
00270         }
00271         | bool_function
00272                 {
00273             $$ = $1;
00274         }
00275 ;
00276 
00277 bool_function: SCAN_WORD <span class="charliteral">'('</span> arg_list <span class="charliteral">')'</span>
00278            {
00279            <a class="code" href="expr_8h.html#a0">bool_func</a> b_func = get_function((*DDS_OBJ(arg)), $1);
00280            <span class="keywordflow">if</span> (!b_func) {
00281                no_such_func(arg, $1);
00282            }
00283            <span class="keywordflow">else</span> {
00284                (*DDS_OBJ(arg)).append_clause(b_func, $3);
00285                $$ = <span class="keyword">true</span>;
00286            }
00287            }
00288 ;
00289 
00290 r_value:        id_or_const
00291         | <span class="charliteral">'*'</span> id_or_const
00292         {
00293             $$ = dereference_variable($2, *DDS_OBJ(arg));
00294             <span class="keywordflow">if</span> (!$$) {
00295             exprerror(<span class="stringliteral">"Could not dereference the URL"</span>, 
00296                   ($2)-&gt;value_name());
00297             }
00298         }
00299         | SCAN_WORD <span class="charliteral">'('</span> arg_list <span class="charliteral">')'</span>
00300         {
00301             <a class="code" href="expr_8h.html#a1">btp_func</a> func = get_btp_function((*DDS_OBJ(arg)), $1);
00302             <span class="keywordflow">if</span> (func) {
00303             $$ = <span class="keyword">new</span> <a class="code" href="classrvalue.html">rvalue</a>(func, $3);
00304             } 
00305             <span class="keywordflow">else</span> {          
00306             no_such_func(arg, $1);
00307             }
00308         }
00309 ;
00310 
00311 r_value_list:   r_value
00312         {
00313             <span class="keywordflow">if</span> ($1)
00314             $$ = make_rvalue_list($1);
00315             <span class="keywordflow">else</span>
00316             $$ = 0;
00317         }
00318         | r_value_list <span class="charliteral">','</span> r_value
00319                 {
00320             <span class="keywordflow">if</span> ($1 &amp;&amp; $3)
00321             $$ = append_rvalue_list($1, $3);
00322             <span class="keywordflow">else</span>
00323             $$ = 0;
00324         }
00325 ;
00326 
00327 arg_list:     r_value_list
00328               {  
00329           $$ = $1;
00330           }
00331               | <span class="comment">/* Null, argument lists may be empty */</span>
00332               { 
00333           $$ = 0; 
00334           }
00335 ;
00336 
00337 id_or_const:    SCAN_WORD
00338         { 
00339             <a class="code" href="classBaseType.html">BaseType</a> *btp = (*DDS_OBJ(arg)).var(<a class="code" href="escaping_8cc.html#a7">www2id</a>(string($1)));
00340             <span class="keywordflow">if</span> (!btp) {
00341             <a class="code" href="structvalue.html">value</a> new_val;
00342             <span class="keywordflow">if</span> (<a class="code" href="parser-util_8cc.html#a10">check_int32</a>($1)) {
00343                 new_val.<a class="code" href="structvalue.html#valuem0">type</a> = <a class="code" href="BaseType_8h.html#a29a17">dods_int32_c</a>;
00344                 new_val.<a class="code" href="structvalue.html#valuem5">v</a>.i = atoi($1);
00345             }
00346             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="parser-util_8cc.html#a11">check_uint32</a>($1)) {
00347                 new_val.<a class="code" href="structvalue.html#valuem0">type</a> = <a class="code" href="BaseType_8h.html#a29a18">dods_uint32_c</a>;
00348                 new_val.<a class="code" href="structvalue.html#valuem5">v</a>.ui = atoi($1);
00349             }
00350             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="parser-util_8cc.html#a13">check_float64</a>($1)) {
00351                 new_val.<a class="code" href="structvalue.html#valuem0">type</a> = <a class="code" href="BaseType_8h.html#a29a20">dods_float64_c</a>;
00352                 new_val.<a class="code" href="structvalue.html#valuem5">v</a>.f = atof($1);
00353             }
00354             <span class="keywordflow">else</span> {
00355                 new_val.<a class="code" href="structvalue.html#valuem0">type</a> = <a class="code" href="BaseType_8h.html#a29a21">dods_str_c</a>;
00356                 new_val.<a class="code" href="structvalue.html#valuem5">v</a>.s = <span class="keyword">new</span> string($1);
00357             }
00358             <a class="code" href="classBaseType.html">BaseType</a> *btp = make_variable((*DDS_OBJ(arg)), new_val); 
00359             <span class="comment">// *** test for btp == null</span>
00360             <span class="comment">// delete new_val.v.s; // Str::val2buf copies the value.</span>
00361             $$ = <span class="keyword">new</span> <a class="code" href="classrvalue.html">rvalue</a>(btp);
00362             }
00363             <span class="keywordflow">else</span>
00364             $$ = <span class="keyword">new</span> <a class="code" href="classrvalue.html">rvalue</a>(btp);
00365         }
00366         | SCAN_STR
00367                 { 
00368             <a class="code" href="classBaseType.html">BaseType</a> *btp = make_variable((*DDS_OBJ(arg)), $1); 
00369             $$ = <span class="keyword">new</span> <a class="code" href="classrvalue.html">rvalue</a>(btp);
00370         }
00371 ;
00372 
00373 array_proj: SCAN_WORD array_indices 
00374                 {
00375           <span class="keywordflow">if</span> (!bracket_projection((*DDS_OBJ(arg)), $1, $2))
00376             <span class="comment">// no_such_ident throws an exception.</span>
00377             no_such_ident(arg, $1, <span class="stringliteral">"array, grid or sequence"</span>);
00378           <span class="keywordflow">else</span>
00379             $$ = <span class="keyword">true</span>;
00380         }
00381 ;
00382 
00383 array_indices:  array_index
00384                 {
00385             $$ = make_array_indices($1);
00386         }
00387                 | array_indices array_index
00388                 {
00389             $$ = append_array_index($1, $2);
00390         }
00391 ;
00392 
00393 array_index:    <span class="charliteral">'['</span> SCAN_WORD <span class="charliteral">']'</span>
00394                 {
00395             <span class="keywordflow">if</span> (!<a class="code" href="parser-util_8cc.html#a11">check_uint32</a>($2)) {
00396             string <a class="code" href="dds_8y.html#a20">msg</a> = <span class="stringliteral">"The word `"</span>;
00397             <a class="code" href="dds_8y.html#a20">msg</a> += string($2) + <span class="stringliteral">"' is not a valid array index."</span>;
00398             <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(malformed_expr, <a class="code" href="dds_8y.html#a20">msg</a>);
00399             }
00400             <a class="code" href="structvalue.html">value</a> i;
00401             i.<a class="code" href="structvalue.html#valuem0">type</a> = <a class="code" href="BaseType_8h.html#a29a18">dods_uint32_c</a>;
00402             i.<a class="code" href="structvalue.html#valuem5">v</a>.i = atoi($2);
00403             $$ = make_array_index(i);
00404         }
00405         |<span class="charliteral">'['</span> SCAN_WORD <span class="charliteral">':'</span> SCAN_WORD <span class="charliteral">']'</span>
00406                 {
00407             <span class="keywordflow">if</span> (!<a class="code" href="parser-util_8cc.html#a11">check_uint32</a>($2)) {
00408             string <a class="code" href="dds_8y.html#a20">msg</a> = <span class="stringliteral">"The word `"</span>;
00409             <a class="code" href="dds_8y.html#a20">msg</a> += string($2) + <span class="stringliteral">"' is not a valid array index."</span>;
00410             <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(malformed_expr, <a class="code" href="dds_8y.html#a20">msg</a>);
00411             }
00412             <span class="keywordflow">if</span> (!<a class="code" href="parser-util_8cc.html#a11">check_uint32</a>($4)) {
00413             string <a class="code" href="dds_8y.html#a20">msg</a> = <span class="stringliteral">"The word `"</span>;
00414             <a class="code" href="dds_8y.html#a20">msg</a> += string($4) + <span class="stringliteral">"' is not a valid array index."</span>;
00415             <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(malformed_expr, <a class="code" href="dds_8y.html#a20">msg</a>);
00416             }
00417             <a class="code" href="structvalue.html">value</a> i,j;
00418             i.<a class="code" href="structvalue.html#valuem0">type</a> = j.<a class="code" href="structvalue.html#valuem0">type</a> = <a class="code" href="BaseType_8h.html#a29a18">dods_uint32_c</a>;
00419             i.<a class="code" href="structvalue.html#valuem5">v</a>.i = atoi($2);
00420             j.<a class="code" href="structvalue.html#valuem5">v</a>.i = atoi($4);
00421             $$ = make_array_index(i, j);
00422         }
00423         | <span class="charliteral">'['</span> SCAN_WORD <span class="charliteral">':'</span> SCAN_WORD <span class="charliteral">':'</span> SCAN_WORD <span class="charliteral">']'</span>
00424                 {
00425             <span class="keywordflow">if</span> (!<a class="code" href="parser-util_8cc.html#a11">check_uint32</a>($2)) {
00426             string <a class="code" href="dds_8y.html#a20">msg</a> = <span class="stringliteral">"The word `"</span>;
00427             <a class="code" href="dds_8y.html#a20">msg</a> += string($2) + <span class="stringliteral">"' is not a valid array index."</span>;
00428             <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(malformed_expr, <a class="code" href="dds_8y.html#a20">msg</a>);
00429             }
00430             <span class="keywordflow">if</span> (!<a class="code" href="parser-util_8cc.html#a11">check_uint32</a>($4)) {
00431             string <a class="code" href="dds_8y.html#a20">msg</a> = <span class="stringliteral">"The word `"</span>;
00432             <a class="code" href="dds_8y.html#a20">msg</a> += string($4) + <span class="stringliteral">"' is not a valid array index."</span>;
00433             <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(malformed_expr, <a class="code" href="dds_8y.html#a20">msg</a>);
00434             }
00435             <span class="keywordflow">if</span> (!<a class="code" href="parser-util_8cc.html#a11">check_uint32</a>($6)) {
00436             string <a class="code" href="dds_8y.html#a20">msg</a> = <span class="stringliteral">"The word `"</span>;
00437             <a class="code" href="dds_8y.html#a20">msg</a> += string($6) + <span class="stringliteral">"' is not a valid array index."</span>;
00438             <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(malformed_expr, <a class="code" href="dds_8y.html#a20">msg</a>);
00439             }
00440             <a class="code" href="structvalue.html">value</a> i, j, k;
00441             i.<a class="code" href="structvalue.html#valuem0">type</a> = j.<a class="code" href="structvalue.html#valuem0">type</a> = k.<a class="code" href="structvalue.html#valuem0">type</a> = <a class="code" href="BaseType_8h.html#a29a18">dods_uint32_c</a>;
00442             i.<a class="code" href="structvalue.html#valuem5">v</a>.i = atoi($2);
00443             j.<a class="code" href="structvalue.html#valuem5">v</a>.i = atoi($4);
00444             k.<a class="code" href="structvalue.html#valuem5">v</a>.i = atoi($6);
00445             $$ = make_array_index(i, j, k);
00446         }
00447 ;
00448 
00449 rel_op:     SCAN_EQUAL
00450         | SCAN_NOT_EQUAL
00451         | SCAN_GREATER
00452         | SCAN_GREATER_EQL
00453         | SCAN_LESS
00454         | SCAN_LESS_EQL
00455         | SCAN_REGEXP
00456 ;
00457 
00458 %%
00459 
00460 <span class="comment">// All these error reporting function now throw instnaces of Error. The expr</span>
00461 <span class="comment">// parser no longer returns an error code to indicate and error. 2/16/2000</span>
00462 <span class="comment">// jhrg.</span>
00463 
00464 <span class="keywordtype">void</span>
00465 exprerror(<span class="keyword">const</span> string &amp;s)
00466 { 
00467     exprerror(s.c_str());
00468 }
00469 
00470 <span class="keywordtype">void</span>
00471 exprerror(<span class="keyword">const</span> <span class="keywordtype">char</span> *s)
00472 {
00473     <span class="comment">// cerr &lt;&lt; "Expression parse error: " &lt;&lt; s &lt;&lt; endl;</span>
00474     string <a class="code" href="dds_8y.html#a20">msg</a> = <span class="stringliteral">"Constraint expression parse error: "</span> + (string)s;
00475     <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(malformed_expr, <a class="code" href="dds_8y.html#a20">msg</a>);
00476 }
00477 
00478 <span class="keywordtype">void</span>
00479 exprerror(<span class="keyword">const</span> string &amp;s, <span class="keyword">const</span> string &amp;s2)
00480 {
00481     exprerror(s.c_str(), s2.c_str());
00482 }
00483 
00484 <span class="keywordtype">void</span>
00485 exprerror(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keyword">const</span> <span class="keywordtype">char</span> *s2)
00486 {
00487     string <a class="code" href="dds_8y.html#a20">msg</a> = <span class="stringliteral">"Constraint expression parse error: "</span> + (string)s + <span class="stringliteral">": "</span> 
00488     + (string)s2;
00489     <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(malformed_expr, <a class="code" href="dds_8y.html#a20">msg</a>);
00490 }
00491 
00492 <span class="keywordtype">void</span>
00493 no_such_ident(<span class="keywordtype">void</span> *arg, <span class="keyword">const</span> string &amp;<a class="code" href="das_8y.html#a18">name</a>, <span class="keyword">const</span> string &amp;word)
00494 {
00495     string <a class="code" href="dds_8y.html#a20">msg</a> = <span class="stringliteral">"No such "</span> + word + <span class="stringliteral">" in dataset"</span>;
00496     exprerror(<a class="code" href="dds_8y.html#a20">msg</a>.c_str(), <a class="code" href="das_8y.html#a18">name</a>);
00497     <span class="comment">//    no_such_ident(arg, name.c_str(), word.c_str());</span>
00498 }
00499 
00500 <span class="keywordtype">void</span>
00501 no_such_ident(<span class="keywordtype">void</span> *arg, <span class="keywordtype">char</span> *<a class="code" href="das_8y.html#a18">name</a>, <span class="keywordtype">char</span> *word)
00502 {
00503     string <a class="code" href="dds_8y.html#a20">msg</a> = <span class="stringliteral">"No such "</span> + (string)word + <span class="stringliteral">" in dataset"</span>;
00504     exprerror(<a class="code" href="dds_8y.html#a20">msg</a>.c_str(), <a class="code" href="das_8y.html#a18">name</a>);
00505 }
00506 
00507 <span class="keywordtype">void</span>
00508 no_such_func(<span class="keywordtype">void</span> *arg, <span class="keyword">const</span> string &amp;<a class="code" href="das_8y.html#a18">name</a>)
00509 {
00510     no_such_func(arg, <a class="code" href="das_8y.html#a18">name</a>.c_str());
00511 }
00512 
00513 <span class="keywordtype">void</span>
00514 no_such_func(<span class="keywordtype">void</span> *arg, <span class="keywordtype">char</span> *<a class="code" href="das_8y.html#a18">name</a>)
00515 {
00516     exprerror(<span class="stringliteral">"Not a registered function"</span>, <a class="code" href="das_8y.html#a18">name</a>);
00517 }
00518 
00519 <span class="keywordtype">bool</span>
00520 bracket_projection(<a class="code" href="classDDS.html">DDS</a> &amp;table, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="das_8y.html#a18">name</a>, <a class="code" href="expr_8h.html#a6">int_list_list</a> *indices)
00521 {
00522     <span class="keywordtype">bool</span> status = <span class="keyword">true</span>;
00523     <a class="code" href="classBaseType.html">BaseType</a> *var = table.<a class="code" href="classDDS.html#DDSa6">var</a>(<a class="code" href="das_8y.html#a18">name</a>);
00524 
00525     <span class="keywordflow">if</span> (var &amp;&amp; is_array_t(var)) {
00526     <span class="comment">/* calls to set_send_p should be replaced with</span>
00527 <span class="comment">       calls to DDS::mark so that arrays of Structures,</span>
00528 <span class="comment">       etc. will be processed correctly when individual</span>
00529 <span class="comment">       elements are projected using short names (Whew!)</span>
00530 <span class="comment">       9/1/98 jhrg */</span>
00531     <span class="comment">/* var-&gt;set_send_p(true); */</span>
00532     table.<a class="code" href="classDDS.html#DDSa49">mark</a>(<a class="code" href="das_8y.html#a18">name</a>, <span class="keyword">true</span>);
00533     status = process_array_indices(var, indices);
00534     <span class="keywordflow">if</span> (!status) {
00535         string <a class="code" href="dds_8y.html#a20">msg</a> = <span class="stringliteral">"The indices given for `"</span>;
00536         <a class="code" href="dds_8y.html#a20">msg</a> += (string)<a class="code" href="das_8y.html#a18">name</a> + (string)<span class="stringliteral">"' are out of range."</span>;
00537         <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(malformed_expr, <a class="code" href="dds_8y.html#a20">msg</a>);
00538     }
00539     delete_array_indices(indices);
00540     }
00541     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (var &amp;&amp; is_grid_t(var)) {
00542     table.<a class="code" href="classDDS.html#DDSa49">mark</a>(<a class="code" href="das_8y.html#a18">name</a>, <span class="keyword">true</span>);
00543     <span class="comment">/* var-&gt;set_send_p(true); */</span>
00544     status = process_grid_indices(var, indices);
00545     <span class="keywordflow">if</span> (!status) {
00546         string <a class="code" href="dds_8y.html#a20">msg</a> = <span class="stringliteral">"The indices given for `"</span>;
00547         <a class="code" href="dds_8y.html#a20">msg</a> += (string)<a class="code" href="das_8y.html#a18">name</a> + (string)<span class="stringliteral">"' are out of range."</span>;
00548         <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(malformed_expr, <a class="code" href="dds_8y.html#a20">msg</a>);
00549     }
00550     delete_array_indices(indices);
00551     }
00552     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (var &amp;&amp; is_sequence_t(var)) {
00553     table.<a class="code" href="classDDS.html#DDSa49">mark</a>(<a class="code" href="das_8y.html#a18">name</a>, <span class="keyword">true</span>);
00554     status = process_sequence_indices(var, indices);
00555     <span class="keywordflow">if</span> (!status) {
00556         string <a class="code" href="dds_8y.html#a20">msg</a> = <span class="stringliteral">"The indices given for `"</span>;
00557         <a class="code" href="dds_8y.html#a20">msg</a> += (string)<a class="code" href="das_8y.html#a18">name</a> + (string)<span class="stringliteral">"' are out of range."</span>;
00558         <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(malformed_expr, <a class="code" href="dds_8y.html#a20">msg</a>);
00559     }
00560     delete_array_indices(indices);
00561     }
00562     <span class="keywordflow">else</span> {
00563     status = <span class="keyword">false</span>;
00564     }
00565   
00566     <span class="keywordflow">return</span> status;
00567 }
00568 
00569 <span class="comment">// Given three values (I1, I2, I3), all of which must be integers, build an</span>
00570 <span class="comment">// int_list which contains those values.</span>
00571 <span class="comment">//</span>
00572 <span class="comment">// Returns: A pointer to an int_list of three integers or NULL if any of the</span>
00573 <span class="comment">// values are not integers.</span>
00574 
00575 <a class="code" href="classstd_1_1vector.html">int_list</a> *
00576 make_array_index(<a class="code" href="structvalue.html">value</a> &amp;i1, <a class="code" href="structvalue.html">value</a> &amp;i2, <a class="code" href="structvalue.html">value</a> &amp;i3)
00577 {
00578     <a class="code" href="classstd_1_1vector.html">int_list</a> *index = <span class="keyword">new</span> <a class="code" href="classstd_1_1vector.html">int_list</a>;
00579 
00580     <span class="keywordflow">if</span> (i1.<a class="code" href="structvalue.html#valuem0">type</a> != <a class="code" href="BaseType_8h.html#a29a18">dods_uint32_c</a>
00581     || i2.<a class="code" href="structvalue.html#valuem0">type</a> != <a class="code" href="BaseType_8h.html#a29a18">dods_uint32_c</a>
00582     || i3.<a class="code" href="structvalue.html#valuem0">type</a> != <a class="code" href="BaseType_8h.html#a29a18">dods_uint32_c</a>)
00583     <span class="keywordflow">return</span> (int_list *)0;
00584 
00585     index-&gt;push_back((<span class="keywordtype">int</span>)i1.<a class="code" href="structvalue.html#valuem5">v</a>.i);
00586     index-&gt;push_back((<span class="keywordtype">int</span>)i2.<a class="code" href="structvalue.html#valuem5">v</a>.i);
00587     index-&gt;push_back((<span class="keywordtype">int</span>)i3.<a class="code" href="structvalue.html#valuem5">v</a>.i);
00588 
00589     <a class="code" href="debug_8h.html#a1">DBG</a>(cout &lt;&lt; <span class="stringliteral">"index: "</span>;\
00590     <span class="keywordflow">for</span> (<a class="code" href="expr_8h.html#a5">int_iter</a> dp = index-&gt;begin(); dp != index-&gt;end(); dp++)\
00591     cout &lt;&lt; (*dp) &lt;&lt; <span class="stringliteral">" "</span>;\
00592     cout &lt;&lt; endl);
00593 
00594     <span class="keywordflow">return</span> index;
00595 }
00596 
00597 int_list *
00598 make_array_index(<a class="code" href="structvalue.html">value</a> &amp;i1, <a class="code" href="structvalue.html">value</a> &amp;i2)
00599 {
00600     int_list *index = <span class="keyword">new</span> int_list;
00601 
00602     <span class="keywordflow">if</span> (i1.<a class="code" href="structvalue.html#valuem0">type</a> != <a class="code" href="BaseType_8h.html#a29a18">dods_uint32_c</a> || i2.<a class="code" href="structvalue.html#valuem0">type</a> != <a class="code" href="BaseType_8h.html#a29a18">dods_uint32_c</a>)
00603     <span class="keywordflow">return</span> (int_list *)0;
00604 
00605     index-&gt;push_back((<span class="keywordtype">int</span>)i1.<a class="code" href="structvalue.html#valuem5">v</a>.i);
00606     index-&gt;push_back(1);
00607     index-&gt;push_back((<span class="keywordtype">int</span>)i2.<a class="code" href="structvalue.html#valuem5">v</a>.i);
00608 
00609     <a class="code" href="debug_8h.html#a1">DBG</a>(cout &lt;&lt; <span class="stringliteral">"index: "</span>;\
00610     <span class="keywordflow">for</span> (<a class="code" href="expr_8h.html#a4">int_citer</a> dp = index-&gt;begin(); dp != index-&gt;end(); dp++)\
00611     cout &lt;&lt; (*dp) &lt;&lt; <span class="stringliteral">" "</span>;\
00612     cout &lt;&lt; endl);
00613 
00614     <span class="keywordflow">return</span> index;
00615 }
00616 
00617 int_list *
00618 make_array_index(<a class="code" href="structvalue.html">value</a> &amp;i1)
00619 {
00620     int_list *index = <span class="keyword">new</span> int_list;
00621 
00622     <span class="keywordflow">if</span> (i1.<a class="code" href="structvalue.html#valuem0">type</a> != <a class="code" href="BaseType_8h.html#a29a18">dods_uint32_c</a>)
00623     <span class="keywordflow">return</span> (int_list *)0;
00624 
00625     index-&gt;push_back((<span class="keywordtype">int</span>)i1.<a class="code" href="structvalue.html#valuem5">v</a>.i);
00626     index-&gt;push_back(1);
00627     index-&gt;push_back((<span class="keywordtype">int</span>)i1.<a class="code" href="structvalue.html#valuem5">v</a>.i);
00628 
00629     <a class="code" href="debug_8h.html#a1">DBG</a>(cout &lt;&lt; <span class="stringliteral">"index: "</span>;\
00630     <span class="keywordflow">for</span> (<a class="code" href="expr_8h.html#a4">int_citer</a> dp = index-&gt;begin(); dp != index-&gt;end(); dp++)\
00631     cout &lt;&lt; (*dp) &lt;&lt; <span class="stringliteral">" "</span>;\
00632     cout &lt;&lt; endl);
00633 
00634     <span class="keywordflow">return</span> index;
00635 }
00636 
00637 <a class="code" href="expr_8h.html#a6">int_list_list</a> *
00638 make_array_indices(int_list *index)
00639 {
00640     <a class="code" href="expr_8h.html#a6">int_list_list</a> *indices = <span class="keyword">new</span> <a class="code" href="expr_8h.html#a6">int_list_list</a>;
00641 
00642     <a class="code" href="debug_8h.html#a1">DBG</a>(cout &lt;&lt; <span class="stringliteral">"index: "</span>;\
00643     <span class="keywordflow">for</span> (<a class="code" href="expr_8h.html#a4">int_citer</a> dp = index-&gt;begin(); dp != index-&gt;end(); dp++)\
00644     cout &lt;&lt; (*dp) &lt;&lt; <span class="stringliteral">" "</span>;\
00645     cout &lt;&lt; endl);
00646 
00647     assert(index);
00648     indices-&gt;push_back(index);
00649 
00650     <span class="keywordflow">return</span> indices;
00651 }
00652 
00653 <a class="code" href="expr_8h.html#a6">int_list_list</a> *
00654 append_array_index(<a class="code" href="expr_8h.html#a6">int_list_list</a> *indices, int_list *index)
00655 {
00656     assert(indices);
00657     assert(index);
00658 
00659     indices-&gt;push_back(index);
00660 
00661     <span class="keywordflow">return</span> indices;
00662 }
00663 
00664 <span class="comment">// Delete an array indices list. </span>
00665 
00666 <span class="keywordtype">void</span>
00667 delete_array_indices(<a class="code" href="expr_8h.html#a6">int_list_list</a> *indices)
00668 {
00669     assert(indices);
00670 
00671     <span class="keywordflow">for</span> (<a class="code" href="expr_8h.html#a7">int_list_citer</a> i = indices-&gt;begin(); i != indices-&gt;end(); i++) {
00672     int_list *il = *i ;
00673     assert(il);
00674     <span class="keyword">delete</span> il;
00675     }
00676 
00677     <span class="keyword">delete</span> indices;
00678 }
00679 
00680 <span class="keywordtype">bool</span>
00681 is_array_t(<a class="code" href="classBaseType.html">BaseType</a> *variable)
00682 {
00683     assert(variable);
00684 
00685     <span class="keywordflow">if</span> (variable-&gt;<a class="code" href="classBaseType.html#Vectora29">type</a>() != <a class="code" href="BaseType_8h.html#a29a23">dods_array_c</a>)
00686     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00687     <span class="keywordflow">else</span>
00688     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00689 }
00690 
00691 <span class="keywordtype">bool</span>
00692 is_grid_t(<a class="code" href="classBaseType.html">BaseType</a> *variable)
00693 {
00694     assert(variable);
00695 
00696     <span class="keywordflow">if</span> (variable-&gt;<a class="code" href="classBaseType.html#Vectora29">type</a>() != <a class="code" href="BaseType_8h.html#a29a27">dods_grid_c</a>)
00697     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00698     <span class="keywordflow">else</span>
00699     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00700 }
00701 
00702 <span class="keywordtype">bool</span>
00703 is_sequence_t(<a class="code" href="classBaseType.html">BaseType</a> *variable)
00704 {
00705     assert(variable);
00706 
00707     <span class="keywordflow">if</span> (variable-&gt;<a class="code" href="classBaseType.html#Vectora29">type</a>() != <a class="code" href="BaseType_8h.html#a29a26">dods_sequence_c</a>)
00708     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00709     <span class="keywordflow">else</span>
00710     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00711 }
00712 
00713 <span class="keywordtype">bool</span>
00714 process_array_indices(<a class="code" href="classBaseType.html">BaseType</a> *variable, <a class="code" href="expr_8h.html#a6">int_list_list</a> *indices)
00715 {
00716     <span class="keywordtype">bool</span> status = <span class="keyword">true</span>;
00717 
00718     assert(variable);
00719 
00720     <a class="code" href="classArray.html">Array</a> *a = dynamic_cast&lt;Array *&gt;(variable); <span class="comment">// replace with dynamic cast</span>
00721     <span class="keywordflow">if</span> (!a)
00722     <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(malformed_expr, 
00723        string(<span class="stringliteral">"The constraint expression evaluator expected an array; "</span>)
00724             + variable-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>() + <span class="stringliteral">" is not an array."</span>);
00725            
00726     <span class="keywordflow">if</span> (a-&gt;<a class="code" href="classArray.html#Arraya25">dimensions</a>(<span class="keyword">true</span>) != (unsigned)indices-&gt;size())
00727     <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(malformed_expr, 
00728        string(<span class="stringliteral">"Error: The number of dimenstions in the constraint for "</span>)
00729             + variable-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>() 
00730             + <span class="stringliteral">" must match the number in the array."</span>);
00731            
00732     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Before clear_costraint:"</span> &lt;&lt; endl);
00733     <a class="code" href="debug_8h.html#a1">DBG</a>(a-&gt;<a class="code" href="classArray.html#Arraya26">print_decl</a>(stderr, <span class="stringliteral">""</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>));
00734 
00735     a-&gt;<a class="code" href="classArray.html#Arraya10">clear_constraint</a>();  <span class="comment">// each projection erases the previous one</span>
00736 
00737     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"After clear_costraint:"</span> &lt;&lt; endl);
00738     <a class="code" href="debug_8h.html#a1">DBG</a>(a-&gt;<a class="code" href="classArray.html#Arraya26">print_decl</a>(stderr, <span class="stringliteral">""</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>));
00739 
00740     assert(indices);
00741     <a class="code" href="expr_8h.html#a7">int_list_citer</a> <a class="code" href="AttrTable_8cc.html#a1">p</a> = indices-&gt;begin() ;
00742     <a class="code" href="classArray.html#Arrays1">Array::Dim_iter</a> r = a-&gt;<a class="code" href="classArray.html#Arraya13">dim_begin</a>() ;
00743     <span class="keywordflow">for</span> (; <a class="code" href="AttrTable_8cc.html#a1">p</a> != indices-&gt;end() &amp;&amp; r != a-&gt;<a class="code" href="classArray.html#Arraya14">dim_end</a>(); <a class="code" href="AttrTable_8cc.html#a1">p</a>++, r++) {
00744     int_list *index = *<a class="code" href="AttrTable_8cc.html#a1">p</a>;
00745     assert(index);
00746 
00747     <a class="code" href="expr_8h.html#a4">int_citer</a> q = index-&gt;begin(); 
00748     assert(q!=index-&gt;end());
00749     <span class="keywordtype">int</span> start = *q;
00750 
00751     q++;
00752     <span class="keywordtype">int</span> stride = *q;
00753     
00754     q++;
00755     <span class="keywordtype">int</span> stop = *q;
00756 
00757     q++;
00758     <span class="keywordflow">if</span> (q != index-&gt;end()) {
00759         <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(malformed_expr,
00760             string(<span class="stringliteral">"Too many values in index list for "</span>)
00761             + a-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>() + <span class="stringliteral">"."</span>);
00762     }
00763 
00764     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"process_array_indices: Setting constraint on "</span>\
00765         &lt;&lt; a-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>() &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; start &lt;&lt; <span class="stringliteral">":"</span> &lt;&lt; stop &lt;&lt; <span class="stringliteral">"]"</span> &lt;&lt; endl);
00766 
00767     a-&gt;<a class="code" href="classArray.html#Arraya7">add_constraint</a>(r, start, stride, stop);
00768 
00769     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Set Constraint: "</span> &lt;&lt; a-&gt;<a class="code" href="classArray.html#Arraya15">dimension_size</a>(r, <span class="keyword">true</span>) &lt;&lt; endl);
00770     }
00771 
00772     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"After processing loop:"</span> &lt;&lt; endl);
00773     <a class="code" href="debug_8h.html#a1">DBG</a>(a-&gt;<a class="code" href="classArray.html#Arraya26">print_decl</a>(stderr, <span class="stringliteral">""</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>));
00774 
00775     <a class="code" href="debug_8h.html#a1">DBG</a>(cout &lt;&lt; <span class="stringliteral">"Array Constraint: "</span>;\
00776     <span class="keywordflow">for</span> (<a class="code" href="classArray.html#Arrays1">Array::Dim_iter</a> dp = a-&gt;<a class="code" href="classArray.html#Arraya13">dim_begin</a>(); dp != a-&gt;<a class="code" href="classArray.html#Arraya14">dim_end</a>(); dp++)\
00777         cout &lt;&lt; a-&gt;<a class="code" href="classArray.html#Arraya15">dimension_size</a>(dp, <span class="keyword">true</span>) &lt;&lt; <span class="stringliteral">" "</span>;\
00778     cout &lt;&lt; endl);
00779     
00780     <span class="keywordflow">if</span> (p != indices-&gt;end() &amp;&amp; r == a-&gt;<a class="code" href="classArray.html#Arraya14">dim_end</a>()) {
00781     <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(malformed_expr,
00782             string(<span class="stringliteral">"Too many indices in constraint for "</span>)
00783             + a-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>() + <span class="stringliteral">"."</span>);
00784     }
00785 
00786     <span class="keywordflow">return</span> status;
00787 }
00788 
00789 <span class="keywordtype">bool</span>
00790 process_grid_indices(<a class="code" href="classBaseType.html">BaseType</a> *variable, <a class="code" href="expr_8h.html#a6">int_list_list</a> *indices)
00791 {
00792     <span class="keywordtype">bool</span> status = <span class="keyword">true</span>;
00793 
00794     assert(variable);
00795     assert(variable-&gt;<a class="code" href="classBaseType.html#Vectora29">type</a>() == <a class="code" href="BaseType_8h.html#a29a27">dods_grid_c</a>);
00796     <a class="code" href="classGrid.html">Grid</a> *g = dynamic_cast&lt;Grid *&gt;(variable);
00797     <span class="keywordflow">if</span> (!g)
00798     <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(unknown_error, <span class="stringliteral">"Expected a Grid variable"</span>);
00799 
00800     <a class="code" href="classArray.html">Array</a> *a = dynamic_cast&lt;Array *&gt;(g-&gt;<a class="code" href="classGrid.html#Grida11">array_var</a>());
00801     <span class="keywordflow">if</span> (!a)
00802     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, <span class="stringliteral">"Malformed Grid variable"</span>);
00803     <span class="keywordflow">if</span> (a-&gt;<a class="code" href="classArray.html#Arraya25">dimensions</a>(<span class="keyword">true</span>) != (unsigned)indices-&gt;size())
00804     <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(malformed_expr, 
00805        string(<span class="stringliteral">"Error: The number of dimenstions in the constraint for "</span>)
00806             + variable-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>() 
00807             + <span class="stringliteral">" must match the number in the grid."</span>);
00808            
00809     <span class="comment">// First do the constraints on the ARRAY in the grid.</span>
00810     process_array_indices(g-&gt;<a class="code" href="classGrid.html#Grida11">array_var</a>(), indices);
00811 
00812     <span class="comment">// Now process the maps.</span>
00813     <a class="code" href="classGrid.html#Grids1">Grid::Map_iter</a> r = g-&gt;<a class="code" href="classGrid.html#Grida27">map_begin</a>() ;
00814 
00815     <span class="comment">// Supress all maps by default.</span>
00816     <span class="keywordflow">for</span> (; r != g-&gt;<a class="code" href="classGrid.html#Grida28">map_end</a>(); r++)
00817     {
00818     (*r)-&gt;set_send_p(<span class="keyword">false</span>);
00819     }
00820 
00821     <span class="comment">// Add specified maps to the current projection.</span>
00822     assert(indices);
00823     <a class="code" href="expr_8h.html#a7">int_list_citer</a> p = indices-&gt;begin();
00824     r = g-&gt;<a class="code" href="classGrid.html#Grida27">map_begin</a>(); 
00825     <span class="keywordflow">for</span> (; p != indices-&gt;end() &amp;&amp; r != g-&gt;<a class="code" href="classGrid.html#Grida28">map_end</a>(); p++, r++)
00826     {
00827     int_list *index = *p;
00828     assert(index);
00829 
00830     <a class="code" href="expr_8h.html#a4">int_citer</a> q = index-&gt;begin(); 
00831     assert(q != index-&gt;end());
00832     <span class="keywordtype">int</span> start = *q;
00833 
00834     q++;
00835     <span class="keywordtype">int</span> stride = *q;
00836     
00837     q++;
00838     <span class="keywordtype">int</span> stop = *q;
00839 
00840     <a class="code" href="classBaseType.html">BaseType</a> *btp = *r;
00841     assert(btp);
00842     assert(btp-&gt;<a class="code" href="classBaseType.html#Vectora29">type</a>() == <a class="code" href="BaseType_8h.html#a29a23">dods_array_c</a>);
00843     <a class="code" href="classArray.html">Array</a> *a = (<a class="code" href="classArray.html">Array</a> *)btp;
00844     a-&gt;<a class="code" href="classVector.html#Vectora6">set_send_p</a>(<span class="keyword">true</span>);
00845     a-&gt;<a class="code" href="classArray.html#Arraya10">clear_constraint</a>();
00846 
00847     q++;
00848     <span class="keywordflow">if</span> (q!=index-&gt;end()) {
00849         <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(malformed_expr,
00850             string(<span class="stringliteral">"Too many values in index list for "</span>)
00851             + a-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>() + <span class="stringliteral">"."</span>);
00852     }
00853 
00854     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"process_grid_indices: Setting constraint on "</span>\
00855         &lt;&lt; a-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>() &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; start &lt;&lt; <span class="stringliteral">":"</span> &lt;&lt; stop &lt;&lt; <span class="stringliteral">"]"</span> &lt;&lt; endl);
00856 
00857     <a class="code" href="classArray.html#Arrays1">Array::Dim_iter</a> si = a-&gt;<a class="code" href="classArray.html#Arraya13">dim_begin</a>() ;
00858     a-&gt;<a class="code" href="classArray.html#Arraya7">add_constraint</a>(si, start, stride, stop);
00859 
00860     <a class="code" href="debug_8h.html#a1">DBG</a>(<a class="code" href="classArray.html#Arrays1">Array::Dim_iter</a> aiter = a-&gt;<a class="code" href="classArray.html#Arraya13">dim_begin</a>() ; \
00861         cerr &lt;&lt; <span class="stringliteral">"Set Constraint: "</span> \
00862         &lt;&lt; a-&gt;<a class="code" href="classArray.html#Arraya15">dimension_size</a>(aiter, <span class="keyword">true</span>) &lt;&lt; endl);
00863     }
00864 
00865     <a class="code" href="debug_8h.html#a1">DBG</a>(cout &lt;&lt; <span class="stringliteral">"Grid Constraint: "</span>;\
00866     <span class="keywordflow">for</span> (<a class="code" href="classArray.html#Arrays1">Array::Dim_iter</a> dp = ((<a class="code" href="classArray.html">Array</a> *)g-&gt;<a class="code" href="classGrid.html#Grida11">array_var</a>())-&gt;dim_begin();
00867          dp != ((<a class="code" href="classArray.html">Array</a> *)g-&gt;<a class="code" href="classGrid.html#Grida11">array_var</a>())-&gt;dim_end(); \
00868          dp++)\
00869        cout &lt;&lt; ((<a class="code" href="classArray.html">Array</a> *)g-&gt;<a class="code" href="classGrid.html#Grida11">array_var</a>())-&gt;dimension_size(dp, <span class="keyword">true</span>) &lt;&lt; <span class="stringliteral">" "</span>;\
00870     cout &lt;&lt; endl);
00871     
00872     <span class="keywordflow">if</span> (p!=indices-&gt;end() &amp;&amp; r==g-&gt;<a class="code" href="classGrid.html#Grida28">map_end</a>()) {
00873     <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(malformed_expr,
00874             string(<span class="stringliteral">"Too many indices in constraint for "</span>)
00875             + (*r)-&gt;name() + <span class="stringliteral">"."</span>);
00876     }
00877 
00878     <span class="keywordflow">return</span> status;
00879 }
00880 
00881 <span class="keywordtype">bool</span>
00882 process_sequence_indices(<a class="code" href="classBaseType.html">BaseType</a> *variable, <a class="code" href="expr_8h.html#a6">int_list_list</a> *indices)
00883 {
00884     <span class="keywordtype">bool</span> status = <span class="keyword">true</span>;
00885 
00886     assert(variable);
00887     assert(variable-&gt;<a class="code" href="classBaseType.html#Vectora29">type</a>() == <a class="code" href="BaseType_8h.html#a29a26">dods_sequence_c</a>);
00888     <a class="code" href="classSequence.html">Sequence</a> *s = dynamic_cast&lt;Sequence *&gt;(variable);
00889     <span class="keywordflow">if</span> (!s)
00890     <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(malformed_expr, <span class="stringliteral">"Expected a Sequence variable"</span>);
00891 
00892     <span class="comment">// Add specified maps to the current projection.</span>
00893     assert(indices);
00894     <span class="keywordflow">for</span> (<a class="code" href="expr_8h.html#a7">int_list_citer</a> p = indices-&gt;begin(); p != indices-&gt;end(); p++)
00895     {
00896     int_list *index = *p;
00897     assert(index);
00898 
00899     <a class="code" href="expr_8h.html#a4">int_citer</a> q = index-&gt;begin(); 
00900     assert(q!=index-&gt;end());
00901     <span class="keywordtype">int</span> start = *q;
00902 
00903     q++;
00904     <span class="keywordtype">int</span> stride = *q;
00905     
00906     q++;
00907     <span class="keywordtype">int</span> stop = *q;
00908 
00909     q++;
00910     <span class="keywordflow">if</span> (q!=index-&gt;end()) {
00911       <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(malformed_expr, 
00912               string(<span class="stringliteral">"Too many values in index list for "</span>)
00913               + s-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>() + <span class="stringliteral">"."</span>);
00914     }
00915 
00916     s-&gt;<a class="code" href="classSequence.html#Sequencea19">set_row_number_constraint</a>(start, stop, stride);
00917     }
00918 
00919     <span class="keywordflow">return</span> status;
00920 }
00921 
00922 <span class="comment">// Create a list of r values and add VAL to the list.</span>
00923 <span class="comment">//</span>
00924 <span class="comment">// Returns: A pointer to the updated rvalue_list.</span>
00925 
00926 <a class="code" href="RValue_8h.html#a0">rvalue_list</a> *
00927 make_rvalue_list(<a class="code" href="classrvalue.html">rvalue</a> *rv)
00928 {
00929     assert(rv);
00930 
00931     <a class="code" href="RValue_8h.html#a0">rvalue_list</a> *rvals = <span class="keyword">new</span> <a class="code" href="RValue_8h.html#a0">rvalue_list</a>;
00932 
00933     <span class="keywordflow">return</span> append_rvalue_list(rvals, rv);
00934 }
00935 
00936 <span class="comment">// Given a rvalue_list pointer RVALS and a value pointer VAL, make a variable</span>
00937 <span class="comment">// to hold VAL and append that variable to the list RVALS.</span>
00938 <span class="comment">//</span>
00939 <span class="comment">// Returns: A pointer to the updated rvalue_list.</span>
00940 
00941 <a class="code" href="RValue_8h.html#a0">rvalue_list</a> *
00942 append_rvalue_list(<a class="code" href="RValue_8h.html#a0">rvalue_list</a> *rvals, <a class="code" href="classrvalue.html">rvalue</a> *rv)
00943 {
00944     assert(rvals);
00945     assert(rv);
00946 
00947     rvals-&gt;push_back(rv);
00948 
00949     <span class="keywordflow">return</span> rvals;
00950 }
00951 
00952 <span class="comment">// Given a string which is a URL, dereference it and return the data it</span>
00953 <span class="comment">// points to.</span>
00954 
00955 <span class="keyword">static</span> <a class="code" href="classrvalue.html">rvalue</a> *
00956 dereference_string(string &amp;s)
00957 {
00958     <span class="comment">// FIX Once Connect/HTTPConnect settle down. ***</span>
00959     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> qpos = s.find(<span class="charliteral">'?'</span>);
00960     string url = s.substr(0, qpos); <span class="comment">// strip off CE</span>
00961     string ce = s.substr(qpos+1);   <span class="comment">// yes, get the CE</span>
00962 
00963     <a class="code" href="classConnect.html">Connect</a> c(url); <span class="comment">// make the virtual connection</span>
00964 
00965     <span class="comment">// the initial URL must be a complete reference to data; thus no</span>
00966     <span class="comment">// additional CE is needed. </span>
00967     <a class="code" href="classDDS.html">DDS</a> *d = c.<a class="code" href="classConnect.html#Connecta13">request_data</a>(ce, <span class="keyword">false</span>, <span class="keyword">false</span>); 
00968 
00969     <span class="comment">// By definition, the DDS `D' can have only one variable, so make sure</span>
00970     <span class="comment">// that is true.</span>
00971     <span class="keywordflow">if</span> (d-&gt;<a class="code" href="classDDS.html#DDSa12">num_var</a>() != 1) {
00972     <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a> (malformed_expr,
00973              string(<span class="stringliteral">"Too many variables in URL; use only single variable projections"</span>));
00974     }
00975 
00976     <span class="comment">// OK, we're here. The first_var() must be the only var, return it bound</span>
00977     <span class="comment">// up in an rvalue struct. NB: the *object* must be copied since the one</span>
00978     <span class="comment">// within DDS `D' will be deleted by D's dtor.</span>
00979     <a class="code" href="classBaseType.html">BaseType</a> *btp = (*(d-&gt;<a class="code" href="classDDS.html#DDSa13">var_begin</a>()))-&gt;<a class="code" href="classBaseType.html#Constructora6">ptr_duplicate</a>();
00980     <a class="code" href="classrvalue.html">rvalue</a> *rv = <span class="keyword">new</span> <a class="code" href="classrvalue.html">rvalue</a>(btp);
00981 
00982     <span class="keyword">delete</span> d;
00983 
00984     <span class="keywordflow">return</span> rv;
00985 }
00986 
00987 <a class="code" href="classrvalue.html">rvalue</a> *
00988 dereference_url(<a class="code" href="structvalue.html">value</a> &amp;val)
00989 {
00990     <span class="keywordflow">if</span> (val.<a class="code" href="structvalue.html#valuem0">type</a> != <a class="code" href="BaseType_8h.html#a29a21">dods_str_c</a>)
00991     <span class="keywordflow">return</span> 0;
00992 
00993     <span class="keywordflow">return</span> dereference_string(*val.<a class="code" href="structvalue.html#valuem5">v</a>.s);
00994 }
00995 
00996 <span class="comment">// Given a rvalue, get the BaseType that encapsulates its value, make sure it</span>
00997 <span class="comment">// is a string and, if all that works, dereference it.</span>
00998 
00999 <a class="code" href="classrvalue.html">rvalue</a> *
01000 dereference_variable(<a class="code" href="classrvalue.html">rvalue</a> *rv, <a class="code" href="classDDS.html">DDS</a> &amp;dds)
01001 {
01002     assert(rv);
01003     <span class="comment">// the value will be read over the net</span>
01004     <a class="code" href="classBaseType.html">BaseType</a> *btp = rv-&gt;<a class="code" href="classrvalue.html#rvaluea5">bvalue</a>(<span class="stringliteral">"dummy"</span>, dds); 
01005     <span class="keywordflow">if</span> (btp-&gt;<a class="code" href="classBaseType.html#Vectora29">type</a>() != <a class="code" href="BaseType_8h.html#a29a21">dods_str_c</a> &amp;&amp; btp-&gt;<a class="code" href="classBaseType.html#Vectora29">type</a>() != <a class="code" href="BaseType_8h.html#a29a22">dods_url_c</a>) {
01006     <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(malformed_expr, string(<span class="stringliteral">"The variable `"</span>) + btp-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>() 
01007             + <span class="stringliteral">"' must be either a string or a url"</span>);
01008     }
01009 
01010     string s;
01011     string  *sp = &amp;s;
01012     btp-&gt;<a class="code" href="classBaseType.html#Constructora30">buf2val</a>((<span class="keywordtype">void</span> **)&amp;sp);
01013     
01014     <span class="keywordflow">return</span> dereference_string(s);
01015 }
01016 
01017 <span class="comment">// Given a value, wrap it up in a BaseType and return a pointer to the same.</span>
01018 
01019 <a class="code" href="classBaseType.html">BaseType</a> *
01020 make_variable(<a class="code" href="classDDS.html">DDS</a> &amp;table, <span class="keyword">const</span> <a class="code" href="structvalue.html">value</a> &amp;val)
01021 {
01022     <a class="code" href="classBaseType.html">BaseType</a> *var;
01023     <span class="keywordflow">switch</span> (val.<a class="code" href="structvalue.html#valuem0">type</a>) {
01024       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a29a17">dods_int32_c</a>: {
01025     var = (<a class="code" href="classBaseType.html">BaseType</a> *)<a class="code" href="VirtualCtorInt32_8cc.html#a1">NewInt32</a>(<span class="stringliteral">"dummy"</span>);
01026     var-&gt;<a class="code" href="classBaseType.html#Constructora31">val2buf</a>((<span class="keywordtype">void</span> *)&amp;val.<a class="code" href="structvalue.html#valuem5">v</a>.i);
01027     <span class="keywordflow">break</span>;
01028       }
01029 
01030       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a29a20">dods_float64_c</a>: {
01031     var = (<a class="code" href="classBaseType.html">BaseType</a> *)<a class="code" href="VirtualCtorFloat64_8cc.html#a1">NewFloat64</a>(<span class="stringliteral">"dummy"</span>);
01032     var-&gt;<a class="code" href="classBaseType.html#Constructora31">val2buf</a>((<span class="keywordtype">void</span> *)&amp;val.<a class="code" href="structvalue.html#valuem5">v</a>.f);
01033     <span class="keywordflow">break</span>;
01034       }
01035 
01036       <span class="keywordflow">case</span> <a class="code" href="BaseType_8h.html#a29a21">dods_str_c</a>: {
01037     var = (<a class="code" href="classBaseType.html">BaseType</a> *)<a class="code" href="VirtualCtorStr_8cc.html#a1">NewStr</a>(<span class="stringliteral">"dummy"</span>);
01038     var-&gt;<a class="code" href="classBaseType.html#Constructora31">val2buf</a>((<span class="keywordtype">void</span> *)val.<a class="code" href="structvalue.html#valuem5">v</a>.s);
01039     <span class="keywordflow">break</span>;
01040       }
01041 
01042       <span class="keywordflow">default</span>:
01043     var = (<a class="code" href="classBaseType.html">BaseType</a> *)0;
01044     <span class="keywordflow">return</span> var;
01045     }
01046 
01047     var-&gt;<a class="code" href="classBaseType.html#Urla25">set_read_p</a>(<span class="keyword">true</span>);  <span class="comment">// ...so the evaluator will know it has data</span>
01048     table.<a class="code" href="classDDS.html#DDSa39">append_constant</a>(var);
01049 
01050     <span class="keywordflow">return</span> var;
01051 }
01052 
01053 <span class="comment">// Given a string (passed in VAL), consult the DDS CE function lookup table</span>
01054 <span class="comment">// to see if a function by that name exists. </span>
01055 <span class="comment">// NB: function arguments are type-checked at run-time.</span>
01056 <span class="comment">//</span>
01057 <span class="comment">// Returns: A poitner to the function or NULL if not such function exists.</span>
01058 
01059 <a class="code" href="expr_8h.html#a0">bool_func</a>
01060 get_function(<span class="keyword">const</span> <a class="code" href="classDDS.html">DDS</a> &amp;table, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="das_8y.html#a18">name</a>)
01061 {
01062     <a class="code" href="expr_8h.html#a0">bool_func</a> <a class="code" href="expr_8y.html#a5">f</a>;
01063 
01064     <span class="keywordflow">if</span> (table.<a class="code" href="classDDS.html#DDSz22_3">find_function</a>(<a class="code" href="das_8y.html#a18">name</a>, &amp;<a class="code" href="expr_8y.html#a5">f</a>))
01065     <span class="keywordflow">return</span> <a class="code" href="expr_8y.html#a5">f</a>;
01066     <span class="keywordflow">else</span>
01067     <span class="keywordflow">return</span> 0;
01068 }
01069 
01070 <a class="code" href="expr_8h.html#a1">btp_func</a>
01071 get_btp_function(<span class="keyword">const</span> <a class="code" href="classDDS.html">DDS</a> &amp;table, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="das_8y.html#a18">name</a>)
01072 {
01073     <a class="code" href="expr_8h.html#a1">btp_func</a> <a class="code" href="expr_8y.html#a5">f</a>;
01074 
01075     <span class="keywordflow">if</span> (table.<a class="code" href="classDDS.html#DDSz22_3">find_function</a>(<a class="code" href="das_8y.html#a18">name</a>, &amp;<a class="code" href="expr_8y.html#a5">f</a>))
01076     <span class="keywordflow">return</span> <a class="code" href="expr_8y.html#a5">f</a>;
01077     <span class="keywordflow">else</span>
01078     <span class="keywordflow">return</span> 0;
01079 }
01080 
01081 <a class="code" href="expr_8h.html#a2">proj_func</a>
01082 get_proj_function(<span class="keyword">const</span> <a class="code" href="classDDS.html">DDS</a> &amp;table, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="das_8y.html#a18">name</a>)
01083 {
01084     <a class="code" href="expr_8h.html#a2">proj_func</a> <a class="code" href="expr_8y.html#a5">f</a>;
01085 
01086     <span class="keywordflow">if</span> (table.<a class="code" href="classDDS.html#DDSz22_3">find_function</a>(<a class="code" href="das_8y.html#a18">name</a>, &amp;<a class="code" href="expr_8y.html#a5">f</a>))
01087     <span class="keywordflow">return</span> <a class="code" href="expr_8y.html#a5">f</a>;
01088     <span class="keywordflow">else</span>
01089     <span class="keywordflow">return</span> 0;
01090 }
01091 
01092 <span class="comment">/*</span>
01093 <span class="comment"> * $Log: expr_8y-source.html,v $
01093 <span class="comment"> * Revision 1.2  2004/01/30 22:51:15  jimg
01093 <span class="comment"> * Updated 2004/01/30.
01093 <span class="comment"> *</span>
01094 <span class="comment"> * Revision 1.47  2003/04/22 19:40:28  jimg</span>
01095 <span class="comment"> * Merged with 3.3.1.</span>
01096 <span class="comment"> *</span>
01097 <span class="comment"> * Revision 1.46  2003/02/27 23:42:32  jimg</span>
01098 <span class="comment"> * Fixed a call to connect down in the code that handles the '*' operator.</span>
01099 <span class="comment"> *</span>
01100 <span class="comment"> * Revision 1.45  2003/02/21 00:14:25  jimg</span>
01101 <span class="comment"> * Repaired copyright.</span>
01102 <span class="comment"> *</span>
01103 <span class="comment"> * Revision 1.44.2.1  2003/02/21 00:10:08  jimg</span>
01104 <span class="comment"> * Repaired copyright.</span>
01105 <span class="comment"> *</span>
01106 <span class="comment"> * Revision 1.44  2003/01/23 00:22:25  jimg</span>
01107 <span class="comment"> * Updated the copyright notice; this implementation of the DAP is</span>
01108 <span class="comment"> * copyrighted by OPeNDAP, Inc.</span>
01109 <span class="comment"> *</span>
01110 <span class="comment"> * Revision 1.43  2003/01/10 19:46:41  jimg</span>
01111 <span class="comment"> * Merged with code tagged release-3-2-10 on the release-3-2 branch. In many</span>
01112 <span class="comment"> * cases files were added on that branch (so they appear on the trunk for</span>
01113 <span class="comment"> * the first time).</span>
01114 <span class="comment"> *</span>
01115 <span class="comment"> * Revision 1.39.4.16  2002/12/17 22:35:03  pwest</span>
01116 <span class="comment"> * Added and updated methods using stdio. Deprecated methods using iostream.</span>
01117 <span class="comment"> *</span>
01118 <span class="comment"> * Revision 1.39.4.15  2002/11/05 00:53:52  jimg</span>
01119 <span class="comment"> * Removed 'identifier.' It was flagged as unneeded by bison.</span>
01120 <span class="comment"> *</span>
01121 <span class="comment"> * Revision 1.39.4.14  2002/10/28 21:17:44  pwest</span>
01122 <span class="comment"> * Converted all return values and method parameters to use non-const iterator.</span>
01123 <span class="comment"> * Added operator== and operator!= methods to IteratorAdapter to handle Pix</span>
01124 <span class="comment"> * problems.</span>
01125 <span class="comment"> *</span>
01126 <span class="comment"> * Revision 1.39.4.13  2002/09/05 22:52:55  pwest</span>
01127 <span class="comment"> * Replaced the GNU data structures SLList and DLList with the STL container</span>
01128 <span class="comment"> * class vector&lt;&gt;. To maintain use of Pix, changed the Pix.h header file to</span>
01129 <span class="comment"> * redefine Pix to be an IteratorAdapter. Usage remains the same and all code</span>
01130 <span class="comment"> * outside of the DAP should compile and link with no problems. Added methods</span>
01131 <span class="comment"> * to the different classes where Pix is used to include methods to use STL</span>
01132 <span class="comment"> * iterators. Replaced the use of Pix within the DAP to use iterators instead.</span>
01133 <span class="comment"> * Updated comments for documentation, updated the test suites, and added some</span>
01134 <span class="comment"> * unit tests. Updated the Makefile to remove GNU/SLList and GNU/DLList.</span>
01135 <span class="comment"> *</span>
01136 <span class="comment"> * Revision 1.39.4.12  2002/07/06 20:56:06  jimg</span>
01137 <span class="comment"> * Somehow the code added on 6.11.2002 that checked to ensure that the number of</span>
01138 <span class="comment"> * dimensions in an array's constraint matched the number of dimensions in the</span>
01139 <span class="comment"> * array was LOST. Hmmm... I added it back again. Looks like it was a casualty</span>
01140 <span class="comment"> * of the libcurl migration.</span>
01141 <span class="comment"> *</span>
01142 <span class="comment"> * Revision 1.39.4.11  2002/06/18 23:05:33  jimg</span>
01143 <span class="comment"> * Updated grammar files when replacing libwww.</span>
01144 <span class="comment"> *</span>
01145 <span class="comment"> * Revision 1.42  2002/06/03 22:21:16  jimg</span>
01146 <span class="comment"> * Merged with release-3-2-9</span>
01147 <span class="comment"> *</span>
01148 <span class="comment"> * Revision 1.39.4.8  2002/03/01 21:03:08  jimg</span>
01149 <span class="comment"> * Significant changes to the var(...) methods. These now take a btp_stack</span>
01150 <span class="comment"> * pointer and are used by DDS::mark(...). The exact_match methods have also</span>
01151 <span class="comment"> * been updated so that leaf variables which contain dots in their names</span>
01152 <span class="comment"> * will be found. Note that constructor variables with dots in their names</span>
01153 <span class="comment"> * will break the lookup routines unless the ctor is the last field in the</span>
01154 <span class="comment"> * constraint expression. These changes were made to fix bug 330.</span>
01155 <span class="comment"> *</span>
01156 <span class="comment"> * Revision 1.39.4.7  2002/02/20 19:16:27  jimg</span>
01157 <span class="comment"> * Changed the expression parser so that variable names may contain only</span>
01158 <span class="comment"> * digits.</span>
01159 <span class="comment"> *</span>
01160 <span class="comment"> * Revision 1.39.4.6  2001/11/01 00:43:51  jimg</span>
01161 <span class="comment"> * Fixes to the scanners and parsers so that dataset variable names may</span>
01162 <span class="comment"> * start with digits. I've expanded the set of characters that may appear</span>
01163 <span class="comment"> * in a variable name and made it so that all except `#' may appear at</span>
01164 <span class="comment"> * the start. Some characters are not allowed in variables that appear in</span>
01165 <span class="comment"> * a DDS or CE while they are allowed in the DAS. This makes it possible</span>
01166 <span class="comment"> * to define containers with names like `COARDS:long_name.' Putting a colon</span>
01167 <span class="comment"> * in a variable name makes the CE parser much more complex. Since the set</span>
01168 <span class="comment"> * of characters that people want seems pretty limited (compared to the</span>
01169 <span class="comment"> * complete ASCII set) I think this is an OK approach. If we have to open</span>
01170 <span class="comment"> * up the expr.lex scanner completely, then we can but not without adding</span>
01171 <span class="comment"> * lots of action clauses to teh parser. Note that colon is just an example,</span>
01172 <span class="comment"> * there's a host of characters that are used in CEs that are not allowed</span>
01173 <span class="comment"> * in IDs.</span>
01174 <span class="comment"> *</span>
01175 <span class="comment"> * Revision 1.41  2001/09/28 17:50:07  jimg</span>
01176 <span class="comment"> * Merged with 3.2.7.</span>
01177 <span class="comment"> *</span>
01178 <span class="comment"> * Revision 1.39.4.5  2001/09/25 20:24:28  jimg</span>
01179 <span class="comment"> * Added some debugging stuff to process_array_indices (and _grid_) to help</span>
01180 <span class="comment"> * debug the grid() server function.</span>
01181 <span class="comment"> *</span>
01182 <span class="comment"> * Revision 1.39.4.4  2001/09/19 21:57:26  jimg</span>
01183 <span class="comment"> * Changed no_such_ident(void *, const string &amp;, const string &amp;) so that it</span>
01184 <span class="comment"> * calls exprerror(...) directly. The call to it's other overloaded version</span>
01185 <span class="comment"> * was not working and resulted in an infinite loop.</span>
01186 <span class="comment"> *</span>
01187 <span class="comment"> * Revision 1.39.4.3  2001/09/06 22:04:03  jimg</span>
01188 <span class="comment"> * Fixed the error message for `No such X in dataset.' I removed an extra</span>
01189 <span class="comment"> * colon (Ouch...).</span>
01190 <span class="comment"> *</span>
01191 <span class="comment"> * Revision 1.40  2001/08/24 17:46:22  jimg</span>
01192 <span class="comment"> * Resolved conflicts from the merge of release 3.2.6</span>
01193 <span class="comment"> *</span>
01194 <span class="comment"> * Revision 1.39.4.2  2001/07/28 01:10:42  jimg</span>
01195 <span class="comment"> * Some of the numeric type classes did not have copy ctors or operator=.</span>
01196 <span class="comment"> * I added those where they were needed.</span>
01197 <span class="comment"> * In every place where delete (or delete []) was called, I set the pointer</span>
01198 <span class="comment"> * just deleted to zero. Thus if for some reason delete is called again</span>
01199 <span class="comment"> * before new memory is allocated there won't be a mysterious crash. This is</span>
01200 <span class="comment"> * just good form when using delete.</span>
01201 <span class="comment"> * I added calls to www2id and id2www where appropriate. The DAP now handles</span>
01202 <span class="comment"> * making sure that names are escaped and unescaped as needed. Connect is</span>
01203 <span class="comment"> * set to handle CEs that contain names as they are in the dataset (see the</span>
01204 <span class="comment"> * comments/Log there). Servers should not handle escaping or unescaping</span>
01205 <span class="comment"> * characters on their own.</span>
01206 <span class="comment"> *</span>
01207 <span class="comment"> * Revision 1.39.4.1  2001/06/23 00:52:08  jimg</span>
01208 <span class="comment"> * Normalized the definitions of ID (SCAN_ID), INT, FLOAT and NEVER so</span>
01209 <span class="comment"> * that they are (more or less) the same in all the scanners. There are</span>
01210 <span class="comment"> * one or two characters that differ (for example das.lex allows ( and )</span>
01211 <span class="comment"> * in an ID while dds.lex, expr.lex and gse.lex don't) but the definitions</span>
01212 <span class="comment"> * are essentially the same across the board.</span>
01213 <span class="comment"> * Added `#' to the set of characeters allowed in an ID (bug 179).</span>
01214 <span class="comment"> *</span>
01215 <span class="comment"> * Revision 1.39  2000/09/22 02:17:23  jimg</span>
01216 <span class="comment"> * Rearranged source files so that the CVS logs appear at the end rather than</span>
01217 <span class="comment"> * the start. Also made the ifdef guard symbols use the same naming scheme and</span>
01218 <span class="comment"> * wrapped headers included in other headers in those guard symbols (to cut</span>
01219 <span class="comment"> * down on extraneous file processing - See Lakos).</span>
01220 <span class="comment"> *</span>
01221 <span class="comment"> * Revision 1.38  2000/09/21 16:22:10  jimg</span>
01222 <span class="comment"> * Merged changes from Jose Garcia that add exceptions to the software.</span>
01223 <span class="comment"> * Many methods that returned error codes now throw exectptions. There are</span>
01224 <span class="comment"> * two classes which are thrown by the software, Error and InternalErr.</span>
01225 <span class="comment"> * InternalErr is used to report errors within the library or errors using</span>
01226 <span class="comment"> * the library. Error is used to reprot all other errors. Since InternalErr</span>
01227 <span class="comment"> * is a subclass of Error, programs need only to catch Error.</span>
01228 <span class="comment"> *</span>
01229 <span class="comment"> * Revision 1.37  2000/09/14 10:30:20  rmorris</span>
01230 <span class="comment"> * Added usage of ends and ostrstream elements in the std namespace for win32.</span>
01231 <span class="comment"> *</span>
01232 <span class="comment"> * Revision 1.36  2000/09/11 16:17:47  jimg</span>
01233 <span class="comment"> * Added Sequence selection using row numbers. This `selection' operation</span>
01234 <span class="comment"> * uses the brackets a la arrays and grids.</span>
01235 <span class="comment"> *</span>
01236 <span class="comment"> * Revision 1.35  2000/07/09 21:43:30  rmorris</span>
01237 <span class="comment"> * Mods to increase portability, minimize ifdef's for win32</span>
01238 <span class="comment"> *</span>
01239 <span class="comment"> * Revision 1.34  2000/06/07 18:07:00  jimg</span>
01240 <span class="comment"> * Merged the pc port branch</span>
01241 <span class="comment"> *</span>
01242 <span class="comment"> * Revision 1.33.14.1  2000/06/02 18:36:39  rmorris</span>
01243 <span class="comment"> * Mod's for port to Win32.</span>
01244 <span class="comment"> *</span>
01245 <span class="comment"> * Revision 1.33.8.1  2000/02/17 05:03:17  jimg</span>
01246 <span class="comment"> * Added file and line number information to calls to InternalErr.</span>
01247 <span class="comment"> * Resolved compile-time problems with read due to a change in its</span>
01248 <span class="comment"> * parameter list given that errors are now reported using exceptions.</span>
01249 <span class="comment"> *</span>
01250 <span class="comment"> * Revision 1.33  1999/07/22 17:11:52  jimg</span>
01251 <span class="comment"> * Merged changes from the release-3-0-2 branch</span>
01252 <span class="comment"> *</span>
01253 <span class="comment"> * Revision 1.32.6.1  1999/06/07 20:03:25  edavis</span>
01254 <span class="comment"> * Changed all string class usage of 'data()' to 'c_str()'.</span>
01255 <span class="comment"> *</span>
01256 <span class="comment"> * Revision 1.32  1999/05/21 17:20:08  jimg</span>
01257 <span class="comment"> * Made the parser error messages a bit easier to decode by adding `Expression'</span>
01258 <span class="comment"> * to them. Still, these are pretty lame messages...</span>
01259 <span class="comment"> *</span>
01260 <span class="comment"> * Revision 1.31  1999/05/04 19:47:24  jimg</span>
01261 <span class="comment"> * Fixed copyright statements. Removed more of the GNU classes.</span>
01262 <span class="comment"> *</span>
01263 <span class="comment"> * Revision 1.30  1999/04/29 02:29:36  jimg</span>
01264 <span class="comment"> * Merge of no-gnu branch</span>
01265 <span class="comment"> *</span>
01266 <span class="comment"> * Revision 1.29  1999/04/22 22:30:52  jimg</span>
01267 <span class="comment"> * Uses dynamic_cast</span>
01268 <span class="comment"> *</span>
01269 <span class="comment"> * Revision 1.28  1998/11/10 00:48:54  jimg</span>
01270 <span class="comment"> * Changed no_such_id() to no_such_ident() (the former is used in bastring.h).</span>
01271 <span class="comment"> *</span>
01272 <span class="comment"> * Revision 1.27  1998/11/05 23:41:20  jimg</span>
01273 <span class="comment"> * Made error message for errant CEs involving arrays better.</span>
01274 <span class="comment"> * DDS::mark() now used for array variables --- this should fix a potential</span>
01275 <span class="comment"> * problem with structures of arrays.</span>
01276 <span class="comment"> *</span>
01277 <span class="comment"> * Revision 1.26  1998/10/21 16:55:15  jimg</span>
01278 <span class="comment"> * Single array element may now be refd as [&lt;int&gt;]. So element seven of the</span>
01279 <span class="comment"> * array `a' can be referenced as a[7]. The old syntax, a[7:7], will still</span>
01280 <span class="comment"> * work. Projection functions are now supported. Functions listed in the</span>
01281 <span class="comment"> * projection part of a CE are evaluated (executed after parsing) as they are</span>
01282 <span class="comment"> * found (before the parse of the rest of the projections or the start of the</span>
01283 <span class="comment"> * parse of the selections. These functions take the same three arguments as</span>
01284 <span class="comment"> * the boll and BaseType * functions (int argc, BaseType *argv[], DDS &amp;dds)</span>
01285 <span class="comment"> * but they return void. They can do whatever they like, but the use I</span>
01286 <span class="comment"> * foresee is adding new (synthesized - see BaseType.cc/h) variables to the</span>
01287 <span class="comment"> * DDS.</span>
01288 <span class="comment"> *</span>
01289 <span class="comment"> * Revision 1.25  1998/09/17 16:56:50  jimg</span>
01290 <span class="comment"> * Made the error messages more verbose (that is, the text in the Error objects</span>
01291 <span class="comment"> * sent back to the client).</span>
01292 <span class="comment"> * Fixed a bug where non-existent fields could be accessed - with predictably</span>
01293 <span class="comment"> * bad results.</span>
01294 <span class="comment"> *</span>
01295 <span class="comment"> * Revision 1.24.6.2  1999/02/05 09:32:36  jimg</span>
01296 <span class="comment"> * Fixed __unused__ so that it not longer clashes with Red Hat 5.2 inlined</span>
01297 <span class="comment"> * math code. </span>
01298 <span class="comment"> *</span>
01299 <span class="comment"> * Revision 1.24.6.1  1999/02/02 21:57:07  jimg</span>
01300 <span class="comment"> * String to string version</span>
01301 <span class="comment"> *</span>
01302 <span class="comment"> * Revision 1.24  1998/03/19 23:22:38  jimg</span>
01303 <span class="comment"> * Fixed the error messages so they use `' instead of :</span>
01304 <span class="comment"> * Added Error objects for array index errors.</span>
01305 <span class="comment"> * Removed old code (that was surrounded by #if 0 ... #endif).</span>
01306 <span class="comment"> *</span>
01307 <span class="comment"> * Revision 1.23  1998/02/05 20:14:03  jimg</span>
01308 <span class="comment"> * DODS now compiles with gcc 2.8.x</span>
01309 <span class="comment"> *</span>
01310 <span class="comment"> * Revision 1.22  1997/10/09 22:19:31  jimg</span>
01311 <span class="comment"> * Resolved conflicts in merge of 2.14c to trunk.</span>
01312 <span class="comment"> *</span>
01313 <span class="comment"> * Revision 1.21  1997/10/04 00:33:05  jimg</span>
01314 <span class="comment"> * Release 2.14c fixes</span>
01315 <span class="comment"> *</span>
01316 <span class="comment"> * Revision 1.20.6.1  1997/09/23 15:45:09  jimg</span>
01317 <span class="comment"> * Fixed nasty comment bug with CVS 1.9</span>
01318 <span class="comment"> *</span>
01319 <span class="comment"> * Revision 1.20  1997/02/17 20:27:19  jimg</span>
01320 <span class="comment"> * Fixed silly spelling errors.</span>
01321 <span class="comment"> *</span>
01322 <span class="comment"> * Revision 1.19  1997/02/12 19:46:33  jimg</span>
01323 <span class="comment"> * Fixed bad asserts in process_array_indices and process_grid_indices.</span>
01324 <span class="comment"> *</span>
01325 <span class="comment"> * Revision 1.18  1997/02/10 02:32:46  jimg</span>
01326 <span class="comment"> * Added assert statements for pointers</span>
01327 <span class="comment"> *</span>
01328 <span class="comment"> * Revision 1.17  1996/12/18 18:47:24  jimg</span>
01329 <span class="comment"> * Modified the parser so that it returns Error objects for certain types of</span>
01330 <span class="comment"> * errors. In order to take advantage of this, callers must examine the</span>
01331 <span class="comment"> * returned object and process it as an Error object if status is false.</span>
01332 <span class="comment"> *</span>
01333 <span class="comment"> * Revision 1.16  1996/11/27 22:40:26  jimg</span>
01334 <span class="comment"> * Added DDS as third parameter to function in the CE evaluator</span>
01335 <span class="comment"> *</span>
01336 <span class="comment"> * Revision 1.15  1996/10/18 16:55:15  jimg</span>
01337 <span class="comment"> * Fixed the fix for bison 1.25...</span>
01338 <span class="comment"> *</span>
01339 <span class="comment"> * Revision 1.14  1996/10/08 17:04:43  jimg</span>
01340 <span class="comment"> * Added a fix for Bison 1.25 so that PARSE_PARAM will still work</span>
01341 <span class="comment"> *</span>
01342 <span class="comment"> * Revision 1.13  1996/08/13 19:00:21  jimg</span>
01343 <span class="comment"> * Added not_used to definition of char rcsid[].</span>
01344 <span class="comment"> * Switched to the parser_arg object for communication with callers. Removed</span>
01345 <span class="comment"> * unused parameters from dereference_{url, variable}, make_rvalue_list and</span>
01346 <span class="comment"> * append_rvalue_list.</span>
01347 <span class="comment"> *</span>
01348 <span class="comment"> * Revision 1.12  1996/06/18 23:54:31  jimg</span>
01349 <span class="comment"> * Fixes for Grid constraints. These include not deleting the array indices</span>
01350 <span class="comment"> * lists after processing the Array component of a grid (but before processing</span>
01351 <span class="comment"> * the Maps...).</span>
01352 <span class="comment"> *</span>
01353 <span class="comment"> * Revision 1.11  1996/06/11 17:27:11  jimg</span>
01354 <span class="comment"> * Moved debug.h in front of all the other DODS includes - this ensures that</span>
01355 <span class="comment"> * the debug.h included in this file is the one in effect (as opposed to a copy</span>
01356 <span class="comment"> * included by some other include file). We should banish nested includes...</span>
01357 <span class="comment"> * Added support for `Grid constraints'. These are like the Array constraints -</span>
01358 <span class="comment"> * projections where the start, stop and stride of each dimension may be</span>
01359 <span class="comment"> * specified. The new feature required a grammar change (so the parser would</span>
01360 <span class="comment"> * accept grids with the array bracket notation) and two new functions:</span>
01361 <span class="comment"> * is_grid_t() and process_grid_indices(). The actual projection information is</span>
01362 <span class="comment"> * stored in the array members of the Grid.</span>
01363 <span class="comment"> *</span>
01364 <span class="comment"> * Revision 1.10  1996/05/31 23:31:04  jimg</span>
01365 <span class="comment"> * Updated copyright notice.</span>
01366 <span class="comment"> *</span>
01367 <span class="comment"> * Revision 1.9  1996/05/29 22:08:57  jimg</span>
01368 <span class="comment"> * Made changes necessary to support CEs that return the value of a function</span>
01369 <span class="comment"> * instead of the value of a variable. This was done so that it would be</span>
01370 <span class="comment"> * possible to translate Sequences into Arrays without first reading the</span>
01371 <span class="comment"> * entire sequence over the network.</span>
01372 <span class="comment"> *</span>
01373 <span class="comment"> * Revision 1.8  1996/05/14 15:39:02  jimg</span>
01374 <span class="comment"> * These changes have already been checked in once before. However, I</span>
01375 <span class="comment"> * corrupted the source repository and restored it from a 5/9/96 backup</span>
01376 <span class="comment"> * tape. The previous version's log entry should cover the changes.</span>
01377 <span class="comment"> *</span>
01378 <span class="comment"> * Revision 1.7  1996/04/05 00:22:21  jimg</span>
01379 <span class="comment"> * Compiled with g++ -Wall and fixed various warnings.</span>
01380 <span class="comment"> *</span>
01381 <span class="comment"> * Revision 1.6  1996/03/02 01:17:09  jimg</span>
01382 <span class="comment"> * Added support for the complete CE spec.</span>
01383 <span class="comment"> *</span>
01384 <span class="comment"> * Revision 1.5  1996/02/01 17:43:18  jimg</span>
01385 <span class="comment"> * Added support for lists as operands in constraint expressions.</span>
01386 <span class="comment"> *</span>
01387 <span class="comment"> * Revision 1.4  1995/12/09  01:07:41  jimg</span>
01388 <span class="comment"> * Added changes so that relational operators will work properly for all the</span>
01389 <span class="comment"> * datatypes (including Sequences). The relational ops are evaluated in</span>
01390 <span class="comment"> * DDS::eval_constraint() after being parsed by DDS::parse_constraint().</span>
01391 <span class="comment"> *</span>
01392 <span class="comment"> * Revision 1.3  1995/12/06  18:42:44  jimg</span>
01393 <span class="comment"> * Added array constraints to the parser.</span>
01394 <span class="comment"> * Added functions for the actions of those new rules.</span>
01395 <span class="comment"> * Changed/added rule's return types.</span>
01396 <span class="comment"> * Changed the types in the %union {}.</span>
01397 <span class="comment"> *</span>
01398 <span class="comment"> * Revision 1.2  1995/10/23  23:10:38  jimg</span>
01399 <span class="comment"> * Added includes for various classes.</span>
01400 <span class="comment"> * Aded rules, actions and functions for evaluation of projections.</span>
01401 <span class="comment"> * Changed the value of YYSTYPE so that bison's %union feature is used -</span>
01402 <span class="comment"> * rules now return several different types.</span>
01403 <span class="comment"> *</span>
01404 <span class="comment"> * Revision 1.1  1995/10/13  03:04:08  jimg</span>
01405 <span class="comment"> * First version. Incorporates Glenn's suggestions. </span>
01406 <span class="comment"> */</span>
01407 
</pre></div><hr><address style="align: right;"><small>Generated on Tue Aug 19 12:42:02 2003 for OPeNDAP by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>
