<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libdap++: HTTPCache.cc Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>HTTPCache.cc</h1><a href="HTTPCache_8cc.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00002 <span class="comment">// -*- mode: c++; c-basic-offset:4 -*-</span>
00003 
00004 <span class="comment">// This file is part of libdap, A C++ implementation of the OPeNDAP Data</span>
00005 <span class="comment">// Access Protocol.</span>
00006 
00007 <span class="comment">// Copyright (c) 2002,2003 OPeNDAP, Inc.</span>
00008 <span class="comment">// Author: James Gallagher &lt;jgallagher@opendap.org&gt;</span>
00009 <span class="comment">//</span>
00010 <span class="comment">// This library is free software; you can redistribute it and/or</span>
00011 <span class="comment">// modify it under the terms of the GNU Lesser General Public</span>
00012 <span class="comment">// License as published by the Free Software Foundation; either</span>
00013 <span class="comment">// version 2.1 of the License, or (at your option) any later version.</span>
00014 <span class="comment">// </span>
00015 <span class="comment">// This library is distributed in the hope that it will be useful,</span>
00016 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00017 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00018 <span class="comment">// Lesser General Public License for more details.</span>
00019 <span class="comment">// </span>
00020 <span class="comment">// You should have received a copy of the GNU Lesser General Public</span>
00021 <span class="comment">// License along with this library; if not, write to the Free Software</span>
00022 <span class="comment">// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00023 <span class="comment">//</span>
00024 <span class="comment">// You can contact OPeNDAP, Inc. at PO Box 112, Saunderstown, RI. 02874-0112.</span>
00025  
00026 <span class="preprocessor">#ifdef __GNUG__</span>
00027 <span class="preprocessor"></span><span class="preprocessor">#pragma implementation</span>
00028 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00029 <span class="preprocessor"></span>
00030 <span class="preprocessor">#include "<a class="code" href="config__dap_8h.html">config_dap.h</a>"</span>
00031 
00032 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00033 <span class="preprocessor">#ifdef HAVE_PTHREAD_H</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#include &lt;pthread.h&gt;</span>
00035 <span class="preprocessor">#endif</span>
00036 <span class="preprocessor"></span>
00037 <span class="preprocessor">#include &lt;iostream&gt;</span>
00038 <span class="preprocessor">#include &lt;sstream&gt;</span>
00039 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00040 <span class="preprocessor">#include &lt;iterator&gt;</span>
00041 <span class="preprocessor">#include &lt;set&gt;</span>
00042 
00043 <span class="preprocessor">#include "<a class="code" href="Error_8h.html">Error.h</a>"</span>
00044 <span class="preprocessor">#include "<a class="code" href="InternalErr_8h.html">InternalErr.h</a>"</span>
00045 <span class="preprocessor">#include "<a class="code" href="ResponseTooBigErr_8h.html">ResponseTooBigErr.h</a>"</span>
00046 <span class="preprocessor">#include "<a class="code" href="HTTPCache_8h.html">HTTPCache.h</a>"</span>
00047 
00048 <span class="preprocessor">#include "<a class="code" href="util__mit_8h.html">util_mit.h</a>"</span>
00049 <span class="preprocessor">#include "<a class="code" href="debug_8h.html">debug.h</a>"</span>
00050 
00051 <a class="code" href="classHTTPCache.html">HTTPCache</a> *HTTPCache::_instance = 0;
00052 
00053 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00054 
00055 <span class="preprocessor">#if HAVE_PTHREAD_H</span>
00056 <span class="preprocessor"></span><span class="comment">// instance_mutex is used to ensure that only one instance is created. The</span>
00057 <span class="comment">// other mutexes used by this class are fields. 10/09/02 jhrg</span>
00058 <span class="keyword">static</span> pthread_mutex_t instance_mutex = PTHREAD_MUTEX_INITIALIZER;
<a name="l00059"></a><a class="code" href="HTTPCache_8cc.html#a0">00059</a> <span class="preprocessor">#define LOCK(m) pthread_mutex_lock((m))</span>
<a name="l00060"></a><a class="code" href="HTTPCache_8cc.html#a1">00060</a> <span class="preprocessor"></span><span class="preprocessor">#define TRYLOCK(m) pthread_mutex_trylock((m))</span>
<a name="l00061"></a><a class="code" href="HTTPCache_8cc.html#a2">00061</a> <span class="preprocessor"></span><span class="preprocessor">#define UNLOCK(m) pthread_mutex_unlock((m))</span>
<a name="l00062"></a><a class="code" href="HTTPCache_8cc.html#a3">00062</a> <span class="preprocessor"></span><span class="preprocessor">#define INIT(m) pthread_mutex_init((m), 0)</span>
<a name="l00063"></a><a class="code" href="HTTPCache_8cc.html#a4">00063</a> <span class="preprocessor"></span><span class="preprocessor">#define DESTROY(m) pthread_mutex_destroy((m))</span>
00064 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00065 <span class="preprocessor"></span><span class="preprocessor">#define LOCK(m)</span>
00066 <span class="preprocessor"></span><span class="preprocessor">#define TRYLOCK(m)</span>
00067 <span class="preprocessor"></span><span class="preprocessor">#define UNLOCK(m)</span>
00068 <span class="preprocessor"></span><span class="preprocessor">#define INIT(m)</span>
00069 <span class="preprocessor"></span><span class="preprocessor">#define DESTROY(m)</span>
00070 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00071 <span class="preprocessor"></span>
00072 <span class="preprocessor">#ifdef WIN32</span>
00073 <span class="preprocessor"></span><span class="preprocessor">#include &lt;direct.h&gt;</span>
00074 <span class="preprocessor">#include &lt;time.h&gt;</span>
00075 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
00076 <span class="preprocessor">#define min(a,b) _MIN(a,b)</span>
00077 <span class="preprocessor"></span><span class="preprocessor">#define max(a,b) _MAX(a,b)</span>
00078 <span class="preprocessor"></span><span class="preprocessor">#define MKDIR(a,b) _mkdir((a))</span>
00079 <span class="preprocessor"></span><span class="preprocessor">#define REMOVE(a) remove((a))</span>
00080 <span class="preprocessor"></span><span class="preprocessor">#define MKSTEMP(a) _open(_mktemp((a)),_O_CREAT,_S_IREAD|_S_IWRITE)</span>
00081 <span class="preprocessor"></span><span class="preprocessor">#define DIR_SEPARATOR_CHAR '\\'</span>
00082 <span class="preprocessor"></span><span class="preprocessor">#define DIR_SEPARATOR_STR "\\"</span>
00083 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00084"></a><a class="code" href="HTTPCache_8cc.html#a5">00084</a> <span class="preprocessor"></span><span class="preprocessor">#define MKDIR(a,b) mkdir((a), (b))</span>
<a name="l00085"></a><a class="code" href="HTTPCache_8cc.html#a6">00085</a> <span class="preprocessor"></span><span class="preprocessor">#define REMOVE(a) remove((a))</span>
<a name="l00086"></a><a class="code" href="HTTPCache_8cc.html#a7">00086</a> <span class="preprocessor"></span><span class="preprocessor">#define MKSTEMP(a) mkstemp((a))</span>
<a name="l00087"></a><a class="code" href="HTTPCache_8cc.html#a8">00087</a> <span class="preprocessor"></span><span class="preprocessor">#define DIR_SEPARATOR_CHAR '/'</span>
<a name="l00088"></a><a class="code" href="HTTPCache_8cc.html#a9">00088</a> <span class="preprocessor"></span><span class="preprocessor">#define DIR_SEPARATOR_STR "/"</span>
00089 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00090 <span class="preprocessor"></span>
00091 <span class="preprocessor">#ifdef WIN32</span>
00092 <span class="preprocessor"></span><span class="preprocessor">#define CACHE_LOC "\\tmp\\"</span>
00093 <span class="preprocessor"></span><span class="preprocessor">#define CACHE_ROOT "dods-cache\\"</span>
00094 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00095"></a><a class="code" href="HTTPCache_8cc.html#a10">00095</a> <span class="preprocessor"></span><span class="preprocessor">#define CACHE_LOC "/tmp/"</span>
<a name="l00096"></a><a class="code" href="HTTPCache_8cc.html#a11">00096</a> <span class="preprocessor"></span><span class="preprocessor">#define CACHE_ROOT "dods-cache/"</span>
00097 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00098"></a><a class="code" href="HTTPCache_8cc.html#a12">00098</a> <span class="preprocessor"></span><span class="preprocessor">#define CACHE_INDEX ".index"</span>
<a name="l00099"></a><a class="code" href="HTTPCache_8cc.html#a13">00099</a> <span class="preprocessor"></span><span class="preprocessor">#define CACHE_LOCK ".lock"</span>
<a name="l00100"></a><a class="code" href="HTTPCache_8cc.html#a14">00100</a> <span class="preprocessor"></span><span class="preprocessor">#define CACHE_META ".meta"</span>
<a name="l00101"></a><a class="code" href="HTTPCache_8cc.html#a15">00101</a> <span class="preprocessor"></span><span class="preprocessor">#define CACHE_EMPTY_ETAG "@cache@"</span>
00102 <span class="preprocessor"></span>
<a name="l00103"></a><a class="code" href="HTTPCache_8cc.html#a16">00103</a> <span class="preprocessor">#define NO_LM_EXPIRATION 24*3600 // 24 hours</span>
<a name="l00104"></a><a class="code" href="HTTPCache_8cc.html#a17">00104</a> <span class="preprocessor"></span><span class="preprocessor">#define MAX_LM_EXPIRATION 48*3600 // Max expiration from LM </span>
00105 <span class="preprocessor"></span>
00106 <span class="comment">// If using LM to find the expiration then take 10% and no more than</span>
00107 <span class="comment">// MAX_LM_EXPIRATION.</span>
00108 <span class="preprocessor">#ifndef LM_EXPIRATION</span>
<a name="l00109"></a><a class="code" href="HTTPCache_8cc.html#a18">00109</a> <span class="preprocessor"></span><span class="preprocessor">#define LM_EXPIRATION(t) (min((MAX_LM_EXPIRATION), static_cast&lt;int&gt;((t) / 10)))</span>
00110 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00111 <span class="preprocessor"></span>
<a name="l00112"></a><a class="code" href="HTTPCache_8cc.html#a19">00112</a> <span class="preprocessor">#define DUMP_FREQUENCY 10   // Dump index every x loads </span>
00113 <span class="preprocessor"></span>
<a name="l00114"></a><a class="code" href="HTTPCache_8cc.html#a20">00114</a> <span class="preprocessor">#define MEGA 0x100000L</span>
<a name="l00115"></a><a class="code" href="HTTPCache_8cc.html#a21">00115</a> <span class="preprocessor"></span><span class="preprocessor">#define CACHE_TOTAL_SIZE 20 // Default cache size is 20M </span>
<a name="l00116"></a><a class="code" href="HTTPCache_8cc.html#a22">00116</a> <span class="preprocessor"></span><span class="preprocessor">#define CACHE_FOLDER_PCT 10 // 10% of cache size for metainfo etc. </span>
<a name="l00117"></a><a class="code" href="HTTPCache_8cc.html#a23">00117</a> <span class="preprocessor"></span><span class="preprocessor">#define CACHE_GC_PCT 10     // 10% of cache size free after GC </span>
<a name="l00118"></a><a class="code" href="HTTPCache_8cc.html#a24">00118</a> <span class="preprocessor"></span><span class="preprocessor">#define MIN_CACHE_TOTAL_SIZE 5  // 5M Min cache size </span>
<a name="l00119"></a><a class="code" href="HTTPCache_8cc.html#a25">00119</a> <span class="preprocessor"></span><span class="preprocessor">#define MAX_CACHE_ENTRY_SIZE 3  // 3M Max size of single cached entry </span>
00120 <span class="preprocessor"></span>
00125 <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">int</span>
00126 get_hash(<span class="keyword">const</span> string &amp;url)
00127 {
00128     <span class="keywordtype">int</span> hash = 0;
00129 
00130     <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">char</span> *ptr=url.c_str(); *ptr; ptr++)
00131     hash = (<span class="keywordtype">int</span>) ((hash * 3 + (*(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)ptr)) % <a class="code" href="HTTPCache_8h.html#a0">CACHE_TABLE_SIZE</a>);
00132 
00133     <span class="keywordflow">return</span> hash;
00134 }
00135 
00150 HTTPCache::HTTPCache(string cache_root, <span class="keywordtype">bool</span> force) <span class="keywordflow">throw</span>(<a class="code" href="classError.html">Error</a>) : 
00151     d_locked_open_file(0), 
00152     d_cache_enabled(<span class="keyword">false</span>), 
00153     d_cache_protected(<span class="keyword">false</span>),
00154     d_expire_ignored(<span class="keyword">false</span>), 
00155     d_always_validate(<span class="keyword">false</span>),
00156     d_total_size(CACHE_TOTAL_SIZE * MEGA),
00157     d_folder_size(CACHE_TOTAL_SIZE/CACHE_FOLDER_PCT),
00158     d_gc_buffer(CACHE_TOTAL_SIZE/CACHE_GC_PCT),
00159     d_max_entry_size(MAX_CACHE_ENTRY_SIZE * MEGA),
00160     d_current_size(0),
00161     d_default_expiration(NO_LM_EXPIRATION), 
00162     d_max_age(-1),
00163     d_max_stale(-1),
00164     d_min_fresh(-1),
00165     d_new_entries(0)
00166 {
00167     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Entering the constructor for "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="stringliteral">"... "</span>);
00168 
00169     <a class="code" href="HTTPCache_8cc.html#a3">INIT</a>(&amp;d_cache_mutex);
00170 
00171     <span class="comment">// Initialize the cache table.</span>
00172     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="HTTPCache_8h.html#a0">CACHE_TABLE_SIZE</a>; ++i)
00173     d_cache_table[i] = 0;
00174 
00175     <span class="comment">// This used to throw an Error object if we could not get the</span>
00176     <span class="comment">// single user lock. However, that results in an invalid object. It's</span>
00177     <span class="comment">// better to have an instance that has default values. If we cannot get</span>
00178     <span class="comment">// the lock, make sure to set the cache as *disabled*. 03/12/03 jhrg</span>
00179     <span class="comment">//</span>
00180     <span class="comment">// I fixed this block so that the cache root is set before we try to get</span>
00181     <span class="comment">// the single user lock. That was the fix for bug #661. To make that</span>
00182     <span class="comment">// work, I had to move the call to create_cache_root out of</span>
00183     <span class="comment">// set_cache_root(). 09/08/03 jhrg</span>
00184 
00185     set_cache_root(cache_root);
00186 
00187     <span class="keywordflow">if</span> (get_single_user_lock(force)) {
00188     cache_index_read();
00189     d_cache_enabled = <span class="keyword">true</span>;
00190     }
00191 
00192     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"exiting"</span> &lt;&lt; endl);
00193 }
00194 
00223 <a class="code" href="classHTTPCache.html">HTTPCache</a> *
<a name="l00224"></a><a class="code" href="classHTTPCache.html#HTTPCachee0">00224</a> <a class="code" href="classHTTPCache.html#HTTPCachee0">HTTPCache::instance</a>(<span class="keyword">const</span> string &amp;cache_root, <span class="keywordtype">bool</span> force) <span class="keywordflow">throw</span>(<a class="code" href="classError.html">Error</a>)
00225 {
00226     <a class="code" href="HTTPCache_8cc.html#a0">LOCK</a>(&amp;instance_mutex);
00227     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Entering instance(); ("</span> &lt;&lt; hex &lt;&lt; _instance &lt;&lt; dec &lt;&lt; <span class="stringliteral">")"</span>
00228      &lt;&lt; <span class="stringliteral">"... "</span>);
00229 
00230     <span class="keywordflow">try</span> {
00231     <span class="keywordflow">if</span> (!_instance) {
00232         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"About to create a new instance, cache root: "</span> 
00233         &lt;&lt; cache_root &lt;&lt; endl);
00234         _instance = <span class="keyword">new</span> <a class="code" href="classHTTPCache.html">HTTPCache</a>(cache_root, force);
00235         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"New instance: "</span> &lt;&lt; _instance &lt;&lt; <span class="stringliteral">", cache root: "</span> 
00236         &lt;&lt; _instance-&gt;d_cache_root &lt;&lt; endl);
00237         atexit(delete_instance);
00238     }
00239     }
00240     <span class="keywordflow">catch</span> (<a class="code" href="classError.html">Error</a> &amp;e) {
00241     <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"The constructor threw an Error!"</span> &lt;&lt; endl);
00242     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;instance_mutex);
00243     <span class="keywordflow">throw</span> e;
00244     }
00245 
00246     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;instance_mutex);
00247     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"returning "</span> &lt;&lt; hex &lt;&lt; _instance &lt;&lt; dec &lt;&lt; endl);
00248 
00249     <span class="keywordflow">return</span> _instance;
00250 }
00251 
00255 <span class="keywordtype">void</span>
00256 HTTPCache::delete_instance()
00257 {
00258     <span class="keywordflow">if</span> (HTTPCache::_instance) {
00259     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Deleting the cache: "</span> &lt;&lt; HTTPCache::_instance &lt;&lt; endl);
00260     <span class="keyword">delete</span> HTTPCache::_instance;
00261     }
00262 }
00263 
00267 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> 
00268 delete_cache_entry(<a class="code" href="structHTTPCache_1_1CacheEntry.html">HTTPCache::CacheEntry</a> *e)
00269 {
00270     <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"Deleting CacheEntry: "</span> &lt;&lt; e &lt;&lt; endl);
00271     <a class="code" href="HTTPCache_8cc.html#a4">DESTROY</a>(&amp;e-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo18">lock</a>);
00272     <span class="keyword">delete</span> e;
00273 }
00274 
<a name="l00287"></a><a class="code" href="classHTTPCache.html#HTTPCachea0">00287</a> <a class="code" href="classHTTPCache.html#HTTPCachea0">HTTPCache::~HTTPCache</a>()
00288 {
00289     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Entering the destructor for "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="stringliteral">"... "</span>);
00290 
00291     <span class="keywordflow">try</span> {
00292     <span class="keywordflow">if</span> (startGC())
00293         perform_garbage_collection();
00294 
00295     <a class="code" href="classHTTPCache.html#HTTPCachez29_0">cache_index_write</a>();
00296     }
00297     <span class="keywordflow">catch</span> (<a class="code" href="classError.html">Error</a> &amp;e) {
00298     <span class="comment">// If the cache index cannot be written, we've got problems. However,</span>
00299     <span class="comment">// unless we're debugging, still free up the cache table in memory. </span>
00300     <span class="comment">// How should we let users know they cache index is not being</span>
00301     <span class="comment">// written?? 10/03/02 jhrg</span>
00302     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; e.get_error_message() &lt;&lt; endl);
00303     }
00304 
00305     <span class="comment">// I don't see any code inside this try block that can throw an Error.</span>
00306     <span class="comment">// Nor do I see anything that can lock the interface. I'll leave this as</span>
00307     <span class="comment">// is, but I'm pretty sure this is left over from older code which called</span>
00308     <span class="comment">// perform_garbage_collection() in here and when that called</span>
00309     <span class="comment">// cache_index_write(). 01/23/04 jhrg</span>
00310     <span class="keywordflow">try</span> {
00311     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="HTTPCache_8h.html#a0">CACHE_TABLE_SIZE</a>; ++i) {
00312         CachePointers *cp = d_cache_table[i];
00313         <span class="keywordflow">if</span> (cp) {
00314         <span class="comment">// delete each entry</span>
00315         for_each(cp-&gt;begin(), cp-&gt;end(), delete_cache_entry);
00316         <span class="comment">// now delete the vector that held the entries</span>
00317         <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"Deleting d_cache_table["</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">"]: "</span>
00318              &lt;&lt; d_cache_table[i] &lt;&lt; endl);
00319         <span class="keyword">delete</span> d_cache_table[i];
00320         }
00321     }
00322 
00323     release_single_user_lock();
00324     HTTPCache::_instance = 0; <span class="comment">// Needed for testing (where many HTTPCache</span>
00325                 <span class="comment">// objects are made by one process).</span>
00326 
00327     }
00328     <span class="keywordflow">catch</span> (<a class="code" href="classError.html">Error</a> &amp;e) {
00329     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"The constructor threw an Error!"</span> &lt;&lt; endl);
00330     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
00331     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
00332     <span class="keywordflow">throw</span> e;
00333     }
00334 
00335     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"exiting destructor."</span> &lt;&lt; endl);
00336     <a class="code" href="HTTPCache_8cc.html#a4">DESTROY</a>(&amp;d_cache_mutex);
00337 }
00338 
00345 
00352 <span class="keywordtype">bool</span>
00353 HTTPCache::cache_index_delete()
00354 {
00355     <span class="keywordflow">return</span> (<a class="code" href="HTTPCache_8cc.html#a6">REMOVE</a>(d_cache_index.c_str()) == 0);
00356 }
00357 
00366 <span class="keywordtype">bool</span>
00367 HTTPCache::cache_index_read()
00368 {
00369     FILE *fp = fopen(d_cache_index.c_str(), <span class="stringliteral">"r"</span>);
00370     <span class="comment">// If the cache index can't be opened that's OK; start with an empty</span>
00371     <span class="comment">// cache. 09/05/02 jhrg</span>
00372     <span class="keywordflow">if</span> (!fp) {
00373     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00374     }
00375 
00376     <span class="keywordtype">char</span> line[1024];
00377     <span class="keywordflow">while</span> (!feof(fp) &amp;&amp; fgets(line, 1024, fp)) {
00378     add_entry_to_cache_table(cache_index_parse_line(line));
00379     <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; line &lt;&lt; endl);
00380     }
00381 
00382     <span class="keywordtype">int</span> res = fclose( fp ) ;
00383     <span class="keywordflow">if</span>( res ) {
00384     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"HTTPCache::cache_index_read - Failed to close "</span> &lt;&lt; (<span class="keywordtype">void</span> *)fp &lt;&lt; endl ;) ;
00385     }
00386 
00387     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00388 }
00389 
00397 <a class="code" href="structHTTPCache_1_1CacheEntry.html">HTTPCache::CacheEntry</a> *
00398 HTTPCache::cache_index_parse_line(<span class="keyword">const</span> <span class="keywordtype">char</span> *line)
00399 {
00400     <span class="comment">// Read the line and create the cache object</span>
00401     CacheEntry *entry = <span class="keyword">new</span> CacheEntry;
00402 
00403     <a class="code" href="HTTPCache_8cc.html#a3">INIT</a>(&amp;entry-&gt;lock);
00404     istringstream iss(line);
00405     iss &gt;&gt; entry-&gt;url;
00406     iss &gt;&gt; entry-&gt;cachename;
00407 
00408     iss &gt;&gt; entry-&gt;etag;
00409     <span class="keywordflow">if</span> (entry-&gt;etag == <a class="code" href="HTTPCache_8cc.html#a15">CACHE_EMPTY_ETAG</a>)
00410     entry-&gt;etag = <span class="stringliteral">""</span>;
00411 
00412     iss &gt;&gt; entry-&gt;lm;
00413     iss &gt;&gt; entry-&gt;expires;
00414     iss &gt;&gt; entry-&gt;size;
00415 
00416     iss &gt;&gt; entry-&gt;range;    <span class="comment">// range is not used. 10/02/02 jhrg</span>
00417 
00418     iss &gt;&gt; entry-&gt;hash;
00419     iss &gt;&gt; entry-&gt;hits;
00420     iss &gt;&gt; entry-&gt;freshness_lifetime;
00421     iss &gt;&gt; entry-&gt;response_time;
00422     iss &gt;&gt; entry-&gt;corrected_initial_age;
00423 
00424     iss &gt;&gt; entry-&gt;must_revalidate;
00425 
00426     <span class="keywordflow">return</span> entry;
00427 }
00428 
00431 <span class="keyword">class </span>WriteOneCacheEntry :
00432     <span class="keyword">public</span> unary_function&lt;HTTPCache::CacheEntry *, void&gt; {
00433 
00434     FILE *d_fp;
00435 
00436 <span class="keyword">public</span>:
00437     WriteOneCacheEntry(FILE *fp) : d_fp(fp) {}
00438 
00439     <span class="keywordtype">void</span> operator()(<a class="code" href="structHTTPCache_1_1CacheEntry.html">HTTPCache::CacheEntry</a> *e) {
00440     <span class="keywordflow">if</span> (e &amp;&amp; fprintf(d_fp, 
00441              <span class="stringliteral">"%s %s %s %ld %ld %ld %c %d %d %ld %ld %ld %c\r\n"</span>,
00442              e-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo0">url</a>.c_str(),
00443              e-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo3">cachename</a>.c_str(),
00444              e-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo4">etag</a> == <span class="stringliteral">""</span> ? <a class="code" href="HTTPCache_8cc.html#a15">CACHE_EMPTY_ETAG</a> 
00445              : e-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo4">etag</a>.c_str(),
00446              (<span class="keywordtype">long</span>) (e-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo5">lm</a>),
00447              (<span class="keywordtype">long</span>) (e-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo6">expires</a>),
00448              e-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo10">size</a>,
00449              e-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo11">range</a> ? <span class="charliteral">'1'</span> : <span class="charliteral">'0'</span>, <span class="comment">// not used. 10/02/02 jhrg </span>
00450              e-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo1">hash</a>,
00451              e-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo2">hits</a>,
00452              (<span class="keywordtype">long</span>) (e-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo12">freshness_lifetime</a>),
00453              (<span class="keywordtype">long</span>) (e-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo13">response_time</a>),
00454              (<span class="keywordtype">long</span>) (e-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo14">corrected_initial_age</a>),
00455              e-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo15">must_revalidate</a> ? <span class="charliteral">'1'</span> : <span class="charliteral">'0'</span>) &lt; 0)
00456         <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(<span class="stringliteral">"Cache Index. Error writing cache index\n"</span>);
00457     }
00458 };
00459 
00468 <span class="keywordtype">void</span>
<a name="l00469"></a><a class="code" href="classHTTPCache.html#HTTPCachez29_0">00469</a> <a class="code" href="classHTTPCache.html#HTTPCachez29_0">HTTPCache::cache_index_write</a>() <span class="keywordflow">throw</span>(<a class="code" href="classError.html">Error</a>)
00470 {
00471     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Locking interface... "</span>);
00472     <a class="code" href="HTTPCache_8cc.html#a0">LOCK</a>(&amp;d_cache_mutex);
00473 
00474     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Cache Index. Writing index "</span> &lt;&lt; d_cache_index &lt;&lt; endl);
00475 
00476     <span class="keywordflow">try</span> {
00477     <span class="comment">// Open the file for writing.</span>
00478     FILE * fp = NULL;
00479     <span class="keywordflow">if</span> ((fp = fopen(d_cache_index.c_str(), <span class="stringliteral">"wb"</span>)) == NULL) {
00480         <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(string(<span class="stringliteral">"Cache Index. Can't open `"</span>) + d_cache_index 
00481             + string(<span class="stringliteral">"' for writing"</span>));
00482     }
00483 
00484     <span class="comment">// Walk through the list and write it out. The format is really</span>
00485     <span class="comment">// simple as we keep it all in ASCII.</span>
00486 
00487     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cnt = 0; cnt &lt; <a class="code" href="HTTPCache_8h.html#a0">CACHE_TABLE_SIZE</a>; cnt++) {
00488         CachePointers *cp = d_cache_table[cnt];
00489         <span class="keywordflow">if</span> (cp)
00490         for_each(cp-&gt;begin(), cp-&gt;end(), WriteOneCacheEntry(fp));
00491     }
00492 
00493     <span class="comment">/* Done writing */</span>
00494     <span class="keywordtype">int</span> res = fclose(fp);
00495     <span class="keywordflow">if</span>( res ) {
00496         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"HTTPCache::cache_index_write - Failed to close "</span> 
00497         &lt;&lt; (<span class="keywordtype">void</span> *)fp &lt;&lt; endl ;) ;
00498     }
00499 
00500     d_new_entries = 0;
00501     }
00502     <span class="keywordflow">catch</span> (<a class="code" href="classError.html">Error</a> &amp;e) {
00503     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
00504     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
00505     <span class="keywordflow">throw</span> e;
00506     }
00507 
00508     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
00509     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
00510 }
00511 
00513 
00517 
00521 <span class="keywordtype">bool</span>
00522 HTTPCache::stopGC()<span class="keyword"> const</span>
00523 <span class="keyword"></span>{
00524     <span class="keywordflow">return</span> (d_current_size + d_folder_size &lt; d_total_size - d_gc_buffer);
00525 }
00526 
00533 <span class="keywordtype">bool</span>
00534 HTTPCache::startGC()<span class="keyword"> const</span>
00535 <span class="keyword"></span>{
00536     <span class="keywordflow">return</span> (d_current_size + d_folder_size &gt; d_total_size);
00537 }
00538 
00549 <span class="keywordtype">void</span>
00550 HTTPCache::remove_cache_entry(CacheEntry *entry) <span class="keywordflow">throw</span>(<a class="code" href="classInternalErr.html">InternalErr</a>)
00551 {
00552     <span class="comment">// This should never happen; all calls to this method are protected by</span>
00553     <span class="comment">// the caller, hence the InternalErr.</span>
00554     <span class="keywordflow">if</span> (entry-&gt;locked)
00555     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(<span class="stringliteral">"Tried to delete a cache entry that is in use."</span>);
00556 
00557     <a class="code" href="HTTPCache_8cc.html#a6">REMOVE</a>(entry-&gt;cachename.c_str());
00558     <a class="code" href="HTTPCache_8cc.html#a6">REMOVE</a>(string(entry-&gt;cachename + CACHE_META).c_str());
00559 
00560     d_current_size -= entry-&gt;size;
00561     <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"Current size (after decrement): "</span> &lt;&lt; d_current_size &lt;&lt; endl);
00562 
00563     <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"Deleting CacheEntry: "</span> &lt;&lt; entry &lt;&lt; endl);
00564     <span class="keyword">delete</span> entry;
00565 }
00566 
00581 <span class="keywordtype">void</span>
00582 HTTPCache::perform_garbage_collection()
00583 {
00584     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Performing garbage collection"</span> &lt;&lt; endl);
00585 
00586     <span class="comment">// Remove all the expired responses.</span>
00587     expired_gc();
00588 
00589     <span class="comment">// Remove entries larger than max_entry_size. Also remove entries</span>
00590     <span class="comment">// starting with zero hits, 1, ..., until stopGC() returns true.</span>
00591     hits_gc();
00592 }
00593 
00601 <span class="keyword">class </span>DeleteExpired : 
00602     <span class="keyword">public</span> unary_function&lt;HTTPCache::CacheEntry *&amp;, void&gt; {
00603     time_t d_time;
00604     <a class="code" href="classHTTPCache.html">HTTPCache</a> *d_cache;
00605 
00606 <span class="keyword">public</span>:
00607     DeleteExpired(<a class="code" href="classHTTPCache.html">HTTPCache</a> *cache, time_t t) : 
00608     d_time(t), d_cache(cache) {}
00609 
00610     <span class="keywordtype">void</span> operator()(<a class="code" href="structHTTPCache_1_1CacheEntry.html">HTTPCache::CacheEntry</a> *&amp;e) {
00611     <span class="keywordflow">if</span> (e &amp;&amp; !e-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo17">locked</a> 
00612         &amp;&amp; (e-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo12">freshness_lifetime</a> 
00613         &lt; (e-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo14">corrected_initial_age</a> + (d_time - e-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo13">response_time</a>)))) {
00614         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Deleting expired cache entry: "</span> &lt;&lt; e-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo0">url</a> &lt;&lt; endl);
00615         d_cache-&gt;remove_cache_entry(e);
00616         e = 0;
00617     }
00618     }
00619 };
00620 
00626 <span class="keywordtype">void</span>
00627 HTTPCache::expired_gc()
00628 {
00629     <span class="keywordflow">if</span> (!d_expire_ignored) {
00630     time_t now = time(0);
00631 
00632     <span class="comment">// Walk through and delete all the expired entries.</span>
00633     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cnt = 0; cnt &lt; <a class="code" href="HTTPCache_8h.html#a0">CACHE_TABLE_SIZE</a>; cnt++) {
00634         CachePointers *slot = d_cache_table[cnt];
00635         <span class="keywordflow">if</span> (slot) { 
00636         for_each(slot-&gt;begin(), slot-&gt;end(), <a class="code" href="classHTTPCache.html#HTTPCachen1">DeleteExpired</a>(<span class="keyword">this</span>, now));
00637         slot-&gt;erase(remove(slot-&gt;begin(), slot-&gt;end(),
00638                    static_cast&lt;CacheEntry *&gt;(0)),
00639                 slot-&gt;end());
00640         }
00641     }
00642     }
00643 }    
00644 
00651 <span class="keyword">class </span>DeleteByHits : 
00652     <span class="keyword">public</span> unary_function&lt;HTTPCache::CacheEntry *&amp;, void&gt; {
00653     <a class="code" href="classHTTPCache.html">HTTPCache</a> *d_cache;
00654     <span class="keywordtype">int</span> d_hits;
00655 
00656 <span class="keyword">public</span>:
00657     DeleteByHits(<a class="code" href="classHTTPCache.html">HTTPCache</a> *cache, <span class="keywordtype">int</span> hits) : 
00658     d_cache(cache), d_hits(hits) {}
00659 
00660     <span class="keywordtype">void</span> operator()(<a class="code" href="structHTTPCache_1_1CacheEntry.html">HTTPCache::CacheEntry</a> *&amp;e) {
00661     <span class="keywordflow">if</span> (d_cache-&gt;stopGC())
00662         <span class="keywordflow">return</span>;
00663     <span class="keywordflow">if</span> (e &amp;&amp; !e-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo17">locked</a>
00664         &amp;&amp; (e-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo10">size</a> &gt; d_cache-&gt;d_max_entry_size || e-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo2">hits</a> &lt;= d_hits)) {
00665         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Deleting cache entry: "</span> &lt;&lt; e-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo0">url</a> &lt;&lt; endl);
00666         d_cache-&gt;remove_cache_entry(e);
00667         e = 0;
00668     }        
00669     }
00670 };
00671 
00688 <span class="keywordtype">void</span>
00689 HTTPCache::hits_gc()
00690 {
00691     <span class="keywordtype">int</span> hits = 0;
00692 
00693     <span class="keywordflow">while</span> (startGC()) {
00694     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cnt = 0; cnt &lt; <a class="code" href="HTTPCache_8h.html#a0">CACHE_TABLE_SIZE</a>; cnt++) {
00695         <span class="keywordflow">if</span> (d_cache_table[cnt]) { 
00696         CachePointers *slot = d_cache_table[cnt];
00697         for_each(slot-&gt;begin(), slot-&gt;end(),
00698              <a class="code" href="classHTTPCache.html#HTTPCachen2">DeleteByHits</a>(<span class="keyword">this</span>, hits));
00699         slot-&gt;erase(remove(slot-&gt;begin(), slot-&gt;end(), 
00700                    static_cast&lt;CacheEntry*&gt;(0)),
00701                 slot-&gt;end());
00702 
00703         }
00704     }
00705 
00706     hits++;
00707     }
00708 }
00709 
00711 
00715 
00724 <span class="keywordtype">void</span>
00725 HTTPCache::add_entry_to_cache_table(<a class="code" href="structHTTPCache_1_1CacheEntry.html">HTTPCache::CacheEntry</a> *entry)
00726 {
00727     <span class="keywordtype">int</span> hash = entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo1">hash</a>;
00728 
00729     <span class="keywordflow">if</span> (!d_cache_table[hash]) {
00730     d_cache_table[hash] = <span class="keyword">new</span> CachePointers;
00731     <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"Allocated d_cache_table["</span> &lt;&lt; hash &lt;&lt; <span class="stringliteral">"]: "</span> 
00732         &lt;&lt; d_cache_table[hash] &lt;&lt; endl);
00733     }
00734 
00735     d_cache_table[hash]-&gt;push_back(entry);
00736     <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"Pushing entry: "</span> &lt;&lt; entry &lt;&lt; <span class="stringliteral">" onto d_cache_table["</span> 
00737     &lt;&lt; hash &lt;&lt; <span class="stringliteral">"]"</span> &lt;&lt; endl);
00738 
00739     d_current_size += entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo10">size</a>;
00740     <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"Current size (after increment): "</span> &lt;&lt; d_current_size &lt;&lt; endl);
00741 }
00742 
00753 <a class="code" href="structHTTPCache_1_1CacheEntry.html">HTTPCache::CacheEntry</a> *
00754 HTTPCache::get_entry_from_cache_table(<span class="keywordtype">int</span> hash, <span class="keyword">const</span> string &amp;url)<span class="keyword"> const</span>
00755 <span class="keyword"></span>{
00756     <span class="keywordflow">if</span> (d_cache_table[hash]) {
00757     CachePointers *cp = d_cache_table[hash];
00758     <span class="keywordflow">for</span> (CachePointersIter i = cp-&gt;begin(); i != cp-&gt;end(); ++i)
00759         <span class="comment">// Must test *i because perform_garbage_collection may have</span>
00760         <span class="comment">// removed this entry; the CacheEntry will then be null.</span>
00761         <span class="keywordflow">if</span> ((*i) &amp;&amp; (*i)-&gt;url == url)
00762         <span class="keywordflow">return</span> *i;
00763     }
00764 
00765     <span class="keywordflow">return</span> 0;
00766 }
00767 
00771 <span class="keyword">class </span>DeleteCacheEntry: 
00772     <span class="keyword">public</span> unary_function&lt;HTTPCache::CacheEntry *&amp;, void&gt; {
00773     
00774     string d_url;
00775     <a class="code" href="classHTTPCache.html">HTTPCache</a> *d_cache;
00776 
00777 <span class="keyword">public</span>:
00778     DeleteCacheEntry(<a class="code" href="classHTTPCache.html">HTTPCache</a> *c, <span class="keyword">const</span> string &amp;url) 
00779     : d_url(url), d_cache(c) {}
00780 
00781     <span class="keywordtype">void</span> operator()(<a class="code" href="structHTTPCache_1_1CacheEntry.html">HTTPCache::CacheEntry</a> *&amp;e) {
00782     <span class="keywordflow">if</span> (e &amp;&amp; !e-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo17">locked</a> &amp;&amp; e-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo0">url</a> == d_url) {
00783         d_cache-&gt;remove_cache_entry(e);
00784         e = 0;
00785     }
00786     }
00787 };
00788 
00798 <span class="keywordtype">void</span>
00799 HTTPCache::remove_entry_from_cache_table(<span class="keyword">const</span> string &amp;url) <span class="keywordflow">throw</span>(<a class="code" href="classInternalErr.html">InternalErr</a>)
00800 {
00801     <span class="keywordtype">int</span> hash = get_hash(url);
00802     <span class="keywordflow">if</span> (d_cache_table[hash]) {
00803     CachePointers *cp = d_cache_table[hash];
00804     for_each(cp-&gt;begin(), cp-&gt;end(), DeleteCacheEntry(<span class="keyword">this</span>, url));
00805     cp-&gt;erase(remove(cp-&gt;begin(), cp-&gt;end(), static_cast&lt;CacheEntry*&gt;(0)),
00806           cp-&gt;end());
00807     }
00808 }
00809 
00816 <a class="code" href="structHTTPCache_1_1CacheEntry.html">HTTPCache::CacheEntry</a> *
00817 HTTPCache::get_entry_from_cache_table(<span class="keyword">const</span> string &amp;url)<span class="keyword"> const</span>
00818 <span class="keyword"></span>{
00819     <span class="keywordflow">return</span> get_entry_from_cache_table(get_hash(url), url);
00820 }
00821 
00823 
00832 <span class="keywordtype">void</span>
00833 HTTPCache::create_cache_root(<span class="keyword">const</span> string &amp;cache_root) <span class="keywordflow">throw</span>(<a class="code" href="classError.html">Error</a>)
00834 {
00835     <span class="keyword">struct </span>stat stat_info;
00836     string::size_type cur = 0;
00837 
00838 <span class="preprocessor">#ifdef WIN32</span>
00839 <span class="preprocessor"></span>    cur = cache_root[1] == <span class="charliteral">':'</span> ? 3 : 1;
00840 <span class="preprocessor">#else</span>
00841 <span class="preprocessor"></span>    cur = 1;
00842 <span class="preprocessor">#endif</span>
00843 <span class="preprocessor"></span>    <span class="keywordflow">while</span> ((cur = cache_root.find(DIR_SEPARATOR_CHAR, cur)) != string::npos) {
00844     string dir = cache_root.substr(0, cur);
00845     <span class="keywordflow">if</span> (stat(dir.c_str(), &amp;stat_info) == -1) {
00846         <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"Cache....... Creating "</span> &lt;&lt; dir &lt;&lt; endl);
00847         <span class="keywordflow">if</span> (<a class="code" href="HTTPCache_8cc.html#a5">MKDIR</a>(dir.c_str(), 0777) &lt; 0) {
00848         <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"Error: can't create."</span> &lt;&lt; endl);
00849         <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(string(<span class="stringliteral">"Could not create the directory for the cache. Failed when building path at "</span>) + dir + string(<span class="stringliteral">"."</span>));
00850         }
00851     } <span class="keywordflow">else</span> {
00852         <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"Cache....... Found "</span> &lt;&lt; dir &lt;&lt; endl);
00853     }
00854     cur++;
00855     }
00856 }
00857 
00872 <span class="keywordtype">void</span>
00873 HTTPCache::set_cache_root(<span class="keyword">const</span> string &amp;root) <span class="keywordflow">throw</span>(<a class="code" href="classError.html">Error</a>)
00874 {
00875     <span class="keywordflow">if</span> (root != <span class="stringliteral">""</span>) {
00876     d_cache_root = root;
00877     <span class="comment">// cache root should end in /.</span>
00878     <span class="keywordflow">if</span> (d_cache_root[d_cache_root.size()-1] != <a class="code" href="HTTPCache_8cc.html#a8">DIR_SEPARATOR_CHAR</a>)
00879         d_cache_root += <a class="code" href="HTTPCache_8cc.html#a8">DIR_SEPARATOR_CHAR</a>;
00880     } <span class="keywordflow">else</span> {
00881     <span class="comment">// If no cache root has been indicated then look for a suitable</span>
00882     <span class="comment">// location.</span>
00883     <span class="keywordtype">char</span> * cr = (<span class="keywordtype">char</span> *) getenv(<span class="stringliteral">"DODS_CACHE"</span>);
00884     <span class="keywordflow">if</span> (!cr) cr = (<span class="keywordtype">char</span> *) getenv(<span class="stringliteral">"TMP"</span>);
00885     <span class="keywordflow">if</span> (!cr) cr = (<span class="keywordtype">char</span> *) getenv(<span class="stringliteral">"TEMP"</span>);
00886     <span class="keywordflow">if</span> (!cr) cr = <a class="code" href="HTTPCache_8cc.html#a10">CACHE_LOC</a>;
00887 
00888     d_cache_root = cr;
00889     <span class="keywordflow">if</span> (d_cache_root[d_cache_root.size()-1] != <a class="code" href="HTTPCache_8cc.html#a8">DIR_SEPARATOR_CHAR</a>)
00890         d_cache_root += <a class="code" href="HTTPCache_8cc.html#a8">DIR_SEPARATOR_CHAR</a>;
00891     
00892     d_cache_root += <a class="code" href="HTTPCache_8cc.html#a11">CACHE_ROOT</a>;
00893     }
00894 
00895     d_cache_index = d_cache_root + <a class="code" href="HTTPCache_8cc.html#a12">CACHE_INDEX</a>;
00896 }
00897 
00908 <span class="keywordtype">bool</span>
00909 HTTPCache::get_single_user_lock(<span class="keywordtype">bool</span> force)
00910 {
00911     <span class="keywordflow">if</span> (!d_locked_open_file) {
00912     FILE * fp = NULL;
00913 
00914     <span class="keywordflow">try</span> {
00915         <span class="comment">// It's OK to call create_cache_root if the directory already</span>
00916         <span class="comment">// exists.</span>
00917         create_cache_root(d_cache_root);
00918     }
00919     <span class="keywordflow">catch</span> (<a class="code" href="classError.html">Error</a> &amp;e) {
00920         <span class="comment">// We need to catch and return false because this method is</span>
00921         <span class="comment">// called from a ctor and throwing at this point will result in a</span>
00922         <span class="comment">// partially constructed object. 01/22/04 jhrg</span>
00923         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00924     }
00925 
00926     string lock = d_cache_root + <a class="code" href="HTTPCache_8cc.html#a13">CACHE_LOCK</a>;
00927     <span class="keywordflow">if</span> ((fp = fopen(lock.c_str(), <span class="stringliteral">"r"</span>)) != NULL) {
00928         <span class="keywordtype">int</span> res = fclose(fp);
00929         <span class="keywordflow">if</span>( res ) {
00930         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"HTTPCache::get_single_user_lock - Failed to close "</span> &lt;&lt; (<span class="keywordtype">void</span> *)fp &lt;&lt; endl ;) ;
00931         }
00932         <span class="keywordflow">if</span> (force)
00933         <a class="code" href="HTTPCache_8cc.html#a6">REMOVE</a>(lock.c_str());
00934         <span class="keywordflow">else</span>
00935         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00936     }
00937 
00938     <span class="keywordflow">if</span> ((fp = fopen(lock.c_str(), <span class="stringliteral">"w"</span>)) == NULL)
00939         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00940 
00941     d_locked_open_file = fp;
00942     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00943     }
00944 
00945     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00946 }
00947 
00950 <span class="keywordtype">void</span> 
00951 HTTPCache::release_single_user_lock()
00952 {
00953     <span class="keywordflow">if</span> (d_locked_open_file) {
00954     <span class="keywordtype">int</span> res = fclose(d_locked_open_file);
00955     <span class="keywordflow">if</span>( res ) {
00956         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"HTTPCache::release_single_user_lock - Failed to close "</span> &lt;&lt; (<span class="keywordtype">void</span> *)d_locked_open_file &lt;&lt; endl ;) ;
00957     }
00958     d_locked_open_file = 0;
00959     }
00960         
00961     string lock = d_cache_root + <a class="code" href="HTTPCache_8cc.html#a13">CACHE_LOCK</a>;
00962     <a class="code" href="HTTPCache_8cc.html#a6">REMOVE</a>(lock.c_str());
00963 }
00964 
00967 
00971 string
<a name="l00972"></a><a class="code" href="classHTTPCache.html#HTTPCachez35_0">00972</a> <a class="code" href="classHTTPCache.html#HTTPCachez35_0">HTTPCache::get_cache_root</a>()<span class="keyword"> const</span>
00973 <span class="keyword"></span>{
00974     <span class="keywordflow">return</span> d_cache_root;
00975 }
00976 
00988 <span class="keywordtype">void</span>
<a name="l00989"></a><a class="code" href="classHTTPCache.html#HTTPCachez35_1">00989</a> <a class="code" href="classHTTPCache.html#HTTPCachez35_1">HTTPCache::set_cache_enabled</a>(<span class="keywordtype">bool</span> mode)
00990 {
00991     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Locking interface... "</span>);
00992     <a class="code" href="HTTPCache_8cc.html#a0">LOCK</a>(&amp;d_cache_mutex);
00993 
00994     d_cache_enabled = mode;
00995 
00996     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
00997     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
00998 }
00999 
01002 <span class="keywordtype">bool</span>
<a name="l01003"></a><a class="code" href="classHTTPCache.html#HTTPCachez35_2">01003</a> <a class="code" href="classHTTPCache.html#HTTPCachez35_2">HTTPCache::is_cache_enabled</a>()<span class="keyword"> const</span>
01004 <span class="keyword"></span>{
01005     <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"In HTTPCache::is_cache_enabled: ("</span> &lt;&lt; d_cache_enabled &lt;&lt; <span class="stringliteral">")"</span> 
01006      &lt;&lt; endl);
01007     <span class="keywordflow">return</span> d_cache_enabled;
01008 }
01009 
01019 <span class="keywordtype">void</span>
<a name="l01020"></a><a class="code" href="classHTTPCache.html#HTTPCachez35_3">01020</a> <a class="code" href="classHTTPCache.html#HTTPCachez35_3">HTTPCache::set_cache_protected</a>(<span class="keywordtype">bool</span> mode)
01021 {
01022     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Locking interface... "</span>);
01023     <a class="code" href="HTTPCache_8cc.html#a0">LOCK</a>(&amp;d_cache_mutex);
01024 
01025     d_cache_protected = mode;
01026 
01027     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
01028     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
01029 }
01030 
01033 <span class="keywordtype">bool</span>
<a name="l01034"></a><a class="code" href="classHTTPCache.html#HTTPCachez35_4">01034</a> <a class="code" href="classHTTPCache.html#HTTPCachez35_4">HTTPCache::is_cache_protected</a>()<span class="keyword"> const</span>
01035 <span class="keyword"></span>{
01036     <span class="keywordflow">return</span> d_cache_protected;
01037 }
01038 
01049 <span class="keywordtype">void</span>
<a name="l01050"></a><a class="code" href="classHTTPCache.html#HTTPCachez35_5">01050</a> <a class="code" href="classHTTPCache.html#HTTPCachez35_5">HTTPCache::set_cache_disconnected</a>(CacheDisconnectedMode mode)
01051 {
01052     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Locking interface... "</span>);
01053     <a class="code" href="HTTPCache_8cc.html#a0">LOCK</a>(&amp;d_cache_mutex);
01054 
01055     d_cache_disconnected = mode;
01056 
01057     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
01058     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
01059 }
01060 
01063 <a class="code" href="HTTPCacheDisconnectedMode_8h.html#a3">CacheDisconnectedMode</a>
<a name="l01064"></a><a class="code" href="classHTTPCache.html#HTTPCachez35_6">01064</a> <a class="code" href="classHTTPCache.html#HTTPCachez35_6">HTTPCache::get_cache_disconnected</a>()<span class="keyword"> const</span>
01065 <span class="keyword"></span>{
01066     <span class="keywordflow">return</span> d_cache_disconnected;
01067 }
01068 
01077 <span class="keywordtype">void</span>
<a name="l01078"></a><a class="code" href="classHTTPCache.html#HTTPCachez35_7">01078</a> <a class="code" href="classHTTPCache.html#HTTPCachez35_7">HTTPCache::set_expire_ignored</a>(<span class="keywordtype">bool</span> mode)
01079 {
01080     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Locking interface... "</span>);
01081     <a class="code" href="HTTPCache_8cc.html#a0">LOCK</a>(&amp;d_cache_mutex);
01082 
01083     d_expire_ignored = mode;
01084 
01085     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
01086     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
01087 }
01088 
01089 <span class="comment">/* Is the cache ignoring Expires headers returned with responses that have</span>
01090 <span class="comment">   been cached? */</span>
01091 
01092 <span class="keywordtype">bool</span>
<a name="l01093"></a><a class="code" href="classHTTPCache.html#HTTPCachez35_8">01093</a> <a class="code" href="classHTTPCache.html#HTTPCachez35_8">HTTPCache::is_expire_ignored</a>()<span class="keyword"> const</span>
01094 <span class="keyword"></span>{
01095     <span class="keywordflow">return</span> d_expire_ignored;
01096 }
01097 
01113 <span class="keywordtype">void</span>
<a name="l01114"></a><a class="code" href="classHTTPCache.html#HTTPCachez35_9">01114</a> <a class="code" href="classHTTPCache.html#HTTPCachez35_9">HTTPCache::set_max_size</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> size)
01115 {
01116     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Locking interface... "</span>);
01117     <a class="code" href="HTTPCache_8cc.html#a0">LOCK</a>(&amp;d_cache_mutex);
01118     
01119     <span class="keywordflow">try</span> {
01120     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> new_size = size &lt; <a class="code" href="HTTPCache_8cc.html#a24">MIN_CACHE_TOTAL_SIZE</a> ?
01121         <a class="code" href="HTTPCache_8cc.html#a24">MIN_CACHE_TOTAL_SIZE</a>*<a class="code" href="HTTPCache_8cc.html#a20">MEGA</a> : 
01122         (size &gt; UINT_MAX || size &lt; 0 ? UINT_MAX : size * <a class="code" href="HTTPCache_8cc.html#a20">MEGA</a>);
01123     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> old_size = d_total_size;
01124     d_total_size = new_size;
01125     d_folder_size = d_total_size/<a class="code" href="HTTPCache_8cc.html#a22">CACHE_FOLDER_PCT</a>;
01126     d_gc_buffer = d_total_size/<a class="code" href="HTTPCache_8cc.html#a23">CACHE_GC_PCT</a>;
01127 
01128     <span class="keywordflow">if</span> (new_size &lt; old_size) {
01129         <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
01130         <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
01131 
01132         <span class="keywordflow">if</span> (startGC()) {
01133         perform_garbage_collection();
01134         <a class="code" href="classHTTPCache.html#HTTPCachez29_0">cache_index_write</a>();
01135         }
01136 
01137         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Locking interface... "</span>);
01138         <a class="code" href="HTTPCache_8cc.html#a0">LOCK</a>(&amp;d_cache_mutex);
01139     }
01140     }
01141     <span class="keywordflow">catch</span> (<a class="code" href="classError.html">Error</a> &amp;e) {
01142     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
01143     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
01144     <span class="keywordflow">throw</span> e;
01145     }
01146 
01147     <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"Cache....... Total cache size: "</span> &lt;&lt; d_total_size
01148      &lt;&lt; <span class="stringliteral">" with "</span> &lt;&lt; d_folder_size 
01149      &lt;&lt; <span class="stringliteral">" bytes for meta information and folders and at least "</span>
01150      &lt;&lt; d_gc_buffer &lt;&lt; <span class="stringliteral">" bytes free after every gc"</span> &lt;&lt; endl);
01151 
01152     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
01153     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
01154 }
01155 
01158 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>
<a name="l01159"></a><a class="code" href="classHTTPCache.html#HTTPCachez35_10">01159</a> <a class="code" href="classHTTPCache.html#HTTPCachez35_10">HTTPCache::get_max_size</a>()<span class="keyword"> const</span>
01160 <span class="keyword"></span>{
01161     <span class="keywordflow">return</span> d_total_size / <a class="code" href="HTTPCache_8cc.html#a20">MEGA</a>;
01162 }
01163 
01172 <span class="keywordtype">void</span>
<a name="l01173"></a><a class="code" href="classHTTPCache.html#HTTPCachez35_11">01173</a> <a class="code" href="classHTTPCache.html#HTTPCachez35_11">HTTPCache::set_max_entry_size</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> size)
01174 {
01175     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Locking interface... "</span>);
01176     <a class="code" href="HTTPCache_8cc.html#a0">LOCK</a>(&amp;d_cache_mutex);
01177 
01178     <span class="keywordflow">try</span> {
01179     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> new_size = size*<a class="code" href="HTTPCache_8cc.html#a20">MEGA</a>;
01180     <span class="keywordflow">if</span> (new_size &gt; 0 &amp;&amp; new_size &lt; d_total_size - d_folder_size) {
01181         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> old_size = d_max_entry_size;
01182         d_max_entry_size = new_size;
01183         <span class="keywordflow">if</span> (new_size &lt; old_size) {
01184         <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
01185         <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
01186 
01187         <span class="keywordflow">if</span> (startGC()) {
01188             perform_garbage_collection();
01189             <a class="code" href="classHTTPCache.html#HTTPCachez29_0">cache_index_write</a>();
01190         }
01191 
01192         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Locking interface... "</span>);
01193         <a class="code" href="HTTPCache_8cc.html#a0">LOCK</a>(&amp;d_cache_mutex);
01194         }
01195     }
01196     }
01197     <span class="keywordflow">catch</span> (<a class="code" href="classError.html">Error</a> &amp;e) {
01198     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
01199     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
01200     <span class="keywordflow">throw</span> e;
01201     }
01202 
01203     <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"Cache...... Max entry cache size is "</span> 
01204      &lt;&lt; d_max_entry_size &lt;&lt; endl);
01205 
01206     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
01207     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
01208 }
01209 
01214 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>
<a name="l01215"></a><a class="code" href="classHTTPCache.html#HTTPCachez35_12">01215</a> <a class="code" href="classHTTPCache.html#HTTPCachez35_12">HTTPCache::get_max_entry_size</a>()<span class="keyword"> const</span>
01216 <span class="keyword"></span>{
01217     <span class="keywordflow">return</span> d_max_entry_size / <a class="code" href="HTTPCache_8cc.html#a20">MEGA</a>;
01218 }
01219 
01230 <span class="keywordtype">void</span>
<a name="l01231"></a><a class="code" href="classHTTPCache.html#HTTPCachez35_13">01231</a> <a class="code" href="classHTTPCache.html#HTTPCachez35_13">HTTPCache::set_default_expiration</a> (<span class="keyword">const</span> <span class="keywordtype">int</span> exp_time)
01232 {
01233     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Locking interface... "</span>);
01234     <a class="code" href="HTTPCache_8cc.html#a0">LOCK</a>(&amp;d_cache_mutex);
01235 
01236     d_default_expiration = exp_time;
01237 
01238     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
01239     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
01240 }
01241 
01244 <span class="keywordtype">int</span>
<a name="l01245"></a><a class="code" href="classHTTPCache.html#HTTPCachez35_14">01245</a> <a class="code" href="classHTTPCache.html#HTTPCachez35_14">HTTPCache::get_default_expiration</a>()<span class="keyword"> const</span>
01246 <span class="keyword"></span>{
01247     <span class="keywordflow">return</span> d_default_expiration;
01248 }
01249 
01254 <span class="keywordtype">void</span>
<a name="l01255"></a><a class="code" href="classHTTPCache.html#HTTPCachez35_15">01255</a> <a class="code" href="classHTTPCache.html#HTTPCachez35_15">HTTPCache::set_always_validate</a>(<span class="keywordtype">bool</span> validate)
01256 {
01257     d_always_validate = validate;
01258 }
01259 
01263 <span class="keywordtype">bool</span> 
<a name="l01264"></a><a class="code" href="classHTTPCache.html#HTTPCachez35_16">01264</a> <a class="code" href="classHTTPCache.html#HTTPCachez35_16">HTTPCache::get_always_validate</a>()<span class="keyword"> const</span>
01265 <span class="keyword"></span>{
01266     <span class="keywordflow">return</span> d_always_validate;
01267 }
01268 
01285 <span class="keywordtype">void</span> 
<a name="l01286"></a><a class="code" href="classHTTPCache.html#HTTPCachez35_17">01286</a> <a class="code" href="classHTTPCache.html#HTTPCachez35_17">HTTPCache::set_cache_control</a>(<span class="keyword">const</span> vector&lt;string&gt; &amp;cc) <span class="keywordflow">throw</span>(<a class="code" href="classInternalErr.html">InternalErr</a>)
01287 {
01288     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Locking interface... "</span>);
01289     <a class="code" href="HTTPCache_8cc.html#a0">LOCK</a>(&amp;d_cache_mutex);
01290 
01291     <span class="keywordflow">try</span> {
01292     d_cache_control = cc;
01293 
01294     vector&lt;string&gt;::const_iterator i;
01295     <span class="keywordflow">for</span> (i = cc.begin(); i != cc.end(); ++i) {
01296         string header = (*i).substr(0, (*i).find(<span class="charliteral">':'</span>));
01297         string value = (*i).substr((*i).find(<span class="stringliteral">": "</span>) + 2);
01298         <span class="keywordflow">if</span> (header != <span class="stringliteral">"Cache-Control"</span>) {
01299         <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, <span class="stringliteral">"Expected cache control header not found."</span>);
01300         }
01301         <span class="keywordflow">else</span> {
01302         <span class="keywordflow">if</span> (value == <span class="stringliteral">"no-cache"</span> || value == <span class="stringliteral">"no-store"</span>)
01303             d_cache_enabled = <span class="keyword">false</span>;
01304         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (value.find(<span class="stringliteral">"max-age"</span>) != string::npos) {
01305             string max_age = value.substr(value.find(<span class="stringliteral">"="</span> + 1));
01306             d_max_age = <a class="code" href="util__mit_8cc.html#a6">parse_time</a>(max_age.c_str());
01307         }
01308         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (value == <span class="stringliteral">"max-stale"</span>)
01309             d_max_stale = 0; <span class="comment">// indicates will take anything;</span>
01310         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (value.find(<span class="stringliteral">"max-stale"</span>) != string::npos) {
01311             string max_stale = value.substr(value.find(<span class="stringliteral">"="</span> + 1));
01312             d_max_stale = <a class="code" href="util__mit_8cc.html#a6">parse_time</a>(max_stale.c_str());
01313         }
01314         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (value.find(<span class="stringliteral">"min-fresh"</span>) != string::npos) {
01315             string min_fresh = value.substr(value.find(<span class="stringliteral">"="</span> + 1));
01316             d_min_fresh = <a class="code" href="util__mit_8cc.html#a6">parse_time</a>(min_fresh.c_str());
01317         }
01318         }
01319     }
01320     }
01321     <span class="keywordflow">catch</span> (<a class="code" href="classError.html">Error</a> &amp;e) {
01322     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
01323     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
01324     <span class="keywordflow">throw</span> e;
01325     }
01326 
01327     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
01328     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
01329 }
01330 
01331 
01338 vector&lt;string&gt;
<a name="l01339"></a><a class="code" href="classHTTPCache.html#HTTPCachez35_18">01339</a> <a class="code" href="classHTTPCache.html#HTTPCachez35_18">HTTPCache::get_cache_control</a>()
01340 {
01341     <span class="keywordflow">return</span> d_cache_control;
01342 }
01343 
01345 
01358 string 
01359 HTTPCache::create_hash_directory(<span class="keywordtype">int</span> hash) <span class="keywordflow">throw</span>(<a class="code" href="classError.html">Error</a>)
01360 {
01361     <span class="keyword">struct </span>stat stat_info;
01362     ostringstream path;
01363 
01364     path &lt;&lt; d_cache_root &lt;&lt; hash;
01365     string p = path.str();
01366 
01367     <span class="keywordflow">if</span> (stat(p.c_str(), &amp;stat_info) == -1) {
01368     <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"Cache....... Create dir "</span> &lt;&lt; p &lt;&lt; endl);
01369     <span class="keywordflow">if</span> (<a class="code" href="HTTPCache_8cc.html#a5">MKDIR</a>(p.c_str(), 0777) &lt; 0) {
01370         <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"Cache....... Can't create..."</span> &lt;&lt; endl);
01371         <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(<span class="stringliteral">"Could not create cache slot to hold response! Check the write permissions on your disk cache directory. Cache root: "</span> + d_cache_root + <span class="stringliteral">"."</span>);
01372     }
01373     } <span class="keywordflow">else</span> {
01374     <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"Cache....... Directory "</span> &lt;&lt; p &lt;&lt; <span class="stringliteral">" already exists"</span> 
01375         &lt;&lt; endl);
01376     }
01377 
01378     <span class="keywordflow">return</span> p;
01379 }
01380 
01395 <span class="keywordtype">void</span>
01396 HTTPCache::create_location(CacheEntry *entry) <span class="keywordflow">throw</span>(<a class="code" href="classError.html">Error</a>)
01397 {
01398     string hash_dir = create_hash_directory(entry-&gt;hash);
01399 <span class="preprocessor">#ifdef WIN32</span>
01400 <span class="preprocessor"></span>    hash_dir += <span class="stringliteral">"\\dodsXXXXXX"</span>;
01401 <span class="preprocessor">#else</span>
01402 <span class="preprocessor"></span>    hash_dir += <span class="stringliteral">"/dodsXXXXXX"</span>;  <span class="comment">// mkstemp uses six characters.</span>
01403 <span class="preprocessor">#endif</span>
01404 <span class="preprocessor"></span>
01405     <span class="comment">// mkstemp uses the storage passed to it; must be writable and local.</span>
01406     <span class="keywordtype">char</span> *templat = <span class="keyword">new</span> <span class="keywordtype">char</span>[hash_dir.size() + 1];
01407     strcpy(templat, hash_dir.c_str());
01408 
01409     <span class="comment">// Open truncated for update. NB: mkstemp() returns a file descriptor.</span>
01410     <span class="comment">// man mkstemp says "... The file is opened with the O_EXCL flag,</span>
01411     <span class="comment">// guaranteeing that when mkstemp returns successfully we are the only</span>
01412     <span class="comment">// user." 09/19/02 jhrg</span>
01413     <span class="keywordtype">int</span> fd = <a class="code" href="HTTPCache_8cc.html#a7">MKSTEMP</a>(templat);  <span class="comment">// fd mode is 666 or 600 (Unix)</span>
01414     <span class="keywordflow">if</span> (fd &lt; 0) {
01415     <span class="keyword">delete</span> templat;
01416     close(fd);
01417     <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(<span class="stringliteral">"The HTTP Cache could not create a file to hold the response; it will not be cached."</span>);
01418     }
01419 
01420     entry-&gt;cachename = templat;
01421     <span class="keyword">delete</span>[] templat;
01422     close(fd);
01423 }
01424 
01435 <span class="keywordtype">void</span>
01436 HTTPCache::parse_headers(CacheEntry *entry, <span class="keyword">const</span> vector&lt;string&gt; &amp;headers)
01437 {
01438     vector&lt;string&gt;::const_iterator i;
01439     <span class="keywordflow">for</span> (i = headers.begin(); i != headers.end(); ++i) {
01440     string header = (*i).substr(0, (*i).find(<span class="charliteral">':'</span>));
01441     string value = (*i).substr((*i).find(<span class="stringliteral">": "</span>) + 2);
01442     <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"Header: "</span> &lt;&lt; header &lt;&lt; endl);
01443     <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"Value: "</span> &lt;&lt; value &lt;&lt; endl);
01444 
01445     <span class="keywordflow">if</span> (header == <span class="stringliteral">"ETag"</span>) {
01446         entry-&gt;etag = value;
01447     }
01448     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (header == <span class="stringliteral">"Last-Modified"</span>) {
01449         entry-&gt;lm = <a class="code" href="util__mit_8cc.html#a6">parse_time</a>(value.c_str());
01450     }
01451     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (header == <span class="stringliteral">"Expires"</span>) {
01452         entry-&gt;expires = <a class="code" href="util__mit_8cc.html#a6">parse_time</a>(value.c_str());
01453     }
01454     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (header == <span class="stringliteral">"Date"</span>) {
01455         entry-&gt;date = <a class="code" href="util__mit_8cc.html#a6">parse_time</a>(value.c_str());
01456     }
01457     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (header == <span class="stringliteral">"Age"</span>) {
01458         entry-&gt;age = <a class="code" href="util__mit_8cc.html#a6">parse_time</a>(value.c_str());
01459     }
01460     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (header == <span class="stringliteral">"Content-Length"</span>) {
01461         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> clength = strtoul(value.c_str(), 0, 0);
01462         <span class="keywordflow">if</span> (clength &gt; d_max_entry_size)
01463         entry-&gt;no_cache = <span class="keyword">true</span>;
01464     }
01465     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (header == <span class="stringliteral">"Cache-Control"</span>) {
01466         <span class="comment">// Ignored Cache-Control values: public, private, no-transform,</span>
01467         <span class="comment">// proxy-revalidate, s-max-age. These are used by shared caches.</span>
01468         <span class="comment">// See section 14.9 of RFC 2612. 10/02/02 jhrg</span>
01469         <span class="keywordflow">if</span> (value == <span class="stringliteral">"no-cache"</span> || value == <span class="stringliteral">"no-store"</span>) 
01470         <span class="comment">// Note that we *can* store a 'no-store' response in volatile</span>
01471         <span class="comment">// memory according to RFC 2616 (section 14.9.2) but those</span>
01472         <span class="comment">// will be rare coming from DAP servers. 10/02/02 jhrg</span>
01473         entry-&gt;no_cache = <span class="keyword">true</span>;
01474         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (value == <span class="stringliteral">"must-revalidate"</span>)
01475         entry-&gt;must_revalidate = <span class="keyword">true</span>;
01476         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (value.find(<span class="stringliteral">"max-age"</span>) != string::npos) {
01477         string max_age = value.substr(value.find(<span class="stringliteral">"="</span> + 1));
01478         entry-&gt;max_age = <a class="code" href="util__mit_8cc.html#a6">parse_time</a>(max_age.c_str());
01479         }
01480     }
01481     }
01482 }
01483 
01495 <span class="keywordtype">void</span>
01496 HTTPCache::calculate_time(CacheEntry *entry, time_t request_time)
01497 {
01498     entry-&gt;response_time = time(NULL);
01499     time_t apparent_age 
01500     = max(0, static_cast&lt;int&gt;(entry-&gt;response_time - entry-&gt;date));
01501     time_t corrected_received_age = max(apparent_age, entry-&gt;age);
01502     time_t response_delay = entry-&gt;response_time - request_time;
01503     entry-&gt;corrected_initial_age = corrected_received_age + response_delay;
01504 
01505     <span class="comment">// Estimate an expires time using the max-age and expires time. If we</span>
01506     <span class="comment">// don't have an explicit expires time then set it to 10% of the LM date</span>
01507     <span class="comment">// (although max 24 h). If no LM date is available then use 24 hours.</span>
01508     time_t freshness_lifetime = entry-&gt;max_age;
01509     <span class="keywordflow">if</span> (freshness_lifetime &lt; 0) {
01510     <span class="keywordflow">if</span> (entry-&gt;expires &lt; 0) {
01511         <span class="keywordflow">if</span> (entry-&gt;lm &lt; 0) {
01512         freshness_lifetime = <a class="code" href="HTTPCache_8cc.html#a16">NO_LM_EXPIRATION</a>;
01513         } 
01514         <span class="keywordflow">else</span> {
01515         freshness_lifetime = <a class="code" href="HTTPCache_8cc.html#a18">LM_EXPIRATION</a>(entry-&gt;date - entry-&gt;lm);
01516         }
01517     } 
01518     <span class="keywordflow">else</span>
01519         freshness_lifetime = entry-&gt;expires - entry-&gt;date;
01520     }
01521 
01522     entry-&gt;freshness_lifetime = max(0, static_cast&lt;int&gt;(freshness_lifetime));
01523 
01524     <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"Cache....... Received Age "</span> &lt;&lt; entry-&gt;age
01525     &lt;&lt; <span class="stringliteral">", corrected "</span> &lt;&lt; entry-&gt;corrected_initial_age
01526     &lt;&lt; <span class="stringliteral">", freshness lifetime "</span> &lt;&lt; entry-&gt;freshness_lifetime &lt;&lt; endl);
01527 }
01528 
01536 <span class="keywordtype">bool</span>
<a name="l01537"></a><a class="code" href="classHTTPCache.html#HTTPCachea4">01537</a> <a class="code" href="classHTTPCache.html#HTTPCachea4">HTTPCache::is_url_in_cache</a>(<span class="keyword">const</span> string &amp;url)
01538 {
01539     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Is this url in the cache? ("</span> &lt;&lt; url &lt;&lt; <span class="stringliteral">")"</span> &lt;&lt; endl);
01540 
01541     <span class="keywordflow">return</span> get_entry_from_cache_table(url) != 0;
01542 }
01543 
01549 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span>
01550 is_hop_by_hop_header(<span class="keyword">const</span> string &amp;header) 
01551 {
01552     <span class="keywordflow">return</span> header.find(<span class="stringliteral">"Connection"</span>) != string::npos
01553     || header.find(<span class="stringliteral">"Keep-Alive"</span>) != string::npos
01554     || header.find(<span class="stringliteral">"Proxy-Authenticate"</span>) != string::npos
01555     || header.find(<span class="stringliteral">"Proxy-Authorization"</span>) != string::npos
01556     || header.find(<span class="stringliteral">"Transfer-Encoding"</span>) != string::npos
01557     || header.find(<span class="stringliteral">"Upgrade"</span>) != string::npos;
01558 }
01559 
01571 <span class="keywordtype">void</span>
01572 HTTPCache::write_metadata(<span class="keyword">const</span> string &amp;cachename, 
01573               <span class="keyword">const</span> vector&lt;string&gt; &amp;headers) 
01574     <span class="keywordflow">throw</span>(<a class="code" href="classInternalErr.html">InternalErr</a>)
01575 {
01576     FILE *dest = fopen(string(cachename + CACHE_META).c_str(), <span class="stringliteral">"w"</span>);
01577     <span class="keywordflow">if</span> (!dest) {
01578     fclose(dest);
01579     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, <span class="stringliteral">"Could not open named cache entry file."</span>);
01580     }
01581 
01582     vector&lt;string&gt;::const_iterator i;
01583     <span class="keywordflow">for</span> (i = headers.begin(); i != headers.end(); ++i) {
01584     <span class="keywordflow">if</span> (!is_hop_by_hop_header(*i)) {
01585         fwrite((*i).c_str(), (*i).size(), 1, dest);
01586         fwrite(<span class="stringliteral">"\n"</span>, 1, 1, dest);
01587     }
01588     }
01589 
01590     <span class="keywordtype">int</span> res = fclose(dest);
01591     <span class="keywordflow">if</span>( res ) {
01592     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"HTTPCache::write_metadata - Failed to close "</span> &lt;&lt; (<span class="keywordtype">void</span> *)dest &lt;&lt; endl ;) ;
01593     }
01594 }
01595 
01606 <span class="keywordtype">void</span>
01607 HTTPCache::read_metadata(<span class="keyword">const</span> string &amp;cachename, vector&lt;string&gt; &amp;headers) 
01608     <span class="keyword">const</span> <span class="keywordflow">throw</span>(<a class="code" href="classInternalErr.html">InternalErr</a>)
01609 {
01610     FILE *md = fopen(string(cachename + CACHE_META).c_str(), <span class="stringliteral">"r"</span>);
01611     <span class="keywordflow">if</span> (!md) {
01612     fclose( md ) ;
01613     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, <span class="stringliteral">"Could not open named cache entry meta data file."</span>);
01614     }
01615 
01616     <span class="keywordtype">char</span> line[1024];
01617     <span class="keywordflow">while</span> (!feof(md) &amp;&amp; fgets(line, 1024, md)) {
01618     line[strlen(line)-1] = <span class="charliteral">'\0'</span>; <span class="comment">// erase newline</span>
01619     headers.push_back(string(line));
01620     }
01621 
01622     <span class="keywordtype">int</span> res = fclose(md);
01623     <span class="keywordflow">if</span>( res ) {
01624     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"HTTPCache::read_metadata - Failed to close "</span> &lt;&lt; (<span class="keywordtype">void</span> *)md &lt;&lt; endl ;) ;
01625     }
01626 }
01627 
01649 <span class="keywordtype">int</span>
01650 HTTPCache::write_body(<span class="keyword">const</span> string &amp;cachename, <span class="keyword">const</span> FILE *src) 
01651     <span class="keywordflow">throw</span>(<a class="code" href="classInternalErr.html">InternalErr</a>, <a class="code" href="classResponseTooBigErr.html">ResponseTooBigErr</a>)
01652 {
01653     FILE *dest = fopen(cachename.c_str(), <span class="stringliteral">"wb"</span>);
01654     <span class="keywordflow">if</span> (!dest) {
01655     <span class="keywordflow">throw</span> InternalErr(__FILE__, __LINE__, <span class="stringliteral">"Could not open named cache entry file."</span>);
01656     }
01657 
01658     <span class="comment">// Read and write in 1k blocks; an attempt at doing this efficiently.</span>
01659     <span class="comment">// 09/30/02 jhrg</span>
01660     <span class="keywordtype">char</span> line[1024];
01661     size_t n;
01662     <span class="keywordtype">int</span> total = 0;
01663     <span class="keywordflow">while</span> ((n = fread(line, 1, 1024, const_cast&lt;FILE *&gt;(src))) &gt; 0) {
01664     total += fwrite(line, 1, n, dest);
01665 <span class="preprocessor">#if 0</span>
01666 <span class="preprocessor"></span>    <span class="comment">// See comment above.</span>
01667     <span class="keywordflow">if</span> (total &gt; d_max_entry_size)
01668         <span class="keywordflow">throw</span> <a class="code" href="classResponseTooBigErr.html">ResponseTooBigErr</a>(<span class="stringliteral">"This response is too big to cache."</span>);
01669 <span class="preprocessor">#endif</span>
01670 <span class="preprocessor"></span>    }
01671     
01672     <span class="keywordflow">if</span> (ferror(const_cast&lt;FILE *&gt;(src)) || ferror(dest)) {
01673     <span class="keywordtype">int</span> res = fclose(dest);
01674     <span class="keywordflow">if</span>( res ) {
01675         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"HTTPCache::write_body - Failed to close "</span> &lt;&lt; (<span class="keywordtype">void</span> *)dest &lt;&lt; endl ;) ;
01676     }
01677     <span class="keywordflow">throw</span> InternalErr(__FILE__, __LINE__, <span class="stringliteral">"I/O error transferring data to the cache."</span>);
01678     }
01679 
01680     rewind(const_cast&lt;FILE *&gt;(src));
01681 
01682     <span class="keywordtype">int</span> res = fclose(dest);
01683     <span class="keywordflow">if</span>( res ) {
01684     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"HTTPCache::write_body - Failed to close "</span> &lt;&lt; (<span class="keywordtype">void</span> *)dest &lt;&lt; endl ;) ;
01685     }
01686 
01687     <span class="keywordflow">return</span> total;
01688 }
01689 
01698 FILE *
01699 HTTPCache::open_body(<span class="keyword">const</span> string &amp;cachename) <span class="keyword">const</span> <span class="keywordflow">throw</span>(InternalErr)
01700 {
01701     FILE *src = fopen(cachename.c_str(), <span class="stringliteral">"r+b"</span>);
01702     <span class="keywordflow">if</span> (!src) {
01703     fclose(src);
01704     <span class="keywordflow">throw</span> InternalErr(__FILE__, __LINE__, <span class="stringliteral">"Could not open named cache entry file."</span>);
01705     }
01706 
01707     <span class="keywordflow">return</span> src;
01708 }
01709 
01735 <span class="keywordtype">bool</span>
<a name="l01736"></a><a class="code" href="classHTTPCache.html#HTTPCachea1">01736</a> <a class="code" href="classHTTPCache.html#HTTPCachea1">HTTPCache::cache_response</a>(<span class="keyword">const</span> string &amp;url, time_t request_time,
01737               <span class="keyword">const</span> vector&lt;string&gt; &amp;headers, <span class="keyword">const</span> FILE *body) 
01738     <span class="keywordflow">throw</span>(<a class="code" href="classError.html">Error</a>, InternalErr)
01739 {
01740     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Locking interface... "</span>);
01741     <a class="code" href="HTTPCache_8cc.html#a0">LOCK</a>(&amp;d_cache_mutex);
01742 
01743     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Caching url: "</span> &lt;&lt; url &lt;&lt; <span class="stringliteral">"."</span> &lt;&lt; endl);
01744 
01745     <span class="keywordflow">try</span> {
01746     <span class="comment">// If this is not an http or https URL, don't cache.</span>
01747     <span class="keywordflow">if</span> (url.find(<span class="stringliteral">"http:"</span>) == string::npos &amp;&amp;
01748         url.find(<span class="stringliteral">"https:"</span>) == string::npos) {
01749         <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
01750         <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
01751         <span class="keywordflow">return</span> <span class="keyword">false</span>;
01752     }
01753 
01754     <span class="comment">// This does nothing if url is not already in the cache. It's</span>
01755     <span class="comment">// more efficient to do this than to first check and see if the entry</span>
01756     <span class="comment">// exists. 10/10/02 jhrg</span>
01757     remove_entry_from_cache_table(url);
01758     
01759     <a class="code" href="structHTTPCache_1_1CacheEntry.html">CacheEntry</a> *entry = <span class="keyword">new</span> <a class="code" href="structHTTPCache_1_1CacheEntry.html">CacheEntry</a>;
01760 
01761     <a class="code" href="HTTPCache_8cc.html#a3">INIT</a>(&amp;entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo18">lock</a>);
01762     entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo0">url</a> = url;
01763     entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo1">hash</a> = get_hash(url);
01764     entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo2">hits</a> = 0;
01765 
01766     <span class="keywordflow">try</span> {   
01767         parse_headers(entry, headers); <span class="comment">// etag, lm, date, age, expires, max_age.</span>
01768         <span class="keywordflow">if</span> (entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo16">no_cache</a>) {
01769         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Not cache-able; deleting CacheEntry: "</span> &lt;&lt; entry 
01770             &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; url &lt;&lt; <span class="stringliteral">")"</span> &lt;&lt; endl);
01771         <span class="keyword">delete</span> entry;
01772         <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
01773         <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
01774         <span class="keywordflow">return</span> <span class="keyword">false</span>;
01775         }
01776 
01777         <span class="comment">// corrected_initial_age, freshness_lifetime, response_time.</span>
01778         calculate_time(entry, request_time); 
01779 
01780         create_location(entry); <span class="comment">// cachename, cache_body_fd</span>
01781         entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo10">size</a> = write_body(entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo3">cachename</a>, body);
01782 
01783         write_metadata(entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo3">cachename</a>, headers);
01784     }
01785     <span class="keywordflow">catch</span> (<a class="code" href="classResponseTooBigErr.html">ResponseTooBigErr</a> &amp;e) {
01786         <span class="comment">// Oops. Bummer. Clean up and exit.</span>
01787         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; e.get_error_message() &lt;&lt; endl);
01788         <a class="code" href="HTTPCache_8cc.html#a6">REMOVE</a>(entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo3">cachename</a>.c_str());
01789         <a class="code" href="HTTPCache_8cc.html#a6">REMOVE</a>(string(entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo3">cachename</a> + <a class="code" href="HTTPCache_8cc.html#a14">CACHE_META</a>).c_str());
01790         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Too big; deleting CacheEntry: "</span> &lt;&lt; entry &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; url 
01791         &lt;&lt; <span class="stringliteral">")"</span> &lt;&lt; endl);
01792         <span class="keyword">delete</span> entry;
01793         <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
01794         <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
01795         <span class="keywordflow">return</span> <span class="keyword">false</span>;
01796     }
01797 
01798     entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo11">range</a> = <span class="keyword">false</span>;   <span class="comment">// not used. 10/02/02 jhrg</span>
01799 
01800     add_entry_to_cache_table(entry);
01801 
01802     <span class="keywordflow">if</span> (++d_new_entries &gt; <a class="code" href="HTTPCache_8cc.html#a19">DUMP_FREQUENCY</a>) {
01803         <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex); <span class="comment">// unlock because cache_index_write() locks</span>
01804         <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
01805 
01806         <span class="keywordflow">if</span> (startGC())
01807         perform_garbage_collection();
01808 
01809         cache_index_write(); <span class="comment">// resets d_new_entries</span>
01810 
01811         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Locking interface... "</span>);
01812         <a class="code" href="HTTPCache_8cc.html#a0">LOCK</a>(&amp;d_cache_mutex);
01813     }
01814     }
01815     <span class="keywordflow">catch</span> (Error &amp;e) {
01816     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
01817     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
01818     <span class="keywordflow">throw</span> e;
01819     }
01820 
01821     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
01822     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
01823 
01824     <span class="keywordflow">return</span> <span class="keyword">true</span>;
01825 }
01826 
01845 vector&lt;string&gt;
<a name="l01846"></a><a class="code" href="classHTTPCache.html#HTTPCachea2">01846</a> <a class="code" href="classHTTPCache.html#HTTPCachea2">HTTPCache::get_conditional_request_headers</a>(<span class="keyword">const</span> string &amp;url) 
01847     <span class="keywordflow">throw</span>(Error)
01848 {
01849     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Locking interface... "</span>);
01850     <a class="code" href="HTTPCache_8cc.html#a0">LOCK</a>(&amp;d_cache_mutex);
01851     <a class="code" href="structHTTPCache_1_1CacheEntry.html">CacheEntry</a> *entry;
01852     vector&lt;string&gt; headers;
01853 
01854     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Getting conditional request headers for "</span> &lt;&lt; url &lt;&lt; endl);
01855 
01856     <span class="keywordflow">try</span> {
01857     entry = get_entry_from_cache_table(url);
01858     <span class="keywordflow">if</span> (!entry) {
01859         <span class="keywordflow">throw</span> Error(<span class="stringliteral">"There is no cache entry for the URL: "</span> + url);
01860     }
01861 
01862     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Locking entry... "</span>);
01863     <a class="code" href="HTTPCache_8cc.html#a0">LOCK</a>(&amp;entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo18">lock</a>);
01864 
01865     <span class="keywordflow">if</span> (entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo4">etag</a> != <span class="stringliteral">""</span>)
01866         headers.push_back(string(<span class="stringliteral">"If-None-Match: "</span>) + entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo4">etag</a>);
01867 
01868     <span class="keywordflow">if</span> (entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo5">lm</a> &gt; 0)
01869         headers.push_back(string(<span class="stringliteral">"If-Modified-Since: "</span>) 
01870                   + <a class="code" href="util__mit_8cc.html#a7">date_time_str</a>(&amp;entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo5">lm</a>));
01871     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo9">max_age</a> &gt; 0)
01872         headers.push_back(string(<span class="stringliteral">"If-Modified-Since: "</span>)
01873                   + <a class="code" href="util__mit_8cc.html#a7">date_time_str</a>(&amp;entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo9">max_age</a>));
01874     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo6">expires</a> &gt; 0)
01875         headers.push_back(string(<span class="stringliteral">"If-Modified-Since: "</span>)
01876                   + <a class="code" href="util__mit_8cc.html#a7">date_time_str</a>(&amp;entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo6">expires</a>));
01877     }
01878     <span class="keywordflow">catch</span> (Error &amp;e) {
01879     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
01880     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
01881     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo18">lock</a>);
01882     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking entry."</span> &lt;&lt; endl);
01883     <span class="keywordflow">throw</span> e;
01884     }
01885 
01886     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo18">lock</a>);
01887     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking entry"</span> &lt;&lt; endl);
01888     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
01889     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
01890 
01891     <span class="keywordflow">return</span> headers;
01892 }
01893 
01897 <span class="keyword">struct </span>HeaderLess: binary_function&lt;const string&amp;, const string&amp;, bool&gt; {
01898     <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp;s2)<span class="keyword"> const </span>{
01899     <span class="keywordflow">return</span> s1.substr(0, s1.find(<span class="charliteral">':'</span>)) &lt; s2.substr(0, s2.find(<span class="charliteral">':'</span>));
01900     }
01901 };
01902 
01916 <span class="keywordtype">void</span>
<a name="l01917"></a><a class="code" href="classHTTPCache.html#HTTPCachea3">01917</a> <a class="code" href="classHTTPCache.html#HTTPCachea3">HTTPCache::update_response</a>(<span class="keyword">const</span> string &amp;url, time_t request_time,
01918                <span class="keyword">const</span> vector&lt;string&gt; &amp;headers) <span class="keywordflow">throw</span>(Error)
01919 {
01920     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Locking interface... "</span>);
01921     <a class="code" href="HTTPCache_8cc.html#a0">LOCK</a>(&amp;d_cache_mutex);
01922     <a class="code" href="structHTTPCache_1_1CacheEntry.html">CacheEntry</a> *entry;
01923 
01924     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Updating the response headers for: "</span> &lt;&lt; url &lt;&lt; endl);
01925 
01926     <span class="keywordflow">try</span> {
01927     entry = get_entry_from_cache_table(url);
01928     <span class="keywordflow">if</span> (!entry)
01929         <span class="keywordflow">throw</span> Error(<span class="stringliteral">"There is no cache entry for the URL: "</span> + url);
01930 
01931     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Locking entry... "</span>);
01932     <a class="code" href="HTTPCache_8cc.html#a0">LOCK</a>(&amp;entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo18">lock</a>);
01933 
01934     <span class="comment">// Merge the new headers with the exiting CacheEntry object.</span>
01935     parse_headers(entry, headers);
01936 
01937     <span class="comment">// Update corrected_initial_age, freshness_lifetime, response_time.</span>
01938     calculate_time(entry, request_time); 
01939 
01940     <span class="comment">// Merge the new headers with those in the persistent store. How:</span>
01941     <span class="comment">// Load the new headers into a set, then merge the old headers. Since</span>
01942     <span class="comment">// set&lt;&gt; ignores duplicates, old headers with the same name as a new</span>
01943     <span class="comment">// header will got into the bit bucket. Define a special compare</span>
01944     <span class="comment">// functor to make sure that headers are compared using only their</span>
01945     <span class="comment">// name and not their value too.</span>
01946     set&lt;string, HeaderLess&gt; merged_headers;
01947 
01948     <span class="comment">// Load in the new headers</span>
01949     copy(headers.begin(), headers.end(), 
01950          inserter(merged_headers, merged_headers.begin()));
01951 
01952     <span class="comment">// Get the old headers and load them in.</span>
01953     vector&lt;string&gt; old_headers;
01954     read_metadata(entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo3">cachename</a>, old_headers);
01955     copy(old_headers.begin(), old_headers.end(), 
01956          inserter(merged_headers, merged_headers.begin()));
01957 
01958     <span class="comment">// Read the values back out. Use reverse iterators with back_inserter</span>
01959     <span class="comment">// to preserve header order. NB: vector&lt;&gt; does not support push_front</span>
01960     <span class="comment">// so we can't use front_inserter(). 01/09/03 jhrg</span>
01961     vector&lt;string&gt; result;
01962     copy(merged_headers.rbegin(), merged_headers.rend(), 
01963          back_inserter(result));
01964 
01965     <span class="comment">// Store.</span>
01966     write_metadata(entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo3">cachename</a>, result);
01967     }
01968     <span class="keywordflow">catch</span> (Error &amp;e) {
01969     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo18">lock</a>);
01970     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking entry."</span> &lt;&lt; endl);
01971     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
01972     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
01973     <span class="keywordflow">throw</span> e;
01974     }
01975 
01976     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo18">lock</a>);
01977     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking entry"</span> &lt;&lt; endl);
01978     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
01979     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
01980 }
01981 
01993 <span class="keywordtype">bool</span>
<a name="l01994"></a><a class="code" href="classHTTPCache.html#HTTPCachea5">01994</a> <a class="code" href="classHTTPCache.html#HTTPCachea5">HTTPCache::is_url_valid</a>(<span class="keyword">const</span> string &amp;url) <span class="keywordflow">throw</span>(Error)
01995 {
01996     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Locking interface... "</span>);
01997     <a class="code" href="HTTPCache_8cc.html#a0">LOCK</a>(&amp;d_cache_mutex);
01998     <span class="keywordtype">bool</span> freshness;
01999     <a class="code" href="structHTTPCache_1_1CacheEntry.html">CacheEntry</a> *entry = 0;
02000 
02001     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Is this URL valid? ("</span> &lt;&lt; url &lt;&lt; <span class="stringliteral">")"</span> &lt;&lt; endl);
02002 
02003     <span class="keywordflow">try</span> {
02004     <span class="keywordflow">if</span> (d_always_validate) {
02005         <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
02006         <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
02007         <span class="keywordflow">return</span> <span class="keyword">false</span>;       <span class="comment">// force re-validation.</span>
02008     }
02009 
02010     entry = get_entry_from_cache_table(url);
02011     <span class="keywordflow">if</span> (!entry) {
02012         <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
02013         <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
02014         <span class="keywordflow">throw</span> Error(<span class="stringliteral">"There is no cache entry for the URL: "</span> + url);
02015     }
02016 
02017     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Locking entry... "</span>);
02018     <a class="code" href="HTTPCache_8cc.html#a0">LOCK</a>(&amp;entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo18">lock</a>);
02019 
02020     <span class="comment">// If we supported range requests, we'd need code here to check if</span>
02021     <span class="comment">// there was only a partial response in the cache. 10/02/02 jhrg</span>
02022 
02023     <span class="comment">// In case this entry is of type "must-revalidate" then we consider it</span>
02024     <span class="comment">// invalid. </span>
02025     <span class="keywordflow">if</span> (entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo15">must_revalidate</a>) {
02026         <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo18">lock</a>);
02027         <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking entry"</span> &lt;&lt; endl);
02028         <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
02029         <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
02030         <span class="keywordflow">return</span> <span class="keyword">false</span>;
02031     }
02032 
02033     time_t resident_time = time(NULL) - entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo13">response_time</a>;
02034     time_t current_age = entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo14">corrected_initial_age</a> + resident_time;
02035 
02036     <span class="comment">// Check that the max-age, max-stale, and min-fresh directives</span>
02037     <span class="comment">// given in the request cache control header is followed.</span>
02038     <span class="keywordflow">if</span> (d_max_age &gt;= 0 &amp;&amp; current_age &gt; d_max_age) {
02039         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Cache....... Max-age validation"</span> &lt;&lt; endl);
02040         <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo18">lock</a>);
02041         <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking entry"</span> &lt;&lt; endl);
02042         <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
02043         <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
02044         <span class="keywordflow">return</span> <span class="keyword">false</span>;
02045     }
02046     <span class="keywordflow">if</span> (d_min_fresh &gt;= 0
02047         &amp;&amp; entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo12">freshness_lifetime</a> &lt; current_age + d_min_fresh) {
02048         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Cache....... Min-fresh validation"</span> &lt;&lt; endl);
02049         <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo18">lock</a>);
02050         <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking entry"</span> &lt;&lt; endl);
02051         <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
02052         <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
02053         <span class="keywordflow">return</span> <span class="keyword">false</span>;
02054     }
02055 
02056     freshness = (entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo12">freshness_lifetime</a> 
02057              + (d_max_stale &gt;= 0 ? d_max_stale : 0) &gt; current_age);
02058     }
02059     <span class="keywordflow">catch</span> (Error &amp;e) {
02060     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo18">lock</a>);
02061     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking entry."</span> &lt;&lt; endl);
02062     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
02063     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
02064     <span class="keywordflow">throw</span> e;
02065     }
02066 
02067     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo18">lock</a>);
02068     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking entry"</span> &lt;&lt; endl);
02069     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
02070     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
02071 
02072     <span class="keywordflow">return</span> freshness;
02073 }
02074 
02100 FILE *
<a name="l02101"></a><a class="code" href="classHTTPCache.html#HTTPCachea6">02101</a> <a class="code" href="classHTTPCache.html#HTTPCachea6">HTTPCache::get_cached_response</a>(<span class="keyword">const</span> string &amp;url, vector&lt;string&gt; &amp;headers)
02102     <span class="keywordflow">throw</span>(Error, InternalErr)
02103 {
02104     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Locking interface... "</span>);
02105     <a class="code" href="HTTPCache_8cc.html#a0">LOCK</a>(&amp;d_cache_mutex);
02106     FILE *body;
02107     <a class="code" href="structHTTPCache_1_1CacheEntry.html">CacheEntry</a> *entry;
02108 
02109     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Getting the cached response for "</span> &lt;&lt; url &lt;&lt; endl);
02110 
02111     <span class="keywordflow">try</span> {
02112     entry = get_entry_from_cache_table(url);
02113     <span class="keywordflow">if</span> (!entry)
02114         <span class="keywordflow">throw</span> Error(<span class="stringliteral">"There is no cache entry for the URL: "</span> + url);
02115 
02116     read_metadata(entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo3">cachename</a>, headers);
02117     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Headers just read from cache: "</span> &lt;&lt; endl);
02118     <a class="code" href="debug_8h.html#a2">DBGN</a>(copy(headers.begin(), headers.end(), ostream_iterator&lt;string&gt;(cerr, <span class="stringliteral">"\n"</span>)));
02119     
02120     body = open_body(entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo3">cachename</a>);
02121 
02122     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Returning: "</span> &lt;&lt; url &lt;&lt; <span class="stringliteral">" from the cache."</span> &lt;&lt; endl);
02123 
02124     entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo2">hits</a>++;      <span class="comment">// Mark hit</span>
02125     entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo17">locked</a>++;    <span class="comment">// lock entry</span>
02126     d_locked_entries[body] = entry; <span class="comment">// record lock, see release_cached_r...</span>
02127     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Locking entry (non-blocking lock)... "</span>);
02128     <a class="code" href="HTTPCache_8cc.html#a1">TRYLOCK</a>(&amp;entry-&gt;lock);  <span class="comment">// Needed for blocking lock; locked counts</span>
02129     }
02130     <span class="keywordflow">catch</span> (Error &amp;e) {
02131     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo18">lock</a>);
02132     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking entry."</span> &lt;&lt; endl);
02133     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
02134     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
02135     <span class="keywordflow">throw</span> e;
02136     }
02137 
02138     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
02139     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
02140 
02141     <span class="keywordflow">return</span> body;
02142 }
02143 
02164 FILE *
<a name="l02165"></a><a class="code" href="classHTTPCache.html#HTTPCachea7">02165</a> <a class="code" href="classHTTPCache.html#HTTPCachea7">HTTPCache::get_cached_response_body</a>(<span class="keyword">const</span> string &amp;url) 
02166     <span class="keywordflow">throw</span>(Error, InternalErr)
02167 {
02168     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Locking interface... "</span>);
02169     <a class="code" href="HTTPCache_8cc.html#a0">LOCK</a>(&amp;d_cache_mutex);
02170     FILE *body;
02171     <a class="code" href="structHTTPCache_1_1CacheEntry.html">CacheEntry</a> *entry;
02172 
02173     <span class="keywordflow">try</span> {
02174     entry = get_entry_from_cache_table(url);
02175 
02176     <span class="keywordflow">if</span> (!entry) {
02177         <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
02178         <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
02179         <span class="keywordflow">throw</span> Error(<span class="stringliteral">"There is no cache entry for the URL: "</span> + url);
02180     }
02181 
02182     body = open_body(entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo3">cachename</a>); <span class="comment">// throws InternalErr</span>
02183 
02184     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Returning body for: "</span> &lt;&lt; url &lt;&lt; <span class="stringliteral">" from the cache."</span> 
02185         &lt;&lt; endl);
02186 
02187     entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo2">hits</a>++;      <span class="comment">// Mark hit</span>
02188     entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo17">locked</a>++;        <span class="comment">// lock entry</span>
02189     d_locked_entries[body] = entry; <span class="comment">// record lock, see release_cached_r...</span>
02190     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Locking entry (non-blocking lock)... "</span>);
02191     <a class="code" href="HTTPCache_8cc.html#a1">TRYLOCK</a>(&amp;entry-&gt;lock);
02192     }
02193     <span class="keywordflow">catch</span> (Error &amp;e) {
02194     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo18">lock</a>);
02195     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking entry."</span> &lt;&lt; endl);
02196     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
02197     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
02198     <span class="keywordflow">throw</span> e;
02199     }
02200 
02201     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
02202     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
02203 
02204     <span class="keywordflow">return</span> body;
02205 }
02206 
02219 <span class="keywordtype">void</span>
<a name="l02220"></a><a class="code" href="classHTTPCache.html#HTTPCachea8">02220</a> <a class="code" href="classHTTPCache.html#HTTPCachea8">HTTPCache::release_cached_response</a>(FILE *body) <span class="keywordflow">throw</span>(Error)
02221 {
02222     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Locking interface... "</span>);
02223     <a class="code" href="HTTPCache_8cc.html#a0">LOCK</a>(&amp;d_cache_mutex);
02224     <a class="code" href="structHTTPCache_1_1CacheEntry.html">CacheEntry</a> *entry;
02225 
02226     <span class="keywordflow">try</span> {
02227     entry = d_locked_entries[body];
02228     <span class="keywordflow">if</span> (!entry)
02229         <span class="keywordflow">throw</span> Error(<span class="stringliteral">"There is no cache entry for the response given."</span>);
02230 
02231     entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo17">locked</a>--;
02232     <span class="keywordflow">if</span> (entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo17">locked</a> == 0) {
02233         d_locked_entries.erase(body);
02234         <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo18">lock</a>);
02235         <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking entry "</span> &lt;&lt; hex &lt;&lt; entry &lt;&lt; dec &lt;&lt; endl);
02236     }
02237 
02238     <span class="keywordflow">if</span> (entry-&gt;<a class="code" href="structHTTPCache_1_1CacheEntry.html#HTTPCache_1_1CacheEntryo17">locked</a> &lt; 0)
02239         <span class="keywordflow">throw</span> Error(<span class="stringliteral">"An unlocked entry was released"</span>);
02240     }
02241     <span class="keywordflow">catch</span> (Error &amp;e) {
02242     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
02243     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
02244     <span class="keywordflow">throw</span> e;
02245     }
02246 
02247     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
02248     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
02249 }
02250 
02253 <span class="keyword">class </span>DeleteUnlockedCacheEntry :
02254     <span class="keyword">public</span> unary_function&lt;HTTPCache::CacheEntry *&amp;, void&gt; {
02255     
02256     <a class="code" href="classHTTPCache.html">HTTPCache</a> *d_cache;
02257 
02258 <span class="keyword">public</span>:
02259     DeleteUnlockedCacheEntry(<a class="code" href="classHTTPCache.html">HTTPCache</a> *c) : d_cache(c) {}
02260     <span class="keywordtype">void</span> operator()(<a class="code" href="structHTTPCache_1_1CacheEntry.html">HTTPCache::CacheEntry</a> *&amp;e) {
02261     <span class="keywordflow">if</span> (e) {
02262         d_cache-&gt;remove_cache_entry(e);
02263         e = 0;
02264     }
02265     }
02266 };
02267 
02280 <span class="keywordtype">void</span>
<a name="l02281"></a><a class="code" href="classHTTPCache.html#HTTPCachea9">02281</a> <a class="code" href="classHTTPCache.html#HTTPCachea9">HTTPCache::purge_cache</a>() <span class="keywordflow">throw</span>(Error)
02282 {
02283     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Locking interface... "</span>);
02284     <a class="code" href="HTTPCache_8cc.html#a0">LOCK</a>(&amp;d_cache_mutex);
02285     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Purging the cache."</span> &lt;&lt; endl);
02286     
02287     <span class="keywordflow">try</span> {
02288     <span class="keywordflow">if</span> (!d_locked_entries.empty()) {
02289         <span class="keywordflow">throw</span> Error(<span class="stringliteral">"Attempt to purge the cache with entries in use."</span>);
02290     }
02291 
02292     <span class="comment">// Walk through the cache table and, for every entry in the cache, delete</span>
02293     <span class="comment">// it on disk and in the cache table.</span>
02294     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cnt = 0; cnt &lt; <a class="code" href="HTTPCache_8h.html#a0">CACHE_TABLE_SIZE</a>; cnt++) {
02295         CachePointers *slot = d_cache_table[cnt];
02296         <span class="keywordflow">if</span> (slot) { 
02297         for_each(slot-&gt;begin(), slot-&gt;end(),
02298              DeleteUnlockedCacheEntry(<span class="keyword">this</span>));
02299         slot-&gt;erase(remove(slot-&gt;begin(), slot-&gt;end(),
02300                    static_cast&lt;CacheEntry *&gt;(0)),
02301                 slot-&gt;end());
02302         }
02303     }
02304 
02305     <span class="comment">// Now delete the index itself.</span>
02306     cache_index_delete();
02307     }
02308     <span class="keywordflow">catch</span> (Error &amp;e) {
02309     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
02310     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
02311     <span class="keywordflow">throw</span> e;
02312     }
02313 
02314     <a class="code" href="HTTPCache_8cc.html#a2">UNLOCK</a>(&amp;d_cache_mutex);
02315     <a class="code" href="debug_8h.html#a2">DBGN</a>(cerr &lt;&lt; <span class="stringliteral">"Unlocking interface."</span> &lt;&lt; endl);
02316 }
02317 
02318 <span class="comment">// $Log: HTTPCache_8cc-source.html,v $
02318 <span class="comment">// Revision 1.4  2004/02/05 06:51:16  jimg
02318 <span class="comment">// Added/update.
02318 <span class="comment">//</span>
02319 <span class="comment">// Revision 1.11.2.8  2004/02/04 00:05:11  jimg</span>
02320 <span class="comment">// Memory errors: I've fixed a number of memory errors (leaks, references)</span>
02321 <span class="comment">// found using valgrind. Many remain. I need to come up with a systematic</span>
02322 <span class="comment">// way of running the tests under valgrind.</span>
02323 <span class="comment">//</span>
02324 <span class="comment">// Revision 1.11.2.7  2004/01/26 16:45:26  jimg</span>
02325 <span class="comment">// Removed DODS_DEBUG and DODS_DEBUG2 defines and fixed an odd comment. When</span>
02326 <span class="comment">// using tkcvs, be very careful to insert newlines in the log text!</span>
02327 <span class="comment">//</span>
02328 <span class="comment">// Revision 1.11.2.6  2004/01/23 22:06:32  jimg</span>
02329 <span class="comment">// Fixed some comments after testing. I also changed they way</span>
02330 <span class="comment">// cache_write_index() is called when perform_garbage_collection() is called</span>
02331 <span class="comment">// inside set_cache_size() and set_max_entry_size(). Before the index was</span>
02332 <span class="comment">// always written. Now it's only written if GC is done.</span>
02333 <span class="comment">//</span>
02334 <span class="comment">// Revision 1.11.2.5  2004/01/22 20:47:23  jimg</span>
02335 <span class="comment">// Fix for bug 689. I added tests to make sure the cache size doesn't wind</span>
02336 <span class="comment">// up being set to a negative number. I also changed the types of the cache</span>
02337 <span class="comment">// size and entry size from int to unsigned long. Added information to</span>
02338 <span class="comment">// the default .dodsrc file explaining the units of the CACHE_SIZE and</span>
02339 <span class="comment">// MAX_ENTRY_SIZE parameters.</span>
02340 <span class="comment">//</span>
02341 <span class="comment">// Revision 1.11.2.4  2003/10/10 23:07:15  jimg</span>
02342 <span class="comment">// Added some instrumentation which helped track down bug 672.</span>
02343 <span class="comment">//</span>
02344 <span class="comment">// Revision 1.11.2.3  2003/09/18 19:27:29  jimg</span>
02345 <span class="comment">// Fixed part of bug #665. When .dods_cache did not exist the code was not able</span>
02346 <span class="comment">// to get the single user lock for the cache. Since the call to _create_ the</span>
02347 <span class="comment">// cache (.dods_cache) was called only if we had the single user lock, ... I</span>
02348 <span class="comment">// fixed this by moving the call to create the cache root directory into the</span>
02349 <span class="comment">// call to get the single user lock. Also, I made the bool d_cache_enabled false</span>
02350 <span class="comment">// by default and true only when the single user lock and cache index have been</span>
02351 <span class="comment">// read.</span>
02352 <span class="comment">//</span>
02353 <span class="comment">// Revision 1.11.2.2  2003/09/08 18:48:29  jimg</span>
02354 <span class="comment">// I fixed bug #661. The cache was trying to grab the single user lock before</span>
02355 <span class="comment">// setting the cache root. This worked OK when the process could write to the</span>
02356 <span class="comment">// CWD (because get_single_user_lock defaults the cache_root to the CWD when</span>
02357 <span class="comment">// the cache_root is not set). However, when the process cannot write to the CWD</span>
02358 <span class="comment">// the cache cannot get the lock. This meant that we were left with a non-null</span>
02359 <span class="comment">// HTTPCache instance which had a bogus cache root.</span>
02360 <span class="comment">//</span>
02361 <span class="comment">// Revision 1.11.2.1  2003/09/06 22:35:38  jimg</span>
02362 <span class="comment">// Updated the documentation. HTTPCache::~HTTPCache() no longer grabs the class'</span>
02363 <span class="comment">// interface lock. That is unnecessary since the dtor is only called by atexit().</span>
02364 <span class="comment">//</span>
02365 <span class="comment">// Revision 1.11  2003/05/02 00:02:38  jimg</span>
02366 <span class="comment">// Modified the code so that perform_garbage_collection() is called only when</span>
02367 <span class="comment">// startGC() is true. This should minimize the time spent scanning the entry</span>
02368 <span class="comment">// entry table.</span>
02369 <span class="comment">//</span>
02370 <span class="comment">// Revision 1.10  2003/05/01 23:06:29  jimg</span>
02371 <span class="comment">// Fixed another class interface lock bug. It would be better to lock class</span>
02372 <span class="comment">// resources (fields) and name them so that it was obvious which were locked and</span>
02373 <span class="comment">// by what mutex. Also, made sure garbage collection happens every time the</span>
02374 <span class="comment">// index file is written out.</span>
02375 <span class="comment">//</span>
02376 <span class="comment">// Revision 1.9  2003/04/23 21:33:53  jimg</span>
02377 <span class="comment">// Changes for the unit tests. This involved merging Rob's VC++ changes</span>
02378 <span class="comment">// and fixing a bug in escaping.cc (a call to string::insert invalidated</span>
02379 <span class="comment">// an iterator in a loop).</span>
02380 <span class="comment">//</span>
02381 <span class="comment">// Revision 1.8  2003/04/22 19:40:27  jimg</span>
02382 <span class="comment">// Merged with 3.3.1.</span>
02383 <span class="comment">//</span>
02384 <span class="comment">// Revision 1.7  2003/03/13 23:55:57  jimg</span>
02385 <span class="comment">// Significant changes regarding the mutex code. I found out that since</span>
02386 <span class="comment">// config_dap.h was not being included, the mutex code was never built! Once</span>
02387 <span class="comment">// built, I found a bunch of deadlocks. Many of the methods had to be modified</span>
02388 <span class="comment">// to fix this/these problem(s).</span>
02389 <span class="comment">//</span>
02390 <span class="comment">// Revision 1.6  2003/03/04 21:43:11  jimg</span>
02391 <span class="comment">// Minor change; changed the order of inline and static for the get_hash()</span>
02392 <span class="comment">// function.</span>
02393 <span class="comment">//</span>
02394 <span class="comment">// Revision 1.5  2003/03/04 17:31:17  jimg</span>
02395 <span class="comment">// Modified cache_response() so that only http and https URLs are cached.</span>
02396 <span class="comment">//</span>
02397 <span class="comment">// Revision 1.4  2003/02/21 00:14:24  jimg</span>
02398 <span class="comment">// Repaired copyright.</span>
02399 <span class="comment">//</span>
02400 <span class="comment">// Revision 1.3.2.1  2003/02/21 00:10:07  jimg</span>
02401 <span class="comment">// Repaired copyright.</span>
02402 <span class="comment">//</span>
02403 <span class="comment">// Revision 1.3  2003/01/23 00:22:24  jimg</span>
02404 <span class="comment">// Updated the copyright notice; this implementation of the DAP is</span>
02405 <span class="comment">// copyrighted by OPeNDAP, Inc.</span>
02406 <span class="comment">//</span>
02407 <span class="comment">// Revision 1.2  2003/01/10 19:46:40  jimg</span>
02408 <span class="comment">// Merged with code tagged release-3-2-10 on the release-3-2 branch. In many</span>
02409 <span class="comment">// cases files were added on that branch (so they appear on the trunk for</span>
02410 <span class="comment">// the first time).</span>
02411 <span class="comment">//</span>
02412 <span class="comment">// Revision 1.1.2.13  2002/12/29 23:03:48  jimg</span>
02413 <span class="comment">// Updated the copyrights for these source files.</span>
02414 <span class="comment">//</span>
02415 <span class="comment">// Revision 1.1.2.12  2002/12/27 00:58:48  jimg</span>
02416 <span class="comment">// Removed some dubious code Rob found. Fixed some comments.</span>
02417 <span class="comment">//</span>
02418 <span class="comment">// Revision 1.1.2.11  2002/12/01 12:49:07  rmorris</span>
02419 <span class="comment">// Bug fixes related to win32 port - numerous related to caching.</span>
02420 <span class="comment">//</span>
02421 <span class="comment">// Revision 1.1.2.10  2002/11/21 21:24:17  pwest</span>
02422 <span class="comment">// memory leak cleanup and file descriptor cleanup</span>
02423 <span class="comment">//</span>
02424 <span class="comment">// Revision 1.1.2.9  2002/11/04 07:26:13  rmorris</span>
02425 <span class="comment">// Finish Porting this new code to win32.</span>
02426 <span class="comment">//</span>
02427 <span class="comment">// Revision 1.1.2.8  2002/10/18 22:43:33  jimg</span>
02428 <span class="comment">// Added methods for the always_validate property. This can be set in the</span>
02429 <span class="comment">// .dodsrc file (see RCReader) so we should support it here. The class respects</span>
02430 <span class="comment">// the value of this property (it's different than CacheEntry::always_validate;</span>
02431 <span class="comment">// that says *that* particular entry should always be validated and its value</span>
02432 <span class="comment">// comes from a Cache_control header in the response). The</span>
02433 <span class="comment">// HTTPCache::always_validate property says *every* entry should always be</span>
02434 <span class="comment">// validated.</span>
02435 <span class="comment">//</span>
02436 <span class="comment">// Revision 1.1.2.7  2002/10/18 00:10:38  jimg</span>
02437 <span class="comment">// MT-safety for entries; I used a mutex to lock an entry so that it won't be</span>
02438 <span class="comment">// modified by one thread while another is using it. Fixed up the documentation.</span>
02439 <span class="comment">//</span>
02440 <span class="comment">// Revision 1.1.2.6  2002/10/11 20:57:36  jimg</span>
02441 <span class="comment">// Fixed up the documentation.</span>
02442 <span class="comment">// Added a test to ensure that hop-by-hop headers are not stored in the cache.</span>
02443 <span class="comment">//</span>
02444 <span class="comment">// Revision 1.1.2.5  2002/10/11 00:20:19  jimg</span>
02445 <span class="comment">// Added methods for conditional responses.</span>
02446 <span class="comment">//</span>
02447 <span class="comment">// Revision 1.1.2.4  2002/10/10 06:46:30  jimg</span>
02448 <span class="comment">// The class is now MT-safe.</span>
02449 <span class="comment">//</span>
02450 <span class="comment">// Revision 1.1.2.3  2002/10/08 05:23:16  jimg</span>
02451 <span class="comment">// The Cache now works. Still to do: Make the cache MT-safe (which will</span>
02452 <span class="comment">// probably require that it become a singleton, but maybe not), protect</span>
02453 <span class="comment">// all non-const methods with a mutex and devise a locking strategy so that</span>
02454 <span class="comment">// entries are not read while being written. Once the cache is MT-safe, it</span>
02455 <span class="comment">// must be made to handle updates.</span>
02456 <span class="comment">//</span>
02457 <span class="comment">// Revision 1.1.2.2  2002/09/17 00:18:49  jimg</span>
02458 <span class="comment">// Added methods to manage the single user lock and to get/set the cache root</span>
02459 <span class="comment">// directory. Also fixed a build problem; I appear to have the sstream headers</span>
02460 <span class="comment">// and classes on my machine but other (most?) gcc 2.95.x installations lack</span>
02461 <span class="comment">// them. I switched from sstream to strstream.</span>
02462 <span class="comment">//</span>
02463 <span class="comment">// Revision 1.1.2.1  2002/09/12 22:39:35  jimg</span>
02464 <span class="comment">// Initial version.</span>
02465 <span class="comment">//</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Feb 4 23:43:01 2004 for libdap++ by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
