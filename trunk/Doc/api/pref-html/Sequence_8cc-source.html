<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libdap++: Sequence.cc Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Sequence.cc</h1><a href="Sequence_8cc.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00002 <span class="comment">// -*- mode: c++; c-basic-offset:4 -*-</span>
00003 
00004 <span class="comment">// This file is part of libdap, A C++ implementation of the OPeNDAP Data</span>
00005 <span class="comment">// Access Protocol.</span>
00006 
00007 <span class="comment">// Copyright (c) 2002,2003 OPeNDAP, Inc.</span>
00008 <span class="comment">// Author: James Gallagher &lt;jgallagher@opendap.org&gt;</span>
00009 <span class="comment">//</span>
00010 <span class="comment">// This library is free software; you can redistribute it and/or</span>
00011 <span class="comment">// modify it under the terms of the GNU Lesser General Public</span>
00012 <span class="comment">// License as published by the Free Software Foundation; either</span>
00013 <span class="comment">// version 2.1 of the License, or (at your option) any later version.</span>
00014 <span class="comment">// </span>
00015 <span class="comment">// This library is distributed in the hope that it will be useful,</span>
00016 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00017 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00018 <span class="comment">// Lesser General Public License for more details.</span>
00019 <span class="comment">// </span>
00020 <span class="comment">// You should have received a copy of the GNU Lesser General Public</span>
00021 <span class="comment">// License along with this library; if not, write to the Free Software</span>
00022 <span class="comment">// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00023 <span class="comment">//</span>
00024 <span class="comment">// You can contact OPeNDAP, Inc. at PO Box 112, Saunderstown, RI. 02874-0112.</span>
00025  
00026 <span class="comment">// (c) COPYRIGHT URI/MIT 1994-1999</span>
00027 <span class="comment">// Please read the full copyright statement in the file COPYRIGHT_URI.</span>
00028 <span class="comment">//</span>
00029 <span class="comment">// Authors:</span>
00030 <span class="comment">//      jhrg,jimg       James Gallagher &lt;jgallagher@gso.uri.edu&gt;</span>
00031 
00032 <span class="comment">// Implementation for the class Structure</span>
00033 <span class="comment">//</span>
00034 <span class="comment">// jhrg 9/14/94</span>
00035 
00036 <span class="preprocessor">#ifdef _GNUG_</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#pragma implementation</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00039 <span class="preprocessor"></span>
00040 <span class="preprocessor">#include "<a class="code" href="config__dap_8h.html">config_dap.h</a>"</span>
00041 
00042 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00043 <span class="preprocessor">#include &lt;string&gt;</span>
00044 <span class="preprocessor">#include &lt;sstream&gt;</span>
00045 
00046 <span class="comment">// #define DODS_DEBUG</span>
00047 
00048 <span class="preprocessor">#include "<a class="code" href="debug_8h.html">debug.h</a>"</span>
00049 <span class="preprocessor">#include "<a class="code" href="Error_8h.html">Error.h</a>"</span>
00050 <span class="preprocessor">#include "<a class="code" href="InternalErr_8h.html">InternalErr.h</a>"</span>
00051 <span class="preprocessor">#include "<a class="code" href="Sequence_8h.html">Sequence.h</a>"</span>
00052 <span class="preprocessor">#include "<a class="code" href="DDS_8h.html">DDS.h</a>"</span>
00053 <span class="preprocessor">#include "<a class="code" href="DataDDS_8h.html">DataDDS.h</a>"</span>
00054 <span class="preprocessor">#include "<a class="code" href="util_8h.html">util.h</a>"</span>
00055 <span class="preprocessor">#include "<a class="code" href="InternalErr_8h.html">InternalErr.h</a>"</span>
00056 <span class="preprocessor">#include "<a class="code" href="escaping_8h.html">escaping.h</a>"</span>
00057 <span class="preprocessor">#include "<a class="code" href="BTIterAdapter_8h.html">BTIterAdapter.h</a>"</span>
00058 
00059 <span class="preprocessor">#ifdef TRACE_NEW</span>
00060 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="trace__new_8h.html">trace_new.h</a>"</span>
00061 <span class="preprocessor">#endif</span>
00062 <span class="preprocessor"></span>
00063 <span class="keyword">using</span> std::cerr;
00064 <span class="keyword">using</span> std::endl;
00065 <span class="keyword">using</span> std::ends;
00066 <span class="keyword">using</span> std::ostringstream;
00067 <span class="keyword">using</span> std::for_each;
00068 
00069 <span class="preprocessor">#if defined(_MSC_VER) &amp;&amp; (_MSC_VER == 1200)  //  VC++ 6.0 only</span>
00070 <span class="preprocessor"></span><span class="keyword">using</span> std::vector&lt;BaseTypeRow *&gt;;
00071 <span class="preprocessor">#else</span>
00072 <span class="preprocessor"></span><span class="keyword">using</span> std::vector;
00073 <span class="preprocessor">#endif</span>
00074 <span class="preprocessor"></span>
00075 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> end_of_sequence = 0xA5; <span class="comment">// binary pattern 1010 0101</span>
00076 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> start_of_instance = 0x5A; <span class="comment">// binary pattern 0101 1010</span>
00077 
00078 <span class="comment">// Private member functions</span>
00079 
00080 <span class="keywordtype">void</span>
00081 <a class="code" href="classConstructor.html#Structureb0">Sequence::_duplicate</a>(<span class="keyword">const</span> <a class="code" href="classSequence.html">Sequence</a> &amp;s)
00082 {
00083     d_row_number = s.<a class="code" href="classSequence.html#Sequencer2">d_row_number</a>;
00084     d_starting_row_number = s.<a class="code" href="classSequence.html#Sequencer3">d_starting_row_number</a>;
00085     d_ending_row_number = s.<a class="code" href="classSequence.html#Sequencer5">d_ending_row_number</a>;
00086     d_row_stride = s.<a class="code" href="classSequence.html#Sequencer4">d_row_stride</a>;
00087 
00088     <a class="code" href="classSequence.html">Sequence</a> &amp;cs = const_cast&lt;Sequence &amp;&gt;(s);
00089     
00090     <span class="comment">// Copy the template BaseType objects.</span>
00091     <span class="keywordflow">for</span> (<a class="code" href="classSequence.html#Sequencew1">Vars_iter</a> i = cs.<a class="code" href="classSequence.html#Sequencea29">var_begin</a>(); i != cs.<a class="code" href="classSequence.html#Sequencea30">var_end</a>(); i++)
00092     {
00093     <a class="code" href="classSequence.html#Sequencea28">add_var</a>((*i)) ;
00094     }
00095 
00096     <span class="comment">// Copy the BaseType objects used to hold values.</span>
00097     <span class="keywordflow">for</span> (vector&lt;BaseTypeRow *&gt;::iterator rows_iter = cs.<a class="code" href="classSequence.html#Sequencer1">d_values</a>.begin();
00098      rows_iter != cs.<a class="code" href="classSequence.html#Sequencer1">d_values</a>.end();
00099      rows_iter++) {
00100     <span class="comment">// Get the current BaseType Row</span>
00101     <a class="code" href="Sequence_8h.html#a1">BaseTypeRow</a> *src_bt_row_ptr = *rows_iter;
00102     <span class="comment">// Create a new row.</span>
00103     <a class="code" href="Sequence_8h.html#a1">BaseTypeRow</a> *dest_bt_row_ptr = <span class="keyword">new</span> <a class="code" href="Sequence_8h.html#a1">BaseTypeRow</a>;
00104     <span class="comment">// Copy the BaseType objects from a row to new BaseType objects.</span>
00105     <span class="comment">// Push new BaseType objects onto new row.</span>
00106     <span class="keywordflow">for</span> (BaseTypeRow::iterator bt_row_iter = src_bt_row_ptr-&gt;begin();
00107          bt_row_iter != src_bt_row_ptr-&gt;end();
00108          bt_row_iter++) {
00109         <a class="code" href="classBaseType.html">BaseType</a> *src_bt_ptr = *bt_row_iter;
00110         <a class="code" href="classBaseType.html">BaseType</a> *dest_bt_ptr = src_bt_ptr-&gt;<a class="code" href="classBaseType.html#Constructora6">ptr_duplicate</a>();
00111         dest_bt_row_ptr-&gt;push_back(dest_bt_ptr);
00112     }
00113     <span class="comment">// Push new row onto d_values.</span>
00114     d_values.push_back(dest_bt_row_ptr);
00115     }
00116 }
00117 
00118 <span class="comment">// Protected member functions</span>
00119 
00120 <span class="keywordtype">void</span>
<a name="l00121"></a><a class="code" href="classSequence.html#Sequenceb0">00121</a> <a class="code" href="classSequence.html#Sequenceb0">Sequence::write_end_of_sequence</a>(XDR *sink)
00122 {
00123     xdr_opaque(sink, (<span class="keywordtype">char</span> *)&amp;end_of_sequence, 1);
00124 }
00125 
00126 <span class="keywordtype">void</span>
<a name="l00127"></a><a class="code" href="classSequence.html#Sequenceb1">00127</a> <a class="code" href="classSequence.html#Sequenceb1">Sequence::write_start_of_instance</a>(XDR *sink)
00128 {
00129     xdr_opaque(sink, (<span class="keywordtype">char</span> *)&amp;start_of_instance, 1);
00130 }
00131 
00132 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>
<a name="l00133"></a><a class="code" href="classSequence.html#Sequenceb2">00133</a> <a class="code" href="classSequence.html#Sequenceb2">Sequence::read_marker</a>(XDR *source)
00134 {
00135     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> marker;
00136     xdr_opaque(source, (<span class="keywordtype">char</span> *)&amp;marker, 1);
00137 
00138     <span class="keywordflow">return</span> marker;
00139 }
00140 
00141 <span class="keywordtype">bool</span>
<a name="l00142"></a><a class="code" href="classSequence.html#Sequenceb3">00142</a> <a class="code" href="classSequence.html#Sequenceb3">Sequence::is_start_of_instance</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> marker)
00143 {
00144     <span class="keywordflow">return</span> (marker == start_of_instance);
00145 }
00146 
00147 <span class="keywordtype">bool</span>
<a name="l00148"></a><a class="code" href="classSequence.html#Sequenceb4">00148</a> <a class="code" href="classSequence.html#Sequenceb4">Sequence::is_end_of_sequence</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> marker)
00149 {
00150     <span class="keywordflow">return</span> (marker == end_of_sequence);
00151 }
00152 
00153 <span class="comment">// Public member functions</span>
00154 
<a name="l00163"></a><a class="code" href="classSequence.html#Sequencea0">00163</a> <a class="code" href="classSequence.html#Sequencea0">Sequence::Sequence</a>(<span class="keyword">const</span> string &amp;n) : <a class="code" href="classConstructor.html">Constructor</a>(n, <a class="code" href="BaseType_8h.html#a21a18">dods_sequence_c</a>), 
00164     d_row_number(-1), d_starting_row_number(-1),
00165     d_row_stride(1), d_ending_row_number(-1)
00166 {
00167 }
00168 
<a name="l00170"></a><a class="code" href="classSequence.html#Sequencea1">00170</a> <a class="code" href="classSequence.html#Sequencea0">Sequence::Sequence</a>(<span class="keyword">const</span> <a class="code" href="classSequence.html">Sequence</a> &amp;rhs) : <a class="code" href="classConstructor.html">Constructor</a>(rhs)
00171 {
00172     <a class="code" href="classConstructor.html#Structureb0">_duplicate</a>(rhs);
00173 }
00174 
00175 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00176"></a><a class="code" href="classSequence.html#Sequencea4">00176</a> <a class="code" href="classSequence.html#Sequencea4">Sequence::ptr_duplicate</a>()
00177 {
00178     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classSequence.html#Sequencea0">Sequence</a>(*<span class="keyword">this</span>);
00179 }
00180 
00181 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span>
00182 delete_bt(<a class="code" href="classBaseType.html">BaseType</a> *bt_ptr)
00183 {
00184     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"In delete_bt: "</span> &lt;&lt; bt_ptr &lt;&lt; endl);
00185     <span class="keyword">delete</span> bt_ptr;
00186     bt_ptr = 0;
00187 }
00188 
00189 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span>
00190 delete_rows(<a class="code" href="Sequence_8h.html#a1">BaseTypeRow</a> *bt_row_ptr)
00191 {
00192     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"In delete_rows: "</span> &lt;&lt; bt_row_ptr &lt;&lt; endl);
00193 
00194     for_each(bt_row_ptr-&gt;begin(), bt_row_ptr-&gt;end(), delete_bt);
00195 
00196     <span class="keyword">delete</span> bt_row_ptr;
00197     bt_row_ptr = 0;
00198 }
00199 
<a name="l00200"></a><a class="code" href="classSequence.html#Sequencea2">00200</a> <a class="code" href="classSequence.html#Sequencea2">Sequence::~Sequence</a>()
00201 {
00202     <span class="keywordflow">for</span> (<a class="code" href="classSequence.html#Sequencew1">Vars_iter</a> i = _vars.begin(); i != _vars.end(); i++)
00203     {
00204     <a class="code" href="classBaseType.html">BaseType</a> *btp = *i ;
00205     <span class="keyword">delete</span> btp ;
00206     }
00207 
00208     for_each(d_values.begin(), d_values.end(), delete_rows);
00209 }
00210 
00211 <a class="code" href="classSequence.html">Sequence</a> &amp;
<a name="l00212"></a><a class="code" href="classSequence.html#Sequencea3">00212</a> <a class="code" href="classSequence.html#Sequencea3">Sequence::operator=</a>(<span class="keyword">const</span> <a class="code" href="classSequence.html">Sequence</a> &amp;rhs)
00213 {
00214     <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;rhs)
00215     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00216 
00217     dynamic_cast&lt;Constructor &amp;&gt;(*this) = rhs; <span class="comment">// run Constructor=</span>
00218 
00219     <a class="code" href="classConstructor.html#Structureb0">_duplicate</a>(rhs);
00220 
00221     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00222 }
00223 
00224 string
<a name="l00225"></a><a class="code" href="classSequence.html#Sequencea5">00225</a> <a class="code" href="classSequence.html#Sequencea5">Sequence::toString</a>()
00226 {
00227     ostringstream oss;
00228 
00229     oss &lt;&lt; <a class="code" href="classBaseType.html#Vectora26">BaseType::toString</a>();
00230 
00231     <span class="keywordflow">for</span> (<a class="code" href="classSequence.html#Sequencew1">Vars_iter</a> i = _vars.begin(); i != _vars.end(); i++)
00232     {
00233     oss &lt;&lt; (*i)-&gt;toString();
00234     }
00235 
00236     oss &lt;&lt; endl;
00237 
00238     <span class="keywordflow">return</span> oss.str();
00239 }
00240 
00241 <span class="keywordtype">int</span>
<a name="l00242"></a><a class="code" href="classSequence.html#Sequencea6">00242</a> <a class="code" href="classSequence.html#Sequencea6">Sequence::element_count</a>(<span class="keywordtype">bool</span> leaves)
00243 {
00244     <span class="keywordflow">if</span> (!leaves)
00245     <span class="keywordflow">return</span> _vars.size();
00246     <span class="keywordflow">else</span> {
00247     <span class="keywordtype">int</span> i = 0;
00248     <span class="keywordflow">for</span> (<a class="code" href="classSequence.html#Sequencew1">Vars_iter</a> iter = _vars.begin(); iter != _vars.end(); iter++)
00249     {
00250         i += (*iter)-&gt;element_count(<span class="keyword">true</span>);
00251     }
00252     <span class="keywordflow">return</span> i;
00253     }
00254 }
00255 
00256 <span class="keywordtype">bool</span>
<a name="l00257"></a><a class="code" href="classSequence.html#Sequencea7">00257</a> <a class="code" href="classSequence.html#Sequencea7">Sequence::is_linear</a>()
00258 {
00259     <span class="keywordtype">bool</span> linear = <span class="keyword">true</span>;
00260     <span class="keywordtype">bool</span> seq_found = <span class="keyword">false</span>;
00261     <span class="keywordflow">for</span> (<a class="code" href="classSequence.html#Sequencew1">Vars_iter</a> iter = _vars.begin(); linear &amp;&amp; iter != _vars.end(); iter++)
00262     {
00263     <span class="keywordflow">if</span> ((*iter)-&gt;type() == <a class="code" href="BaseType_8h.html#a21a18">dods_sequence_c</a>) {
00264         <span class="comment">// A linear sequence cannot have more than one child seq. at any</span>
00265         <span class="comment">// one level. If we've already found a seq at this level, return</span>
00266         <span class="comment">// false. </span>
00267         <span class="keywordflow">if</span> (seq_found) {
00268         linear = <span class="keyword">false</span>;
00269         <span class="keywordflow">break</span>;
00270         }
00271         seq_found = <span class="keyword">true</span>;
00272         linear = dynamic_cast&lt;Sequence *&gt;((*iter))-&gt;is_linear();
00273     }
00274     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((*iter)-&gt;type() == <a class="code" href="BaseType_8h.html#a21a17">dods_structure_c</a>) {
00275         linear = dynamic_cast&lt;Structure*&gt;((*iter))-&gt;is_linear();
00276     }
00277     <span class="keywordflow">else</span> {
00278         <span class="comment">// A linear sequence cannot have Arrays, Lists or Grids.</span>
00279         linear = (*iter)-&gt;is_simple_type();
00280     }
00281     }
00282 
00283     <span class="keywordflow">return</span> linear;
00284 }
00285 
00286 <span class="keywordtype">void</span>
<a name="l00287"></a><a class="code" href="classSequence.html#Sequencea8">00287</a> <a class="code" href="classSequence.html#Sequencea8">Sequence::set_send_p</a>(<span class="keywordtype">bool</span> state)
00288 {
00289     <span class="keywordflow">for</span> (<a class="code" href="classSequence.html#Sequencew1">Vars_iter</a> i = _vars.begin(); i != _vars.end(); i++)
00290     {
00291     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Calling Sequence::set_send_p() for: "</span> &lt;&lt; (*i)-&gt;name() 
00292         &lt;&lt; endl);
00293     (*i)-&gt;set_send_p(state);
00294     }
00295 
00296     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Calling Sequence::set_send_p() for: "</span> &lt;&lt; this-&gt;name() 
00297     &lt;&lt; endl);
00298     <a class="code" href="classBaseType.html#Urla27">BaseType::set_send_p</a>(state);
00299 }
00300 
00301 <span class="keywordtype">void</span>
<a name="l00302"></a><a class="code" href="classSequence.html#Sequencea9">00302</a> <a class="code" href="classSequence.html#Sequencea9">Sequence::set_read_p</a>(<span class="keywordtype">bool</span> state)
00303 {
00304     <span class="keywordflow">for</span> (<a class="code" href="classSequence.html#Sequencew1">Vars_iter</a> i = _vars.begin(); i != _vars.end(); i++)
00305     {
00306     (*i)-&gt;set_read_p(state);
00307     }
00308 
00309     <a class="code" href="classBaseType.html#Urla25">BaseType::set_read_p</a>(state);
00310 }
00311 
00312 <span class="keywordtype">void</span>
<a name="l00313"></a><a class="code" href="classSequence.html#Sequencea10">00313</a> <a class="code" href="classSequence.html#Sequencea10">Sequence::set_in_selection</a>(<span class="keywordtype">bool</span> state)
00314 {
00315     <span class="keywordflow">for</span> (<a class="code" href="classSequence.html#Sequencew1">Vars_iter</a> i = _vars.begin(); i != _vars.end(); i++) {
00316     (*i)-&gt;set_in_selection(state);
00317     }
00318 
00319     <a class="code" href="classBaseType.html#Vectora40">BaseType::set_in_selection</a>(state);
00320 }
00321 
00331 <span class="keywordtype">void</span> 
<a name="l00332"></a><a class="code" href="classSequence.html#Sequencea28">00332</a> <a class="code" href="classSequence.html#Sequencea28">Sequence::add_var</a>(<a class="code" href="classBaseType.html">BaseType</a> *bt, Part)
00333 {
00334    <span class="keywordflow">if</span>(!bt)
00335        <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, 
00336              <span class="stringliteral">"Cannot add variable: NULL pointer"</span>);
00337    <span class="comment">// Jose Garcia</span>
00338    <span class="comment">// We append a copy of bt so the owner</span>
00339    <span class="comment">// of bt is free to deallocate as he wishes.</span>
00340    <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"In Sequence::add_var(), bt: "</span> &lt;&lt; bt &lt;&lt;endl);
00341    <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; bt-&gt;<a class="code" href="classBaseType.html#Vectora26">toString</a>() &lt;&lt; endl);
00342 
00343    <a class="code" href="classBaseType.html">BaseType</a> *bt_copy = bt-&gt;<a class="code" href="classBaseType.html#Constructora6">ptr_duplicate</a>();
00344    bt_copy-&gt;<a class="code" href="classBaseType.html#Vectora42">set_parent</a>(<span class="keyword">this</span>);
00345    _vars.push_back(bt_copy);
00346 
00347    <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"In Sequence::add_var(), bt_copy: "</span> &lt;&lt; bt_copy &lt;&lt;endl);
00348    <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; bt_copy-&gt;<a class="code" href="classBaseType.html#Vectora26">toString</a>() &lt;&lt; endl);
00349 }
00350 
00351 <span class="comment">// Deprecated</span>
00352 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00353"></a><a class="code" href="classSequence.html#Sequencea24">00353</a> <a class="code" href="classSequence.html#Sequencea23">Sequence::var</a>(<span class="keyword">const</span> string &amp;n, <a class="code" href="BaseType_8h.html#a1">btp_stack</a> &amp;s)
00354 {
00355     string <a class="code" href="classBaseType.html#Vectora27">name</a> = <a class="code" href="escaping_8cc.html#a7">www2id</a>(n);
00356 
00357     <a class="code" href="classBaseType.html">BaseType</a> *btp = exact_match(name, &amp;s);
00358     <span class="keywordflow">if</span> (btp)
00359     <span class="keywordflow">return</span> btp;
00360 
00361     <span class="keywordflow">return</span> leaf_match(name, &amp;s);
00362 }
00363 
00364 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00365"></a><a class="code" href="classSequence.html#Sequencea23">00365</a> <a class="code" href="classSequence.html#Sequencea23">Sequence::var</a>(<span class="keyword">const</span> string &amp;n, <span class="keywordtype">bool</span> exact, <a class="code" href="BaseType_8h.html#a1">btp_stack</a> *s)
00366 {
00367     string <a class="code" href="classBaseType.html#Vectora27">name</a> = <a class="code" href="escaping_8cc.html#a7">www2id</a>(n);
00368 
00369     <span class="keywordflow">if</span> (exact)
00370     <span class="keywordflow">return</span> exact_match(name, s);
00371     <span class="keywordflow">else</span>
00372     <span class="keywordflow">return</span> leaf_match(name, s);
00373 }
00374 
00375 <a class="code" href="classBaseType.html">BaseType</a> *
00376 Sequence::leaf_match(<span class="keyword">const</span> string &amp;name, <a class="code" href="BaseType_8h.html#a1">btp_stack</a> *s)
00377 {
00378     <span class="keywordflow">for</span> (<a class="code" href="classSequence.html#Sequencew1">Vars_iter</a> i = _vars.begin(); i != _vars.end(); i++)
00379     {
00380     <span class="keywordflow">if</span> ((*i)-&gt;name() == name) {
00381         <span class="keywordflow">if</span> (s)
00382         s-&gt;push(static_cast&lt;BaseType *&gt;(<span class="keyword">this</span>));
00383         <span class="keywordflow">return</span> *i;
00384     }
00385         <span class="keywordflow">if</span> ((*i)-&gt;is_constructor_type()) {
00386         <a class="code" href="classBaseType.html">BaseType</a> *btp = (*i)-&gt;var(name, <span class="keyword">false</span>, s);
00387         <span class="keywordflow">if</span> (btp) {
00388         <span class="keywordflow">if</span> (s)
00389             s-&gt;push(static_cast&lt;BaseType *&gt;(<span class="keyword">this</span>));
00390         <span class="keywordflow">return</span> btp;
00391         }
00392     }
00393     }
00394 
00395     <span class="keywordflow">return</span> 0;
00396 }
00397 
00398 <a class="code" href="classBaseType.html">BaseType</a> *
00399 Sequence::exact_match(<span class="keyword">const</span> string &amp;name, <a class="code" href="BaseType_8h.html#a1">btp_stack</a> *s)
00400 {
00401     <span class="keywordflow">for</span> (<a class="code" href="classSequence.html#Sequencew1">Vars_iter</a> i = _vars.begin(); i != _vars.end(); i++)
00402     {
00403     <span class="keywordflow">if</span> ((*i)-&gt;name() == name) {
00404         <span class="keywordflow">if</span> (s)
00405         s-&gt;push(static_cast&lt;BaseType *&gt;(<span class="keyword">this</span>));
00406         <span class="keywordflow">return</span> *i;
00407     }
00408     }
00409 
00410     string::size_type dot_pos = name.find(<span class="stringliteral">"."</span>); <span class="comment">// zero-based index of `.'</span>
00411     <span class="keywordflow">if</span> (dot_pos != string::npos) {
00412     string aggregate = name.substr(0, dot_pos);
00413     string field = name.substr(dot_pos + 1);
00414 
00415     <a class="code" href="classBaseType.html">BaseType</a> *agg_ptr = <a class="code" href="classSequence.html#Sequencea23">var</a>(aggregate);
00416     <span class="keywordflow">if</span> (agg_ptr) {
00417         <span class="keywordflow">if</span> (s)
00418         s-&gt;push(static_cast&lt;BaseType *&gt;(<span class="keyword">this</span>));
00419         <span class="keywordflow">return</span> agg_ptr-&gt;<a class="code" href="classBaseType.html#Vectora44">var</a>(field, <span class="keyword">true</span>, s); <span class="comment">// recurse</span>
00420     }
00421     <span class="keywordflow">else</span>
00422         <span class="keywordflow">return</span> 0;       <span class="comment">// qualified names must be *fully* qualified</span>
00423     }
00424 
00425     <span class="keywordflow">return</span> 0;
00426 }
00427 
00431 <a class="code" href="Sequence_8h.html#a1">BaseTypeRow</a> *
<a name="l00432"></a><a class="code" href="classSequence.html#Sequencea27">00432</a> <a class="code" href="classSequence.html#Sequencea27">Sequence::row_value</a>(size_t row)
00433 {
00434     <span class="keywordflow">if</span> (row &gt;= d_values.size())
00435     <span class="keywordflow">return</span> 0;
00436     <span class="keywordflow">return</span> d_values[row];
00437 }
00438 
00444 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00445"></a><a class="code" href="classSequence.html#Sequencea25">00445</a> <a class="code" href="classSequence.html#Sequencea25">Sequence::var_value</a>(size_t row, <span class="keyword">const</span> string &amp;name)
00446 {
00447     <a class="code" href="Sequence_8h.html#a1">BaseTypeRow</a> *bt_row_ptr = <a class="code" href="classSequence.html#Sequencea27">row_value</a>(row);
00448     <span class="keywordflow">if</span> (!bt_row_ptr)
00449     <span class="keywordflow">return</span> 0;
00450 
00451     BaseTypeRow::iterator bt_row_iter = bt_row_ptr-&gt;begin();
00452     BaseTypeRow::iterator bt_row_end = bt_row_ptr-&gt;end();    
00453     <span class="keywordflow">while</span> (bt_row_iter != bt_row_end &amp;&amp; (*bt_row_iter)-&gt;name() != name)
00454     ++bt_row_iter;
00455     
00456     <span class="keywordflow">if</span> (bt_row_iter == bt_row_end)
00457     <span class="keywordflow">return</span> 0;
00458     <span class="keywordflow">else</span>
00459     <span class="keywordflow">return</span> *bt_row_iter;
00460 }
00461 
00467 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00468"></a><a class="code" href="classSequence.html#Sequencea26">00468</a> <a class="code" href="classSequence.html#Sequencea25">Sequence::var_value</a>(size_t row, size_t i)
00469 {
00470     <a class="code" href="Sequence_8h.html#a1">BaseTypeRow</a> *bt_row_ptr = <a class="code" href="classSequence.html#Sequencea27">row_value</a>(row);
00471     <span class="keywordflow">if</span> (!bt_row_ptr)
00472     <span class="keywordflow">return</span> 0;
00473 
00474     <span class="keywordflow">if</span> (i &gt;= bt_row_ptr-&gt;size())
00475     <span class="keywordflow">return</span> 0;
00476 
00477     <span class="keywordflow">return</span> (*bt_row_ptr)[i];
00478 }
00479 
00484 Pix
<a name="l00485"></a><a class="code" href="classSequence.html#Sequencea32">00485</a> <a class="code" href="classSequence.html#Sequencea32">Sequence::first_var</a>()
00486 {
00487     <span class="keywordflow">if</span> (_vars.empty())
00488     <span class="keywordflow">return</span> 0;
00489 
00490     <a class="code" href="classBTIterAdapter.html">BTIterAdapter</a> *i = <span class="keyword">new</span> <a class="code" href="classBTIterAdapter.html">BTIterAdapter</a>( _vars ) ;
00491     i-&gt;<a class="code" href="classBTIterAdapter.html#BTIterAdapterz62_0">first</a>() ;
00492     <span class="keywordflow">return</span> i ;
00493 }
00494 
00495 <a class="code" href="classSequence.html#Sequencew1">Sequence::Vars_iter</a>
<a name="l00496"></a><a class="code" href="classSequence.html#Sequencea29">00496</a> <a class="code" href="classSequence.html#Sequencea29">Sequence::var_begin</a>()
00497 {
00498     <span class="keywordflow">return</span> _vars.begin() ;
00499 }
00500 
00501 <a class="code" href="classSequence.html#Sequencew1">Sequence::Vars_iter</a>
<a name="l00502"></a><a class="code" href="classSequence.html#Sequencea30">00502</a> <a class="code" href="classSequence.html#Sequencea30">Sequence::var_end</a>()
00503 {
00504     <span class="keywordflow">return</span> _vars.end() ;
00505 }
00506 
00510 <a class="code" href="classSequence.html#Sequencew1">Sequence::Vars_iter</a>
<a name="l00511"></a><a class="code" href="classSequence.html#Sequencea31">00511</a> <a class="code" href="classSequence.html#Sequencea31">Sequence::get_vars_iter</a>(<span class="keywordtype">int</span> i)
00512 {
00513     <span class="keywordflow">return</span> _vars.begin() + i;
00514 }
00515 
00519 <span class="keywordtype">void</span>
<a name="l00520"></a><a class="code" href="classSequence.html#Sequencea33">00520</a> <a class="code" href="classSequence.html#Sequencea33">Sequence::next_var</a>(Pix p)
00521 {
00522     p.next() ;
00523 }
00524 
00527 <a class="code" href="classBaseType.html">BaseType</a> *
<a name="l00528"></a><a class="code" href="classSequence.html#Sequencea34">00528</a> <a class="code" href="classSequence.html#Sequencea23">Sequence::var</a>(Pix p)
00529 {
00530     <a class="code" href="classBTIterAdapter.html">BTIterAdapter</a> *i = (<a class="code" href="classBTIterAdapter.html">BTIterAdapter</a> *)p.getIterator() ;
00531     <span class="keywordflow">if</span>( i ) {
00532     <span class="keywordflow">return</span> i-&gt;<a class="code" href="classBTIterAdapter.html#BTIterAdapterz64_0">entry</a>() ;
00533     }
00534     <span class="keywordflow">return</span> 0 ;
00535 }
00536 
00537 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00538"></a><a class="code" href="classSequence.html#Sequencea11">00538</a> <a class="code" href="classSequence.html#Sequencea11">Sequence::width</a>()
00539 {
00540     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz = 0;
00541 
00542     <span class="keywordflow">for</span>(<a class="code" href="classSequence.html#Sequencew1">Vars_iter</a> i = _vars.begin(); i != _vars.end(); i++)
00543     {
00544     sz += (*i)-&gt;width();
00545     }
00546 
00547     <span class="keywordflow">return</span> sz;
00548 }
00549 
00550 <span class="comment">// This version returns -1. Each API-specific subclass should define a more</span>
00551 <span class="comment">// reasonable version. jhrg 5/24/96</span>
00552 
00568 <span class="keywordtype">int</span>
<a name="l00569"></a><a class="code" href="classSequence.html#Sequencea12">00569</a> <a class="code" href="classSequence.html#Sequencea12">Sequence::length</a>()
00570 {
00571     <span class="keywordflow">return</span> -1;
00572 }
00573 
00574 <span class="keywordtype">int</span>
<a name="l00575"></a><a class="code" href="classSequence.html#Sequencea13">00575</a> <a class="code" href="classSequence.html#Sequencea13">Sequence::number_of_rows</a>()
00576 {
00577     <span class="keywordflow">return</span> d_values.size();
00578 }
00579 
00580 <span class="comment">// Notes:</span>
00581 <span class="comment">// Assume that read() is implemented so that, when reading data for a nested</span>
00582 <span class="comment">// sequence, only the outer most level is *actually* read.</span>
00583 <span class="comment">// This is a consequence of our current (12/7/99) implementation of</span>
00584 <span class="comment">// the JGOFS server (which is the only server to actually use nested</span>
00585 <span class="comment">// sequences). 12/7/99 jhrg</span>
00586 <span class="comment">//</span>
00587 <span class="comment">// Stop assuming this. This logic is being moved into the JGOFS server</span>
00588 <span class="comment">// itself. 6/1/2001 jhrg</span>
00589 
00590 <span class="comment">// The read() function returns a boolean value, with TRUE</span>
00591 <span class="comment">// indicating that read() should be called again because there's</span>
00592 <span class="comment">// more data to read, and FALSE indicating there's no more data</span>
00593 <span class="comment">// to read. Note that this behavior is necessary to properly</span>
00594 <span class="comment">// handle variables that contain Sequences. Jose Garcia If an</span>
00595 <span class="comment">// error exists while reading, the implementers of the surrogate</span>
00596 <span class="comment">// library SHOULD throw an Error object which will propagate</span>
00597 <span class="comment">// beyond this point to to the original caller.</span>
00598 <span class="comment">// Jose Garcia</span>
00599 
00626 <span class="keywordtype">bool</span>
<a name="l00627"></a><a class="code" href="classSequence.html#Sequencea14">00627</a> <a class="code" href="classSequence.html#Sequencea14">Sequence::read_row</a>(<span class="keywordtype">int</span> row, <span class="keyword">const</span> string &amp;dataset, <a class="code" href="classDDS.html">DDS</a> &amp;dds, <span class="keywordtype">bool</span> ce_eval)
00628 {
00629     <span class="keywordflow">if</span> (row &lt; d_row_number)
00630     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(<span class="stringliteral">"Trying to back up inside a sequence!"</span>);
00631 
00632     <span class="keywordflow">if</span> (row == d_row_number)
00633     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00634 
00635     dds.<a class="code" href="classDDS.html#DDSa18">timeout_on</a>();
00636 
00637     <span class="keywordtype">int</span> eof = 0;        <span class="comment">// Start out assuming EOF is false.</span>
00638     <span class="keywordflow">while</span>(!eof &amp;&amp; d_row_number &lt; row) {
00639     <span class="keywordflow">if</span> (!<a class="code" href="classBaseType.html#Vectora37">read_p</a>()) {
00640         eof = (<a class="code" href="classBaseType.html#Vectora45">read</a>(dataset) == <span class="keyword">false</span>);
00641     }
00642 
00643     <span class="comment">// Advance the row number if ce_eval is false (we're not supposed to</span>
00644     <span class="comment">// evaluate the selection) or both ce_eval and the selection are</span>
00645     <span class="comment">// true.</span>
00646     <span class="keywordflow">if</span> (!ce_eval || (ce_eval &amp;&amp; dds.<a class="code" href="classDDS.html#DDSa31">eval_selection</a>(dataset)))
00647         d_row_number++;
00648 
00649     <a class="code" href="classSequence.html#Sequencea9">set_read_p</a>(<span class="keyword">false</span>);  <span class="comment">// ...so that the next instance will be read</span>
00650     }
00651 
00652     <span class="comment">// Once we finish te above loop, set read_p to true so that the caller</span>
00653     <span class="comment">// knows that data *has* been read. This is how the read() methods of the</span>
00654     <span class="comment">// elements of the sequence know to not call read() themselves but</span>
00655     <span class="comment">// instead look for data values inside themselves.</span>
00656     <a class="code" href="classSequence.html#Sequencea9">set_read_p</a>(<span class="keyword">true</span>);
00657 
00658     dds.<a class="code" href="classDDS.html#DDSa19">timeout_off</a>();
00659 
00660     <span class="comment">// Return true if we have valid data, false if we've read to the EOF.</span>
00661     <span class="keywordflow">return</span> eof == 0;
00662 }
00663 
00664 <span class="comment">// Private. This is used to process constraints on the rows of a sequence.</span>
00665 <span class="comment">// Starting with 3.2 we support constraints like Sequence[10:2:20]. This</span>
00666 <span class="comment">// odd-looking logic first checks if d_ending_row_number is the sentinel</span>
00667 <span class="comment">// value of -1. If so, the sequence was not constrained by row number and</span>
00668 <span class="comment">// this method should never return true (which indicates that we're at the</span>
00669 <span class="comment">// end of a row-number constraint). If d_ending_row_number is not -1, then is</span>
00670 <span class="comment">// \e i at the end point? 6/1/2001 jhrg</span>
00671 <span class="keyword">inline</span> <span class="keywordtype">bool</span>
00672 Sequence::is_end_of_rows(<span class="keywordtype">int</span> i)
00673 {
00674     <span class="keywordflow">return</span> ((d_ending_row_number == -1) ? <span class="keyword">false</span> : (i &gt;= d_ending_row_number));
00675 }
00676 
00677 <span class="keywordtype">bool</span>
<a name="l00678"></a><a class="code" href="classSequence.html#Sequencea15">00678</a> <a class="code" href="classSequence.html#Sequencea15">Sequence::serialize</a>(<span class="keyword">const</span> string &amp;dataset, <a class="code" href="classDDS.html">DDS</a> &amp;dds, XDR *sink, <span class="keywordtype">bool</span> ce_eval)
00679 {
00680     <span class="keywordtype">int</span> i = (d_starting_row_number != -1) ? d_starting_row_number : 0;
00681 
00682     <span class="comment">// read_row returns true if valid data was read, false if the EOF was</span>
00683     <span class="comment">// found. 6/1/2001 jhrg</span>
00684     <span class="keywordtype">bool</span> status = <a class="code" href="classSequence.html#Sequencea14">read_row</a>(i, dataset, dds, ce_eval);
00685 
00686     <span class="keywordflow">while</span> (status &amp;&amp; !is_end_of_rows(i)) {
00687     i += d_row_stride;
00688 
00689     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Writing Start of Instance marker"</span> &lt;&lt; endl);
00690     <a class="code" href="classSequence.html#Sequenceb1">write_start_of_instance</a>(sink);
00691 
00692     <span class="comment">// In this loop serialize will signal an error with an exception.</span>
00693     <span class="keywordflow">for</span> (<a class="code" href="classSequence.html#Sequencew1">Vars_iter</a> iter = _vars.begin(); iter != _vars.end(); iter++)
00694     {
00695         <span class="keywordflow">if</span> ((*iter)-&gt;send_p())
00696         (*iter)-&gt;serialize(dataset, dds, sink, <span class="keyword">false</span>);
00697     }
00698 
00699     <a class="code" href="classSequence.html#Sequencea9">set_read_p</a>(<span class="keyword">false</span>);  <span class="comment">// ...so this will read the next instance</span>
00700 
00701     status = <a class="code" href="classSequence.html#Sequencea14">read_row</a>(i, dataset, dds, ce_eval);
00702     }
00703 
00704     <a class="code" href="debug_8h.html#a1">DBG</a>(cerr &lt;&lt; <span class="stringliteral">"Writing End of Sequence marker"</span> &lt;&lt; endl);
00705     <a class="code" href="classSequence.html#Sequenceb0">write_end_of_sequence</a>(sink);
00706 
00707     <span class="keywordflow">return</span> <span class="keyword">true</span>;        <span class="comment">// Signal errors with exceptions.</span>
00708 }
00709 
00710 
00730 <span class="keywordtype">bool</span>
<a name="l00731"></a><a class="code" href="classSequence.html#Sequencea16">00731</a> <a class="code" href="classSequence.html#Sequencea16">Sequence::deserialize</a>(XDR *source, <a class="code" href="classDDS.html">DDS</a> *dds, <span class="keywordtype">bool</span> reuse)
00732 {
00733     <a class="code" href="classDataDDS.html">DataDDS</a> *dd = dynamic_cast&lt;DataDDS *&gt;(dds);
00734     <span class="keywordflow">if</span> (!dd)
00735     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(<span class="stringliteral">"Expected argument 'dds' to be a DataDDS!"</span>);
00736 
00737     <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"Reading from server version: "</span> &lt;&lt; dd-&gt;<a class="code" href="classDataDDS.html#DataDDSa4">get_version_major</a>() \
00738      &lt;&lt; <span class="stringliteral">"."</span> &lt;&lt; dd-&gt;<a class="code" href="classDataDDS.html#DataDDSa5">get_version_minor</a>() &lt;&lt; endl);
00739 
00740     <span class="comment">// Check for old servers.</span>
00741     <span class="keywordflow">if</span> (dd-&gt;<a class="code" href="classDataDDS.html#DataDDSa4">get_version_major</a>() &lt; 2 
00742     || dd-&gt;<a class="code" href="classDataDDS.html#DataDDSa4">get_version_major</a>() == 2 &amp;&amp; dd-&gt;<a class="code" href="classDataDDS.html#DataDDSa5">get_version_minor</a>() &lt; 15) {
00743     <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(
00744 string(<span class="stringliteral">"The server version ("</span>) + dd-&gt;<a class="code" href="classDataDDS.html#DataDDSa3">get_version</a>() + <span class="stringliteral">") indicates that this\n\</span>
00745 <span class="stringliteral">is an old server which may not correctly transmit Sequence variables.\n\</span>
00746 <span class="stringliteral">Contact the server administrator."</span>);
00747     }
00748 
00749     <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
00750     <span class="comment">// Grab the sequence stream's marker. </span>
00751     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> marker = <a class="code" href="classSequence.html#Sequenceb2">read_marker</a>(source);
00752     <span class="keywordflow">if</span> (<a class="code" href="classSequence.html#Sequenceb4">is_end_of_sequence</a>(marker))
00753         <span class="keywordflow">break</span>;      <span class="comment">// EXIT the while loop here!!!</span>
00754     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classSequence.html#Sequenceb3">is_start_of_instance</a>(marker)) {
00755         d_row_number++;
00756         <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"Reading row "</span> &lt;&lt; d_row_number &lt;&lt; <span class="stringliteral">" of "</span>
00757          &lt;&lt; <a class="code" href="classBaseType.html#Vectora27">name</a>() &lt;&lt; endl);
00758         <a class="code" href="Sequence_8h.html#a1">BaseTypeRow</a> *bt_row_ptr = <span class="keyword">new</span> <a class="code" href="Sequence_8h.html#a1">BaseTypeRow</a>;
00759         <span class="comment">// Read the instance's values, building up the row</span>
00760         <span class="keywordflow">for</span> (<a class="code" href="classSequence.html#Sequencew1">Vars_iter</a> iter = _vars.begin(); iter != _vars.end(); iter++)
00761         {
00762         <a class="code" href="classBaseType.html">BaseType</a> *bt_ptr = (*iter)-&gt;ptr_duplicate();
00763         bt_ptr-&gt;<a class="code" href="classBaseType.html#Constructora35">deserialize</a>(source, dds, reuse);
00764         <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"Deserialized "</span> &lt;&lt; bt_ptr-&gt;<a class="code" href="classBaseType.html#Vectora27">name</a>() &lt;&lt; <span class="stringliteral">" ("</span>
00765              &lt;&lt; bt_ptr &lt;&lt; <span class="stringliteral">") = "</span>);
00766         <a class="code" href="debug_8h.html#a3">DBG2</a>(bt_ptr-&gt;<a class="code" href="classBaseType.html#Constructora39">print_val</a>(stderr, <span class="stringliteral">""</span>));
00767         bt_row_ptr-&gt;push_back(bt_ptr);
00768         }
00769         <span class="comment">// Append this row to those accumulated.</span>
00770         d_values.push_back(bt_row_ptr);
00771     }
00772     <span class="keywordflow">else</span>
00773         <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(<span class="stringliteral">"I could not read the expected Sequence data stream marker!"</span>);
00774     };
00775 
00776     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00777 }
00778 
00779 <span class="comment">// Return the current row number.</span>
00780 
00792 <span class="keywordtype">int</span>
<a name="l00793"></a><a class="code" href="classSequence.html#Sequencea17">00793</a> <a class="code" href="classSequence.html#Sequencea17">Sequence::get_starting_row_number</a>()
00794 {
00795   <span class="keywordflow">return</span> d_starting_row_number;
00796 }
00797 
00808 <span class="keywordtype">int</span>
<a name="l00809"></a><a class="code" href="classSequence.html#Sequencea18">00809</a> <a class="code" href="classSequence.html#Sequencea18">Sequence::get_row_stride</a>()
00810 {
00811   <span class="keywordflow">return</span> d_row_stride;
00812 }
00813 
00825 <span class="keywordtype">int</span>
<a name="l00826"></a><a class="code" href="classSequence.html#Sequencea19">00826</a> <a class="code" href="classSequence.html#Sequencea19">Sequence::get_ending_row_number</a>()
00827 {
00828   <span class="keywordflow">return</span> d_ending_row_number;
00829 }
00830 
00839 <span class="keywordtype">void</span>
<a name="l00840"></a><a class="code" href="classSequence.html#Sequencea20">00840</a> <a class="code" href="classSequence.html#Sequencea20">Sequence::set_row_number_constraint</a>(<span class="keywordtype">int</span> start, <span class="keywordtype">int</span> stop, <span class="keywordtype">int</span> stride)
00841 {
00842   <span class="keywordflow">if</span> (stop &lt; start)
00843     <span class="keywordflow">throw</span> <a class="code" href="classError.html">Error</a>(<a class="code" href="Error_8h.html#a5">malformed_expr</a>, <span class="stringliteral">"Starting row number must precede the ending row number."</span>);
00844 
00845   d_starting_row_number = start;
00846   d_row_stride = stride;
00847   d_ending_row_number = stop;
00848 }
00849 
00850 <span class="comment">// private mfunc. Use this to read from older servers.</span>
00851 
00852 <span class="keywordtype">bool</span>
00853 Sequence::old_deserialize(XDR *source, <a class="code" href="classDDS.html">DDS</a> *dds, <span class="keywordtype">bool</span> reuse)
00854 {
00855     <span class="keywordtype">bool</span> stat = <span class="keyword">true</span>;
00856 
00857     <a class="code" href="debug_8h.html#a3">DBG2</a>(cerr &lt;&lt; <span class="stringliteral">"Entering old_deserialize()"</span> &lt;&lt; endl);
00858 
00859     <span class="keywordflow">for</span> (<a class="code" href="classSequence.html#Sequencew1">Vars_iter</a> i = _vars.begin(); i != _vars.end(); i++)
00860     {
00861     stat = (*i)-&gt;deserialize(source, dds, reuse);
00862     <span class="keywordflow">if</span> (!stat) 
00863         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00864     }
00865 
00866     d_row_number++;
00867 
00868     <span class="keywordflow">return</span> stat;
00869 }
00870 
00873 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00874"></a><a class="code" href="classSequence.html#Sequencea21">00874</a> <a class="code" href="classSequence.html#Sequencea21">Sequence::val2buf</a>(<span class="keywordtype">void</span> *, <span class="keywordtype">bool</span>)
00875 {
00876     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, <span class="stringliteral">"Never use this method; see the programmer's guide documentation."</span>);
00877     <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(<a class="code" href="classSequence.html">Sequence</a>);
00878 }
00879 
00884 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00885"></a><a class="code" href="classSequence.html#Sequencea22">00885</a> <a class="code" href="classSequence.html#Sequencea22">Sequence::buf2val</a>(<span class="keywordtype">void</span> **)
00886 {
00887     <span class="keywordflow">throw</span> <a class="code" href="classInternalErr.html">InternalErr</a>(__FILE__, __LINE__, <span class="stringliteral">"Use Sequence::var_value() or Sequence::row_value() in place of Sequence::buf2val()"</span>);
00888     <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(<a class="code" href="classSequence.html">Sequence</a>);
00889 }
00890 
00891 <span class="keywordtype">void</span>
<a name="l00892"></a><a class="code" href="classSequence.html#Sequencea35">00892</a> <a class="code" href="classSequence.html#Sequencea35">Sequence::print_decl</a>(ostream &amp;os, string space, <span class="keywordtype">bool</span> print_semi,
00893              <span class="keywordtype">bool</span> constraint_info, <span class="keywordtype">bool</span> constrained)
00894 {
00895     <span class="keywordflow">if</span> (constrained &amp;&amp; !<a class="code" href="classBaseType.html#Vectora38">send_p</a>())
00896     <span class="keywordflow">return</span>;
00897 
00898     os &lt;&lt; space &lt;&lt; <a class="code" href="classBaseType.html#Vectora31">type_name</a>() &lt;&lt; <span class="stringliteral">" {"</span> &lt;&lt; endl;
00899     <span class="keywordflow">for</span> (<a class="code" href="classSequence.html#Sequencew1">Vars_iter</a> i = _vars.begin(); i != _vars.end(); i++)
00900     {
00901     (*i)-&gt;print_decl(os, space + <span class="stringliteral">"    "</span>, <span class="keyword">true</span>,
00902              constraint_info, constrained);
00903     }
00904     os &lt;&lt; space &lt;&lt; <span class="stringliteral">"} "</span> &lt;&lt; <a class="code" href="escaping_8cc.html#a5">id2www</a>(<a class="code" href="classBaseType.html#Vectora27">name</a>());
00905 
00906     <span class="keywordflow">if</span> (constraint_info) {  <span class="comment">// Used by test drivers only.</span>
00907     <span class="keywordflow">if</span> (<a class="code" href="classBaseType.html#Vectora38">send_p</a>())
00908         cout &lt;&lt; <span class="stringliteral">": Send True"</span>;
00909     <span class="keywordflow">else</span>
00910         cout &lt;&lt; <span class="stringliteral">": Send False"</span>;
00911     }
00912 
00913     <span class="keywordflow">if</span> (print_semi)
00914     os &lt;&lt; <span class="stringliteral">";"</span> &lt;&lt; endl;
00915 }
00916 
00917 <span class="keywordtype">void</span>
<a name="l00918"></a><a class="code" href="classSequence.html#Sequencea36">00918</a> <a class="code" href="classSequence.html#Sequencea35">Sequence::print_decl</a>(FILE *out, string space, <span class="keywordtype">bool</span> print_semi,
00919              <span class="keywordtype">bool</span> constraint_info, <span class="keywordtype">bool</span> constrained)
00920 {
00921     <span class="keywordflow">if</span> (constrained &amp;&amp; !<a class="code" href="classBaseType.html#Vectora38">send_p</a>())
00922     <span class="keywordflow">return</span>;
00923 
00924     fprintf( out, <span class="stringliteral">"%s%s {\n"</span>, space.c_str(), <a class="code" href="classBaseType.html#Vectora31">type_name</a>().c_str() ) ;
00925     <span class="keywordflow">for</span> (<a class="code" href="classSequence.html#Sequencew0">Vars_citer</a> i = _vars.begin(); i != _vars.end(); i++)
00926     {
00927     (*i)-&gt;print_decl(out, space + <span class="stringliteral">"    "</span>, <span class="keyword">true</span>,
00928              constraint_info, constrained);
00929     }
00930     fprintf( out, <span class="stringliteral">"%s} %s"</span>, space.c_str(), <a class="code" href="escaping_8cc.html#a5">id2www</a>( <a class="code" href="classBaseType.html#Vectora27">name</a>() ).c_str() ) ;
00931 
00932     <span class="keywordflow">if</span> (constraint_info) {  <span class="comment">// Used by test drivers only.</span>
00933     <span class="keywordflow">if</span> (<a class="code" href="classBaseType.html#Vectora38">send_p</a>())
00934         cout &lt;&lt; <span class="stringliteral">": Send True"</span>;
00935     <span class="keywordflow">else</span>
00936         cout &lt;&lt; <span class="stringliteral">": Send False"</span>;
00937     }
00938 
00939     <span class="keywordflow">if</span> (print_semi)
00940     fprintf( out, <span class="stringliteral">";\n"</span> ) ;
00941 }
00942 
00946 <span class="keywordtype">void</span> 
<a name="l00947"></a><a class="code" href="classSequence.html#Sequencea37">00947</a> <a class="code" href="classSequence.html#Sequencea37">Sequence::print_one_row</a>(ostream &amp;os, <span class="keywordtype">int</span> row, string space, 
00948             <span class="keywordtype">bool</span> print_row_num)
00949 {
00950     <span class="keywordflow">if</span> (print_row_num)
00951     os &lt;&lt; endl &lt;&lt; row &lt;&lt; <span class="stringliteral">": "</span>;
00952 
00953     os &lt;&lt; <span class="stringliteral">"{ "</span>;
00954 
00955     <span class="keywordtype">int</span> elements = <a class="code" href="classSequence.html#Sequencea6">element_count</a>() - 1;
00956     <span class="keywordtype">int</span> j;
00957     <a class="code" href="classBaseType.html">BaseType</a> *bt_ptr;
00958     <span class="comment">// Print first N-1 elements of the row.</span>
00959     <span class="keywordflow">for</span> (j = 0; j &lt; elements; ++j) {
00960     bt_ptr = <a class="code" href="classSequence.html#Sequencea25">var_value</a>(row, j);
00961     <span class="keywordflow">if</span> (bt_ptr) {       <span class="comment">// data</span>
00962         <span class="keywordflow">if</span> (bt_ptr-&gt;<a class="code" href="classBaseType.html#Vectora29">type</a>() == <a class="code" href="BaseType_8h.html#a21a18">dods_sequence_c</a>)
00963         dynamic_cast&lt;Sequence*&gt;(bt_ptr)-&gt;print_val_by_rows
00964             (os, space, <span class="keyword">false</span>, print_row_num);
00965         <span class="keywordflow">else</span>
00966         bt_ptr-&gt;<a class="code" href="classBaseType.html#Constructora39">print_val</a>(os, space, <span class="keyword">false</span>);
00967         os &lt;&lt; <span class="stringliteral">", "</span>;
00968     }
00969     }
00970 
00971     <span class="comment">// Print Nth element; end with a `}.'</span>
00972     bt_ptr = <a class="code" href="classSequence.html#Sequencea25">var_value</a>(row, j);
00973     <span class="keywordflow">if</span> (bt_ptr) {       <span class="comment">// data</span>
00974     <span class="keywordflow">if</span> (bt_ptr-&gt;<a class="code" href="classBaseType.html#Vectora29">type</a>() == <a class="code" href="BaseType_8h.html#a21a18">dods_sequence_c</a>)
00975         dynamic_cast&lt;Sequence*&gt;(bt_ptr)-&gt;print_val_by_rows
00976         (os, space, <span class="keyword">false</span>, print_row_num);
00977     <span class="keywordflow">else</span>
00978         bt_ptr-&gt;<a class="code" href="classBaseType.html#Constructora39">print_val</a>(os, space, <span class="keyword">false</span>);
00979     }
00980 
00981     os &lt;&lt; <span class="stringliteral">" }"</span>;
00982 }
00983 
00984 <span class="keywordtype">void</span> 
<a name="l00985"></a><a class="code" href="classSequence.html#Sequencea38">00985</a> <a class="code" href="classSequence.html#Sequencea37">Sequence::print_one_row</a>(FILE *out, <span class="keywordtype">int</span> row, string space, 
00986             <span class="keywordtype">bool</span> print_row_num)
00987 {
00988     <span class="keywordflow">if</span> (print_row_num)
00989     fprintf( out, <span class="stringliteral">"\n%d: "</span>, row ) ;
00990 
00991     fprintf( out, <span class="stringliteral">"{ "</span> ) ;
00992 
00993     <span class="keywordtype">int</span> elements = <a class="code" href="classSequence.html#Sequencea6">element_count</a>() - 1;
00994     <span class="keywordtype">int</span> j;
00995     <a class="code" href="classBaseType.html">BaseType</a> *bt_ptr;
00996     <span class="comment">// Print first N-1 elements of the row.</span>
00997     <span class="keywordflow">for</span> (j = 0; j &lt; elements; ++j) {
00998     bt_ptr = <a class="code" href="classSequence.html#Sequencea25">var_value</a>(row, j);
00999     <span class="keywordflow">if</span> (bt_ptr) {       <span class="comment">// data</span>
01000         <span class="keywordflow">if</span> (bt_ptr-&gt;<a class="code" href="classBaseType.html#Vectora29">type</a>() == <a class="code" href="BaseType_8h.html#a21a18">dods_sequence_c</a>)
01001         dynamic_cast&lt;Sequence*&gt;(bt_ptr)-&gt;print_val_by_rows
01002             (out, space, <span class="keyword">false</span>, print_row_num);
01003         <span class="keywordflow">else</span>
01004         bt_ptr-&gt;<a class="code" href="classBaseType.html#Constructora39">print_val</a>(out, space, <span class="keyword">false</span>);
01005         fprintf( out, <span class="stringliteral">", "</span> ) ;
01006     }
01007     }
01008 
01009     <span class="comment">// Print Nth element; end with a `}.'</span>
01010     bt_ptr = <a class="code" href="classSequence.html#Sequencea25">var_value</a>(row, j);
01011     <span class="keywordflow">if</span> (bt_ptr) {       <span class="comment">// data</span>
01012     <span class="keywordflow">if</span> (bt_ptr-&gt;<a class="code" href="classBaseType.html#Vectora29">type</a>() == <a class="code" href="BaseType_8h.html#a21a18">dods_sequence_c</a>)
01013         dynamic_cast&lt;Sequence*&gt;(bt_ptr)-&gt;print_val_by_rows
01014         (out, space, <span class="keyword">false</span>, print_row_num);
01015     <span class="keywordflow">else</span>
01016         bt_ptr-&gt;<a class="code" href="classBaseType.html#Constructora39">print_val</a>(out, space, <span class="keyword">false</span>);
01017     }
01018 
01019     fprintf( out, <span class="stringliteral">" }"</span> ) ;
01020 }
01033 <span class="keywordtype">void</span>
<a name="l01034"></a><a class="code" href="classSequence.html#Sequencea39">01034</a> <a class="code" href="classSequence.html#Sequencea39">Sequence::print_val_by_rows</a>(ostream &amp;os, string space, <span class="keywordtype">bool</span> print_decl_p,
01035                 <span class="keywordtype">bool</span> print_row_numbers)
01036 {
01037     <span class="keywordflow">if</span> (print_decl_p) {
01038     <a class="code" href="classSequence.html#Sequencea35">print_decl</a>(os, space, <span class="keyword">false</span>);
01039     os &lt;&lt; <span class="stringliteral">" = "</span>;
01040     }
01041 
01042     os &lt;&lt; <span class="stringliteral">"{ "</span>;
01043 
01044     <span class="keywordtype">int</span> rows = <a class="code" href="classSequence.html#Sequencea13">number_of_rows</a>() - 1;
01045     <span class="keywordtype">int</span> i;
01046     <span class="keywordflow">for</span> (i = 0; i &lt; rows; ++i) {
01047     <a class="code" href="classSequence.html#Sequencea37">print_one_row</a>(os, i, space, print_row_numbers);
01048         os &lt;&lt; <span class="stringliteral">", "</span>;
01049     }
01050     <a class="code" href="classSequence.html#Sequencea37">print_one_row</a>(os, i, space, print_row_numbers);
01051 
01052     os &lt;&lt; <span class="stringliteral">" }"</span>;
01053 
01054     <span class="keywordflow">if</span> (print_decl_p)
01055         os &lt;&lt; <span class="stringliteral">";"</span> &lt;&lt; endl;
01056 }
01057 
01058 <span class="keywordtype">void</span>
<a name="l01059"></a><a class="code" href="classSequence.html#Sequencea40">01059</a> <a class="code" href="classSequence.html#Sequencea39">Sequence::print_val_by_rows</a>(FILE *out, string space, <span class="keywordtype">bool</span> print_decl_p,
01060                 <span class="keywordtype">bool</span> print_row_numbers)
01061 {
01062     <span class="keywordflow">if</span> (print_decl_p) {
01063     <a class="code" href="classSequence.html#Sequencea35">print_decl</a>(out, space, <span class="keyword">false</span>);
01064     fprintf( out, <span class="stringliteral">" = "</span> ) ;
01065     }
01066 
01067     fprintf( out, <span class="stringliteral">"{ "</span> ) ;
01068 
01069     <span class="keywordtype">int</span> rows = <a class="code" href="classSequence.html#Sequencea13">number_of_rows</a>() - 1;
01070     <span class="keywordtype">int</span> i;
01071     <span class="keywordflow">for</span> (i = 0; i &lt; rows; ++i) {
01072     <a class="code" href="classSequence.html#Sequencea37">print_one_row</a>(out, i, space, print_row_numbers);
01073         fprintf( out, <span class="stringliteral">", "</span> ) ;
01074     }
01075     <a class="code" href="classSequence.html#Sequencea37">print_one_row</a>(out, i, space, print_row_numbers);
01076 
01077     fprintf( out, <span class="stringliteral">" }"</span> ) ;
01078 
01079     <span class="keywordflow">if</span> (print_decl_p)
01080         fprintf( out, <span class="stringliteral">";\n"</span> ) ;
01081 }
01082 
01088 <span class="keywordtype">void</span> 
<a name="l01089"></a><a class="code" href="classSequence.html#Sequencea41">01089</a> <a class="code" href="classSequence.html#Sequencea41">Sequence::print_val</a>(ostream &amp;os, string space, <span class="keywordtype">bool</span> print_decl_p)
01090 {
01091     <a class="code" href="classSequence.html#Sequencea39">print_val_by_rows</a>(os, space, print_decl_p, <span class="keyword">false</span>);
01092 }
01093 
01094 <span class="keywordtype">void</span> 
<a name="l01095"></a><a class="code" href="classSequence.html#Sequencea42">01095</a> <a class="code" href="classSequence.html#Sequencea41">Sequence::print_val</a>(FILE *out, string space, <span class="keywordtype">bool</span> print_decl_p)
01096 {
01097     <a class="code" href="classSequence.html#Sequencea39">print_val_by_rows</a>(out, space, print_decl_p, <span class="keyword">false</span>);
01098 }
01099 
01100 <span class="comment">// print_all_vals is from Todd Karakasian. </span>
01101 <span class="comment">// We need to integrate this into print_val somehow, maybe by adding an XDR *</span>
01102 <span class="comment">// to Sequence? This can wait since print_val is mostly used for debugging...</span>
01103 <span class="comment">//</span>
01104 <span class="comment">// Deprecated. </span>
01105 
01126 <span class="keywordtype">void</span>
<a name="l01127"></a><a class="code" href="classSequence.html#Sequencea43">01127</a> <a class="code" href="classSequence.html#Sequencea43">Sequence::print_all_vals</a>(ostream&amp; os, XDR *src, <a class="code" href="classDDS.html">DDS</a> *dds, string space,
01128              <span class="keywordtype">bool</span> print_decl_p)
01129 {
01130     <a class="code" href="classSequence.html#Sequencea41">print_val</a>(os, space, print_decl_p);
01131 }
01132 
01133 <span class="comment">// print_all_vals is from Todd Karakasian. </span>
01134 <span class="comment">// We need to integrate this into print_val somehow, maybe by adding an XDR *</span>
01135 <span class="comment">// to Sequence? This can wait since print_val is mostly used for debugging...</span>
01136 <span class="comment">//</span>
01137 <span class="comment">// Deprecated. No longer needed since print_vals does its job.</span>
01138 
01139 <span class="keywordtype">void</span>
<a name="l01140"></a><a class="code" href="classSequence.html#Sequencea44">01140</a> <a class="code" href="classSequence.html#Sequencea43">Sequence::print_all_vals</a>(FILE *out, XDR *src, <a class="code" href="classDDS.html">DDS</a> *dds, string space,
01141              <span class="keywordtype">bool</span> print_decl_p)
01142 {
01143 <span class="preprocessor">#if 0</span>
01144 <span class="preprocessor"></span>    <a class="code" href="classSequence.html#Sequencea16">deserialize</a>(src, dds);
01145 <span class="preprocessor">#endif</span>
01146 <span class="preprocessor"></span>    <a class="code" href="classSequence.html#Sequencea41">print_val</a>(out, space, print_decl_p);
01147 }
01148 
01149 <span class="keywordtype">bool</span>
<a name="l01150"></a><a class="code" href="classSequence.html#Sequencea45">01150</a> <a class="code" href="classSequence.html#Sequencea45">Sequence::check_semantics</a>(string &amp;msg, <span class="keywordtype">bool</span> all)
01151 {
01152     <span class="keywordflow">if</span> (!<a class="code" href="classBaseType.html#Urla40">BaseType::check_semantics</a>(msg))
01153     <span class="keywordflow">return</span> <span class="keyword">false</span>;
01154 
01155     <span class="keywordflow">if</span> (!<a class="code" href="util_8cc.html#a3">unique_names</a>(_vars, <a class="code" href="classBaseType.html#Vectora27">name</a>(), <a class="code" href="classBaseType.html#Vectora31">type_name</a>(), msg))
01156     <span class="keywordflow">return</span> <span class="keyword">false</span>;
01157 
01158     <span class="keywordflow">if</span> (all) 
01159     <span class="keywordflow">for</span> (<a class="code" href="classSequence.html#Sequencew1">Vars_iter</a> i = _vars.begin(); i != _vars.end(); i++)
01160     {
01161         <span class="keywordflow">if</span> (!(*i)-&gt;check_semantics(msg, <span class="keyword">true</span>))
01162         {
01163         <span class="keywordflow">return</span> <span class="keyword">false</span>;
01164         }
01165     }
01166 
01167     <span class="keywordflow">return</span> <span class="keyword">true</span>;
01168 }
01169 
01170 <span class="comment">// $Log: Sequence_8cc-source.html,v $
01170 <span class="comment">// Revision 1.4  2004/02/05 06:51:16  jimg
01170 <span class="comment">// Added/update.
01170 <span class="comment">//</span>
01171 <span class="comment">// Revision 1.70.2.7  2004/01/17 13:37:50  rmorris</span>
01172 <span class="comment">// Mod's to account for differences in usage statements containing template</span>
01173 <span class="comment">// reference between MS VC++ 6.0 and MS VC++ 7.0.</span>
01174 <span class="comment">//</span>
01175 <span class="comment">// Revision 1.70.2.6  2003/11/25 18:21:16  jimg</span>
01176 <span class="comment">// Comments for buf2val() and val2buf() improved.</span>
01177 <span class="comment">//</span>
01178 <span class="comment">// Revision 1.70.2.5  2003/11/19 18:21:59  jimg</span>
01179 <span class="comment">// Fixed a bug in the deserialize() method introduced for the last bug fix</span>
01180 <span class="comment">// (#682).</span>
01181 <span class="comment">//</span>
01182 <span class="comment">// Revision 1.70.2.4  2003/11/18 21:59:10  jimg</span>
01183 <span class="comment">// deserialize() now throws Error if the version number is &lt; 2.15. This means</span>
01184 <span class="comment">// that all servers MUST produce valid version strings and that the old method</span>
01185 <span class="comment">// may be eliminated.</span>
01186 <span class="comment">//</span>
01187 <span class="comment">// Revision 1.70.2.3  2003/09/06 22:54:37  jimg</span>
01188 <span class="comment">// Added set_in_selection() method. Updated the documentation.</span>
01189 <span class="comment">//</span>
01190 <span class="comment">// Revision 1.70.2.2  2003/07/25 06:04:28  jimg</span>
01191 <span class="comment">// Refactored the code so that DDS:send() is now incorporated into</span>
01192 <span class="comment">// DODSFilter::send_data(). The old DDS::send() is still there but is</span>
01193 <span class="comment">// depracated.</span>
01194 <span class="comment">// Added 'smart timeouts' to all the variable classes. This means that</span>
01195 <span class="comment">// the new server timeouts are active only for the data read and CE</span>
01196 <span class="comment">// evaluation. This went inthe BaseType::serialize() methods because it</span>
01197 <span class="comment">// needed to time both the read() calls and the dds::eval() calls.</span>
01198 <span class="comment">//</span>
01199 <span class="comment">// Revision 1.70.2.1  2003/06/05 20:15:26  jimg</span>
01200 <span class="comment">// Removed many uses of strstream and replaced them with stringstream.</span>
01201 <span class="comment">//</span>
01202 <span class="comment">// Revision 1.70  2003/04/22 19:40:28  jimg</span>
01203 <span class="comment">// Merged with 3.3.1.</span>
01204 <span class="comment">//</span>
01205 <span class="comment">// Revision 1.68.2.2  2003/04/15 01:17:12  jimg</span>
01206 <span class="comment">// Added a method to get the iterator for a variable (or map) given its</span>
01207 <span class="comment">// index. To get the iterator for the ith variable/map, call</span>
01208 <span class="comment">// get_vars_iter(i).</span>
01209 <span class="comment">//</span>
01210 <span class="comment">// Revision 1.69  2003/02/21 00:14:24  jimg</span>
01211 <span class="comment">// Repaired copyright.</span>
01212 <span class="comment">//</span>
01213 <span class="comment">// Revision 1.68.2.1  2003/02/21 00:10:07  jimg</span>
01214 <span class="comment">// Repaired copyright.</span>
01215 <span class="comment">//</span>
01216 <span class="comment">// Revision 1.68  2003/01/23 00:22:24  jimg</span>
01217 <span class="comment">// Updated the copyright notice; this implementation of the DAP is</span>
01218 <span class="comment">// copyrighted by OPeNDAP, Inc.</span>
01219 <span class="comment">//</span>
01220 <span class="comment">// Revision 1.67  2003/01/15 19:24:39  pwest</span>
01221 <span class="comment">// Removing IteratorAdapterT and replacing with non-templated versions.</span>
01222 <span class="comment">//</span>
01223 <span class="comment">// Revision 1.66  2003/01/10 19:46:40  jimg</span>
01224 <span class="comment">// Merged with code tagged release-3-2-10 on the release-3-2 branch. In many</span>
01225 <span class="comment">// cases files were added on that branch (so they appear on the trunk for</span>
01226 <span class="comment">// the first time).</span>
01227 <span class="comment">//</span>
01228 <span class="comment">// Revision 1.59.4.24  2002/12/31 16:43:20  rmorris</span>
01229 <span class="comment">// Patches to handle some of the fancier template code under VC++ 6.0.</span>
01230 <span class="comment">//</span>
01231 <span class="comment">// Revision 1.59.4.23  2002/12/27 19:34:42  jimg</span>
01232 <span class="comment">// Modified the var() methods so that www2id() is called before looking</span>
01233 <span class="comment">// up identifier names. See bug 563.</span>
01234 <span class="comment">//</span>
01235 <span class="comment">// Revision 1.59.4.22  2002/12/17 22:35:03  pwest</span>
01236 <span class="comment">// Added and updated methods using stdio. Deprecated methods using iostream.</span>
01237 <span class="comment">//</span>
01238 <span class="comment">// Revision 1.59.4.21  2002/12/01 14:37:52  rmorris</span>
01239 <span class="comment">// Smalling changes for the win32 porting and maintenance work.</span>
01240 <span class="comment">//</span>
01241 <span class="comment">// Revision 1.59.4.20  2002/10/28 21:17:44  pwest</span>
01242 <span class="comment">// Converted all return values and method parameters to use non-const iterator.</span>
01243 <span class="comment">// Added operator== and operator!= methods to IteratorAdapter to handle Pix</span>
01244 <span class="comment">// problems.</span>
01245 <span class="comment">//</span>
01246 <span class="comment">// Revision 1.59.4.19  2002/09/12 22:49:57  pwest</span>
01247 <span class="comment">// Corrected signature changes made with Pix to IteratorAdapter changes. Rather</span>
01248 <span class="comment">// than taking a reference to a Pix, taking a Pix value.</span>
01249 <span class="comment">//</span>
01250 <span class="comment">// Revision 1.59.4.18  2002/09/05 22:52:54  pwest</span>
01251 <span class="comment">// Replaced the GNU data structures SLList and DLList with the STL container</span>
01252 <span class="comment">// class vector&lt;&gt;. To maintain use of Pix, changed the Pix.h header file to</span>
01253 <span class="comment">// redefine Pix to be an IteratorAdapter. Usage remains the same and all code</span>
01254 <span class="comment">// outside of the DAP should compile and link with no problems. Added methods</span>
01255 <span class="comment">// to the different classes where Pix is used to include methods to use STL</span>
01256 <span class="comment">// iterators. Replaced the use of Pix within the DAP to use iterators instead.</span>
01257 <span class="comment">// Updated comments for documentation, updated the test suites, and added some</span>
01258 <span class="comment">// unit tests. Updated the Makefile to remove GNU/SLList and GNU/DLList.</span>
01259 <span class="comment">//</span>
01260 <span class="comment">// Revision 1.59.4.17  2002/08/08 06:54:57  jimg</span>
01261 <span class="comment">// Changes for thread-safety. In many cases I found ugly places at the</span>
01262 <span class="comment">// tops of files while looking for globals, et c., and I fixed them up</span>
01263 <span class="comment">// (hopefully making them easier to read, ...). Only the files RCReader.cc</span>
01264 <span class="comment">// and usage.cc actually use pthreads synchronization functions. In other</span>
01265 <span class="comment">// cases I removed static objects where they were used for supposed</span>
01266 <span class="comment">// improvements in efficiency which had never actually been verifiied (and</span>
01267 <span class="comment">// which looked dubious).</span>
01268 <span class="comment">//</span>
01269 <span class="comment">// Revision 1.65  2002/06/18 15:36:24  tom</span>
01270 <span class="comment">// Moved comments and edited to accommodate doxygen documentation-generator.</span>
01271 <span class="comment">//</span>
01272 <span class="comment">// Revision 1.64  2002/06/03 21:53:59  jimg</span>
01273 <span class="comment">// Removed level stuff. The level() and set_level() methods were not being used</span>
01274 <span class="comment">// anymore, so I removed them.</span>
01275 <span class="comment">//</span>
01276 <span class="comment">// Revision 1.59.4.16  2002/05/22 16:57:51  jimg</span>
01277 <span class="comment">// I modified the `data type classes' so that they do not need to be</span>
01278 <span class="comment">// subclassed for clients. It might be the case that, for a complex client,</span>
01279 <span class="comment">// subclassing is still the best way to go, but you're not required to do</span>
01280 <span class="comment">// it anymore.</span>
01281 <span class="comment">//</span>
01282 <span class="comment">// Revision 1.59.4.15  2002/03/29 18:36:40  jimg</span>
01283 <span class="comment">// _duplicate() no longer calls Constructor::_duplicate.</span>
01284 <span class="comment">//</span>
01285 <span class="comment">// Revision 1.59.4.14  2002/03/01 21:03:08  jimg</span>
01286 <span class="comment">// Significant changes to the var(...) methods. These now take a btp_stack</span>
01287 <span class="comment">// pointer and are used by DDS::mark(...). The exact_match methods have also</span>
01288 <span class="comment">// been updated so that leaf variables which contain dots in their names</span>
01289 <span class="comment">// will be found. Note that constructor variables with dots in their names</span>
01290 <span class="comment">// will break the lookup routines unless the ctor is the last field in the</span>
01291 <span class="comment">// constraint expression. These changes were made to fix bug 330.</span>
01292 <span class="comment">//</span>
01293 <span class="comment">// Revision 1.59.4.13  2002/02/20 19:01:25  jimg</span>
01294 <span class="comment">// Changed some comments</span>
01295 <span class="comment">//</span>
01296 <span class="comment">// Revision 1.59.4.12  2001/11/09 15:11:09  rmorris</span>
01297 <span class="comment">// *** empty log message ***</span>
01298 <span class="comment">//</span>
01299 <span class="comment">// Revision 1.59.4.11  2001/10/30 06:55:45  rmorris</span>
01300 <span class="comment">// Win32 porting changes.  Brings core win32 port up-to-date.</span>
01301 <span class="comment">//</span>
01302 <span class="comment">// Revision 1.63  2001/10/14 01:28:38  jimg</span>
01303 <span class="comment">// Merged with release-3-2-8.</span>
01304 <span class="comment">//</span>
01305 <span class="comment">// Revision 1.59.4.10  2001/10/02 17:01:52  jimg</span>
01306 <span class="comment">// Made the behavior of serialize and deserialize uniform. Both methods now</span>
01307 <span class="comment">// use Error exceptions to signal problems with network I/O and InternalErr</span>
01308 <span class="comment">// exceptions to signal other problems. The return codes, always true for</span>
01309 <span class="comment">// serialize and always false for deserialize, are now meaningless. However,</span>
01310 <span class="comment">// by always returning a code that means OK, old code should continue to work.</span>
01311 <span class="comment">//</span>
01312 <span class="comment">// Revision 1.62  2001/09/28 17:50:07  jimg</span>
01313 <span class="comment">// Merged with 3.2.7.</span>
01314 <span class="comment">//</span>
01315 <span class="comment">// Revision 1.59.4.9  2001/09/26 23:25:42  jimg</span>
01316 <span class="comment">// Returned the set_level() and level() methods to the class.</span>
01317 <span class="comment">//</span>
01318 <span class="comment">// Revision 1.59.4.8  2001/09/25 20:30:15  jimg</span>
01319 <span class="comment">// Added is_linear().</span>
01320 <span class="comment">//</span>
01321 <span class="comment">// Revision 1.59.4.7  2001/09/07 00:38:35  jimg</span>
01322 <span class="comment">// Sequence::deserialize(...) now reads all the sequence values at once.</span>
01323 <span class="comment">// Its call semantics are the same as the other classes' versions. Values</span>
01324 <span class="comment">// are stored in the Sequence object using a vector&lt;BaseType *&gt; for each</span>
01325 <span class="comment">// row (those are themselves held in a vector). Three new accessor methods</span>
01326 <span class="comment">// have been added to Sequence (row_value() and two versions of var_value()).</span>
01327 <span class="comment">// BaseType::deserialize(...) now always returns true. This matches with the</span>
01328 <span class="comment">// expectations of most client code (the seqeunce version returned false</span>
01329 <span class="comment">// when it was done reading, but all the calls for sequences must be changed</span>
01330 <span class="comment">// anyway). If an XDR error is found, deserialize throws InternalErr.</span>
01331 <span class="comment">//</span>
01332 <span class="comment">// Revision 1.61  2001/08/24 17:46:22  jimg</span>
01333 <span class="comment">// Resolved conflicts from the merge of release 3.2.6</span>
01334 <span class="comment">//</span>
01335 <span class="comment">// Revision 1.59.4.6  2001/08/18 00:16:22  jimg</span>
01336 <span class="comment">// Removed WIN32 compile guards from using statements.</span>
01337 <span class="comment">//</span>
01338 <span class="comment">// Revision 1.59.4.5  2001/07/28 01:10:42  jimg</span>
01339 <span class="comment">// Some of the numeric type classes did not have copy ctors or operator=.</span>
01340 <span class="comment">// I added those where they were needed.</span>
01341 <span class="comment">// In every place where delete (or delete []) was called, I set the pointer</span>
01342 <span class="comment">// just deleted to zero. Thus if for some reason delete is called again</span>
01343 <span class="comment">// before new memory is allocated there won't be a mysterious crash. This is</span>
01344 <span class="comment">// just good form when using delete.</span>
01345 <span class="comment">// I added calls to www2id and id2www where appropriate. The DAP now handles</span>
01346 <span class="comment">// making sure that names are escaped and unescaped as needed. Connect is</span>
01347 <span class="comment">// set to handle CEs that contain names as they are in the dataset (see the</span>
01348 <span class="comment">// comments/Log there). Servers should not handle escaping or unescaping</span>
01349 <span class="comment">// characters on their own.</span>
01350 <span class="comment">//</span>
01351 <span class="comment">// Revision 1.60  2001/06/15 23:49:02  jimg</span>
01352 <span class="comment">// Merged with release-3-2-4.</span>
01353 <span class="comment">//</span>
01354 <span class="comment">// Revision 1.59.4.4  2001/06/07 16:55:53  jimg</span>
01355 <span class="comment">// Changed the logic of print_all_vals() so that it work when a sequence is</span>
01356 <span class="comment">// returned that contains no values. This can happen if a Sequence is</span>
01357 <span class="comment">// constrained to values that don't appear (e.g., date ranges).</span>
01358 <span class="comment">// Changed the printing of the closing brace to match what happens in</span>
01359 <span class="comment">// Structure::print_all_vals(). Braces will be balanced for Sequences held</span>
01360 <span class="comment">// within Structures, et cetera.</span>
01361 <span class="comment">//</span>
01362 <span class="comment">// Revision 1.59.4.3  2001/06/05 06:49:19  jimg</span>
01363 <span class="comment">// Added the Constructor class which is to Structures, Sequences and Grids</span>
01364 <span class="comment">// what Vector is to Arrays and Lists. This should be used in future</span>
01365 <span class="comment">// refactorings (I thought it was going to be used for the back pointers).</span>
01366 <span class="comment">// Introduced back pointers so children can refer to their parents in</span>
01367 <span class="comment">// hierarchies of variables.</span>
01368 <span class="comment">// Added to Sequence methods to tell if a child sequence is done</span>
01369 <span class="comment">// deserializing its data.</span>
01370 <span class="comment">// Fixed the operator=() and copy ctors; removed redundency from</span>
01371 <span class="comment">// _duplicate().</span>
01372 <span class="comment">// Changed the way serialize and deserialize work for sequences. Now SOI and</span>
01373 <span class="comment">// EOS markers are written for every `level' of a nested Sequence. This</span>
01374 <span class="comment">// should fixed nested Sequences. There is still considerable work to do</span>
01375 <span class="comment">// for these to work in all cases.</span>
01376 <span class="comment">//</span>
01377 <span class="comment">// Revision 1.59.4.2  2001/05/16 18:58:26  dan</span>
01378 <span class="comment">// Modified serialize method to break out of while loop after</span>
01379 <span class="comment">// serializing member elements if the current sequence is not</span>
01380 <span class="comment">// at level 0.</span>
01381 <span class="comment">//</span>
01382 <span class="comment">// Revision 1.59.4.1  2001/05/12 00:05:07  jimg</span>
01383 <span class="comment">// Fixed bugs in _duplicate(). The new fields associated with access by row</span>
01384 <span class="comment">// number were not being copied.</span>
01385 <span class="comment">// Added a toString() implementation.</span>
01386 <span class="comment">//</span>
01387 <span class="comment">// Revision 1.59  2000/10/06 01:26:05  jimg</span>
01388 <span class="comment">// Changed the way serialize() calls read(). The status from read() is</span>
01389 <span class="comment">// returned by the Structure and Sequence serialize() methods; ignored by</span>
01390 <span class="comment">// all others. Any exceptions thrown by read() are caught and discarded.</span>
01391 <span class="comment">// serialize() returns false if read() throws an exception. This should</span>
01392 <span class="comment">// be fixed once all the servers build using the new read() definition.</span>
01393 <span class="comment">//</span>
01394 <span class="comment">// Revision 1.58  2000/09/22 02:17:21  jimg</span>
01395 <span class="comment">// Rearranged source files so that the CVS logs appear at the end rather than</span>
01396 <span class="comment">// the start. Also made the ifdef guard symbols use the same naming scheme and</span>
01397 <span class="comment">// wrapped headers included in other headers in those guard symbols (to cut</span>
01398 <span class="comment">// down on extraneous file processing - See Lakos).</span>
01399 <span class="comment">//</span>
01400 <span class="comment">// Revision 1.57  2000/09/21 16:22:08  jimg</span>
01401 <span class="comment">// Merged changes from Jose Garcia that add exceptions to the software.</span>
01402 <span class="comment">// Many methods that returned error codes now throw exectptions. There are</span>
01403 <span class="comment">// two classes which are thrown by the software, Error and InternalErr.</span>
01404 <span class="comment">// InternalErr is used to report errors within the library or errors using</span>
01405 <span class="comment">// the library. Error is used to reprot all other errors. Since InternalErr</span>
01406 <span class="comment">// is a subclass of Error, programs need only to catch Error.</span>
01407 <span class="comment">//</span>
01408 <span class="comment">// Revision 1.56  2000/09/11 16:31:48  jimg</span>
01409 <span class="comment">// Added methods to make it simpler to access Sequences by row number. The new</span>
01410 <span class="comment">// methods are: get_row(), get_row_number(), get_starting_row_number(),</span>
01411 <span class="comment">// get_ending_row_number(), get_row_stride(), set_row_number_constraint(). The</span>
01412 <span class="comment">// starting and ending row numbers refer to constraints placed on the sequence,</span>
01413 <span class="comment">// to get the number of rows in the current sequence, use the length() method.</span>
01414 <span class="comment">//</span>
01415 <span class="comment">// Revision 1.55  2000/08/16 00:38:22  jimg</span>
01416 <span class="comment">// Added the getRowNumber method.</span>
01417 <span class="comment">//</span>
01418 <span class="comment">// Revision 1.54  2000/07/09 22:05:36  rmorris</span>
01419 <span class="comment">// Changes to increase portability, minimize ifdef's for win32 and account</span>
01420 <span class="comment">// for differences in the iostreams implementations.</span>
01421 <span class="comment">//</span>
01422 <span class="comment">// Revision 1.53  2000/06/16 18:15:00  jimg</span>
01423 <span class="comment">// Merged with 3.1.7</span>
01424 <span class="comment">//</span>
01425 <span class="comment">// Revision 1.49.6.3  2000/06/07 23:05:30  jimg</span>
01426 <span class="comment">// The first_*() methods return 0 if there are no variables</span>
01427 <span class="comment">//</span>
01428 <span class="comment">// Revision 1.51.2.2  2000/02/17 05:03:13  jimg</span>
01429 <span class="comment">// Added file and line number information to calls to InternalErr.</span>
01430 <span class="comment">// Resolved compile-time problems with read due to a change in its</span>
01431 <span class="comment">// parameter list given that errors are now reported using exceptions.</span>
01432 <span class="comment">//</span>
01433 <span class="comment">// Revision 1.51.2.1  2000/01/28 22:14:05  jgarcia</span>
01434 <span class="comment">// Added exception handling and modify add_var to get a copy of the object</span>
01435 <span class="comment">//</span>
01436 <span class="comment">// Revision 1.52  2000/01/27 06:29:57  jimg</span>
01437 <span class="comment">// Resolved conflicts from merge with release-3-1-4</span>
01438 <span class="comment">//</span>
01439 <span class="comment">// Revision 1.49.6.2  2000/01/26 23:57:15  jimg</span>
01440 <span class="comment">// Fixed the return type of string::find.</span>
01441 <span class="comment">//</span>
01442 <span class="comment">// Revision 1.51  1999/12/31 00:55:11  jimg</span>
01443 <span class="comment">// Fixed up the progress indicator</span>
01444 <span class="comment">//</span>
01445 <span class="comment">// Revision 1.50  1999/09/03 22:07:44  jimg</span>
01446 <span class="comment">// Merged changes from release-3-1-1</span>
01447 <span class="comment">//</span>
01448 <span class="comment">// Revision 1.49.6.1  1999/08/28 06:43:04  jimg</span>
01449 <span class="comment">// Fixed the implementation/interface pragmas and misc comments</span>
01450 <span class="comment">//</span>
01451 <span class="comment">// Revision 1.49  1999/04/29 02:29:31  jimg</span>
01452 <span class="comment">// Merge of no-gnu branch</span>
01453 <span class="comment">//</span>
01454 <span class="comment">// Revision 1.48  1999/04/22 22:28:26  jimg</span>
01455 <span class="comment">// Uses dynamic_cast</span>
01456 <span class="comment">//</span>
01457 <span class="comment">// Revision 1.47  1998/09/17 17:18:39  jimg</span>
01458 <span class="comment">// Changes for the new variable lookup scheme. Fields of ctor types no longer</span>
01459 <span class="comment">// need to be fully qualified. my.thing.f1 can now be named `f1' in a CE. Note</span>
01460 <span class="comment">// that if there are two `f1's in a dataset, the first will be silently used;</span>
01461 <span class="comment">// There's no warning about the situation. The new code in the var member</span>
01462 <span class="comment">// function passes a stack of BaseType pointers so that the projection</span>
01463 <span class="comment">// information (send_p field) can be set properly.</span>
01464 <span class="comment">//</span>
01465 <span class="comment">// Revision 1.46.6.1  1999/02/02 21:57:01  jimg</span>
01466 <span class="comment">// String to string version</span>
01467 <span class="comment">//</span>
01468 <span class="comment">// Revision 1.46  1998/04/03 17:41:42  jimg</span>
01469 <span class="comment">// Patch from Jake Hamby to print_all_vals(). deserialize needed to be called</span>
01470 <span class="comment">// before the first call to print_val.</span>
01471 <span class="comment">//</span>
01472 <span class="comment">// Revision 1.45  1998/03/26 00:20:04  jimg</span>
01473 <span class="comment">// Removed DODS_DEBUG define.</span>
01474 <span class="comment">//</span>
01475 <span class="comment">// Revision 1.44  1998/03/17 17:39:24  jimg</span>
01476 <span class="comment">// Added an implementation of element_count().</span>
01477 <span class="comment">//</span>
01478 <span class="comment">// Revision 1.43  1998/02/19 19:41:27  jimg</span>
01479 <span class="comment">// Changed name of ...end_of_sequence to ...start_of_sequence since that is</span>
01480 <span class="comment">// now how it is used. I hope this will reduce confusion.</span>
01481 <span class="comment">// Changed the name of read_end_marker to read_marker (since they are not</span>
01482 <span class="comment">// always end markers anymore).</span>
01483 <span class="comment">//</span>
01484 <span class="comment">// Revision 1.42  1998/02/18 01:00:48  jimg</span>
01485 <span class="comment">// Reverted to the old transfer scheme for Sequences.</span>
01486 <span class="comment">// Added EOI/EOS markers.</span>
01487 <span class="comment">// The code supports (via version numbers in the header of the return</span>
01488 <span class="comment">// documents) reading from the old-style servers (which do not have EOI/EOS</span>
01489 <span class="comment">// markers.</span>
01490 <span class="comment">//</span>
01491 <span class="comment">// Revision 1.41  1998/02/05 20:13:55  jimg</span>
01492 <span class="comment">// DODS now compiles with gcc 2.8.x</span>
01493 <span class="comment">//</span>
01494 <span class="comment">// Revision 1.40  1997/12/31 20:55:15  jimg</span>
01495 <span class="comment">// Changed name of read_level() to level() to reduce confusion in child</span>
01496 <span class="comment">// classes. Also changed return type from unsigned int to int. This allows</span>
01497 <span class="comment">// callers to store flags, etc. in the _level field - not the best thing, but</span>
01498 <span class="comment">// a realistic expectation</span>
01499 <span class="comment">//</span>
01500 <span class="comment">// Revision 1.39  1997/12/16 01:36:18  jimg</span>
01501 <span class="comment">// Merged changes from release-2.14d.</span>
01502 <span class="comment">//</span>
01503 <span class="comment">// Revision 1.38  1997/12/16 00:41:22  jimg</span>
01504 <span class="comment">// Added debugging code to help finder problems reading sequences from older</span>
01505 <span class="comment">// servers.</span>
01506 <span class="comment">//</span>
01507 <span class="comment">// Revision 1.37  1997/09/22 22:48:17  jimg</span>
01508 <span class="comment">// Added DDS * to deserialize parameters.</span>
01509 <span class="comment">// Added End of instance and end of sequence marker constants.</span>
01510 <span class="comment">// Change serialize() and deserialize() mfuncs so that the new markers are</span>
01511 <span class="comment">// used and embedded sequences are sent without needlessly replicating the</span>
01512 <span class="comment">// enclosing sequence's instance.</span>
01513 <span class="comment">//</span>
01514 <span class="comment">// Revision 1.36  1997/07/15 21:53:25  jimg</span>
01515 <span class="comment">// Changed length member function to return -1 instead of 0. Thus the default,</span>
01516 <span class="comment">// when a subclass does not define its own version of this member function, is</span>
01517 <span class="comment">// to return -1. This value will be easy to differentiate from 0, which could</span>
01518 <span class="comment">// mean that the sequence has zero elements.</span>
01519 <span class="comment">//</span>
01520 <span class="comment">// Revision 1.35  1997/03/08 19:02:05  jimg</span>
01521 <span class="comment">// Changed default param to check_semantics() from  to String()</span>
01522 <span class="comment">// and removed the default from the argument list in the mfunc definition</span>
01523 <span class="comment">//</span>
01524 <span class="comment">// Revision 1.34  1997/02/28 01:27:57  jimg</span>
01525 <span class="comment">// Changed check_semantics() so that it now returns error messages in a String</span>
01526 <span class="comment">// object (passed by reference).</span>
01527 <span class="comment">//</span>
01528 <span class="comment">// Revision 1.33  1997/02/10 02:32:42  jimg</span>
01529 <span class="comment">// Added assert statements for pointers</span>
01530 <span class="comment">//</span>
01531 <span class="comment">// Revision 1.32  1996/10/08 17:07:59  jimg</span>
01532 <span class="comment">// Fixed deserialize so that when called on a null Sequence it will return</span>
01533 <span class="comment">// true.</span>
01534 <span class="comment">//</span>
01535 <span class="comment">// Revision 1.31  1996/09/16 18:09:16  jimg</span>
01536 <span class="comment">// Fixed var(const String name) so that it would correctly descend names of the</span>
01537 <span class="comment">// form &lt;base&gt;.&lt;name&gt; where &lt;name&gt; may itself contain `dots'.</span>
01538 <span class="comment">//</span>
01539 <span class="comment">// Revision 1.30  1996/08/26 21:12:59  jimg</span>
01540 <span class="comment">// Changes for version 2.07</span>
01541 <span class="comment">//</span>
01542 <span class="comment">// Revision 1.29  1996/08/13 18:36:12  jimg</span>
01543 <span class="comment">// Added void casts to values computed in print_val() for loops.</span>
01544 <span class="comment">//</span>
01545 <span class="comment">// Revision 1.28  1996/06/04 21:33:37  jimg</span>
01546 <span class="comment">// Multiple connections are now possible. It is now possible to open several</span>
01547 <span class="comment">// URLs at the same time and read from them in a round-robin fashion. To do</span>
01548 <span class="comment">// this I added data source and sink parameters to the serialize and</span>
01549 <span class="comment">// deserialize mfuncs. Connect was also modified so that it manages the data</span>
01550 <span class="comment">// source `object' (which is just an XDR pointer).</span>
01551 <span class="comment">//</span>
01552 <span class="comment">// Revision 1.27  1996/05/31 23:29:58  jimg</span>
01553 <span class="comment">// Updated copyright notice.</span>
01554 <span class="comment">//</span>
01555 <span class="comment">// Revision 1.26  1996/05/29 22:08:46  jimg</span>
01556 <span class="comment">// Made changes necessary to support CEs that return the value of a function</span>
01557 <span class="comment">// instead of the value of a variable. This was done so that it would be</span>
01558 <span class="comment">// possible to translate Sequences into Arrays without first reading the</span>
01559 <span class="comment">// entire sequence over the network.</span>
01560 <span class="comment">//</span>
01561 <span class="comment">// Revision 1.25  1996/05/22 18:05:15  jimg</span>
01562 <span class="comment">// Merged files from the old netio directory into the dap directory.</span>
01563 <span class="comment">// Removed the errmsg library from the software.</span>
01564 <span class="comment">//</span>
01565 <span class="comment">// Revision 1.24  1996/05/16 22:44:52  jimg</span>
01566 <span class="comment">// Dan's changes for 2.0.</span>
01567 <span class="comment">//</span>
01568 <span class="comment">// Revision 1.23  1996/05/14 15:38:35  jimg</span>
01569 <span class="comment">// These changes have already been checked in once before. However, I</span>
01570 <span class="comment">// corrupted the source repository and restored it from a 5/9/96 backup</span>
01571 <span class="comment">// tape. The previous version's log entry should cover the changes.</span>
01572 <span class="comment">//</span>
01573 <span class="comment">// Revision 1.22  1996/04/05 00:21:38  jimg</span>
01574 <span class="comment">// Compiled with g++ -Wall and fixed various warnings.</span>
01575 <span class="comment">//</span>
01576 <span class="comment">// Revision 1.21  1996/04/04 18:10:46  jimg</span>
01577 <span class="comment">// Merged changes from version 1.1.1.</span>
01578 <span class="comment">// Fixed a bug in serialize() which caused the sequence serialization to end</span>
01579 <span class="comment">// when the current CE first evaluated to false</span>
01580 <span class="comment">//</span>
01581 <span class="comment">// Revision 1.20  1996/03/05 17:44:21  jimg</span>
01582 <span class="comment">// Added ce_eval to serailize member function.</span>
01583 <span class="comment">//</span>
01584 <span class="comment">// Revision 1.19  1996/02/02 00:31:12  jimg</span>
01585 <span class="comment">// Merge changes for DODS-1.1.0 into DODS-2.x</span>
01586 <span class="comment">//</span>
01587 <span class="comment">// Revision 1.18  1995/12/09  01:06:54  jimg</span>
01588 <span class="comment">// Added changes so that relational operators will work properly for all the</span>
01589 <span class="comment">// datatypes (including Sequences). The relational ops are evaluated in</span>
01590 <span class="comment">// DDS::eval_constraint() after being parsed by DDS::parse_constraint().</span>
01591 <span class="comment">//</span>
01592 <span class="comment">// Revision 1.17  1995/12/06  21:56:29  jimg</span>
01593 <span class="comment">// Added `constrained' flag to print_decl.</span>
01594 <span class="comment">// Removed third parameter of read.</span>
01595 <span class="comment">// Modified print_decl() to print only those parts of a dataset that are</span>
01596 <span class="comment">// selected when `constrained' is true.</span>
01597 <span class="comment">//</span>
01598 <span class="comment">// Revision 1.16  1995/10/23  23:21:01  jimg</span>
01599 <span class="comment">// Added _send_p and _read_p fields (and their accessors) along with the</span>
01600 <span class="comment">// virtual mfuncs set_send_p() and set_read_p().</span>
01601 <span class="comment">//</span>
01602 <span class="comment">// Revision 1.15  1995/08/26  00:31:43  jimg</span>
01603 <span class="comment">// Removed code enclosed in #ifdef NEVER #endif.</span>
01604 <span class="comment">//</span>
01605 <span class="comment">// Revision 1.14  1995/08/23  00:11:06  jimg</span>
01606 <span class="comment">// Changed old, deprecated member functions to new ones.</span>
01607 <span class="comment">// Switched from String representation of type to enum.</span>
01608 <span class="comment">//</span>
01609 <span class="comment">// Revision 1.13.2.1  1995/09/14 20:58:15  jimg</span>
01610 <span class="comment">// Moved some loop index variables out of the loop statement.</span>
01611 <span class="comment">//</span>
01612 <span class="comment">// Revision 1.13  1995/07/09  21:29:03  jimg</span>
01613 <span class="comment">// Added copyright notice.</span>
01614 <span class="comment">//</span>
01615 <span class="comment">// Revision 1.12  1995/05/10  15:34:03  jimg</span>
01616 <span class="comment">// Failed to change `config.h' to `config_dap.h' in these files.</span>
01617 <span class="comment">//</span>
01618 <span class="comment">// Revision 1.11  1995/05/10  13:45:27  jimg</span>
01619 <span class="comment">// Changed the name of the configuration header file from `config.h' to</span>
01620 <span class="comment">// `config_dap.h' so that other libraries could have header files which were</span>
01621 <span class="comment">// installed in the DODS include directory without overwriting this one. Each</span>
01622 <span class="comment">// config header should follow the convention config_&lt;name&gt;.h.</span>
01623 <span class="comment">//</span>
01624 <span class="comment">// Revision 1.10  1995/03/16  17:29:11  jimg</span>
01625 <span class="comment">// Added include config_dap.h to top of include list.</span>
01626 <span class="comment">// Added TRACE_NEW switched dbnew includes.</span>
01627 <span class="comment">// Fixed bug in read_val() where **val was passed incorrectly to</span>
01628 <span class="comment">// subordinate read_val() calls.</span>
01629 <span class="comment">//</span>
01630 <span class="comment">// Revision 1.9  1995/03/04  14:34:49  jimg</span>
01631 <span class="comment">// Major modifications to the transmission and representation of values:</span>
01632 <span class="comment">// Added card() virtual function which is true for classes that</span>
01633 <span class="comment">// contain cardinal types (byte, int float, string).</span>
01634 <span class="comment">// Changed the representation of Str from the C rep to a C++</span>
01635 <span class="comment">// class represenation.</span>
01636 <span class="comment">// Chnaged read_val and store_val so that they take and return</span>
01637 <span class="comment">// types that are stored by the object (e.g., inthe case of Str</span>
01638 <span class="comment">// an URL, read_val returns a C++ String object).</span>
01639 <span class="comment">// Modified Array representations so that arrays of card()</span>
01640 <span class="comment">// objects are just that - no more storing strings, ... as</span>
01641 <span class="comment">// C would store them.</span>
01642 <span class="comment">// Arrays of non cardinal types are arrays of the DODS objects (e.g.,</span>
01643 <span class="comment">// an array of a structure is represented as an array of Structure</span>
01644 <span class="comment">// objects).</span>
01645 <span class="comment">//</span>
01646 <span class="comment">// Revision 1.8  1995/02/10  02:23:02  jimg</span>
01647 <span class="comment">// Added DBMALLOC includes and switch to code which uses malloc/free.</span>
01648 <span class="comment">// Private and protected symbols now start with `_'.</span>
01649 <span class="comment">// Added new accessors for name and type fields of BaseType; the old ones</span>
01650 <span class="comment">// will be removed in a future release.</span>
01651 <span class="comment">// Added the store_val() mfunc. It stores the given value in the object's</span>
01652 <span class="comment">// internal buffer.</span>
01653 <span class="comment">// Made both List and Str handle their values via pointers to memory.</span>
01654 <span class="comment">// Fixed read_val().</span>
01655 <span class="comment">// Made serialize/deserialize handle all malloc/free calls (even in those</span>
01656 <span class="comment">// cases where xdr initiates the allocation).</span>
01657 <span class="comment">// Fixed print_val().</span>
01658 <span class="comment">//</span>
01659 <span class="comment">// Revision 1.7  1995/01/19  20:05:26  jimg</span>
01660 <span class="comment">// ptr_duplicate() mfunc is now abstract virtual.</span>
01661 <span class="comment">// Array, ... Grid duplicate mfuncs were modified to take pointers, not</span>
01662 <span class="comment">// references.</span>
01663 <span class="comment">//</span>
01664 <span class="comment">// Revision 1.6  1995/01/11  15:54:53  jimg</span>
01665 <span class="comment">// Added modifications necessary for BaseType's static XDR pointers. This</span>
01666 <span class="comment">// was mostly a name change from xdrin/out to _xdrin/out.</span>
01667 <span class="comment">// Removed the two FILE pointers from ctors, since those are now set with</span>
01668 <span class="comment">// functions which are friends of BaseType.</span>
01669 <span class="comment">//</span>
01670 <span class="comment">// Revision 1.5  1994/12/15  21:21:13  dan</span>
01671 <span class="comment">// Modified Sequence class to directly inherit from class BaseType</span>
01672 <span class="comment">// Modified constructors to reflect new inheritance.</span>
01673 <span class="comment">//</span>
01674 <span class="comment">// Revision 1.4  1994/12/08  15:55:58  dan</span>
01675 <span class="comment">// Added data transmission member functions serialize() and deserialize()</span>
01676 <span class="comment">// Modified size() member function to return cumulative size of all members.</span>
01677 <span class="comment">// Fixed the duplicate() member function to correctly access the data members</span>
01678 <span class="comment">// of the sequence being duplicated.</span>
01679 <span class="comment">//</span>
01680 <span class="comment">// Revision 1.3  1994/10/17  23:34:49  jimg</span>
01681 <span class="comment">// Added code to print_decl so that variable declarations are pretty</span>
01682 <span class="comment">// printed.</span>
01683 <span class="comment">// Added private mfunc duplicate().</span>
01684 <span class="comment">// Added ptr_duplicate().</span>
01685 <span class="comment">// Added Copy ctor, dtor and operator=.</span>
01686 <span class="comment">//</span>
01687 <span class="comment">// Revision 1.2  1994/09/23  14:48:31  jimg</span>
01688 <span class="comment">// Fixed some errors in comments.</span>
01689 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Feb 4 23:43:04 2004 for libdap++ by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
